;(function (root, factory) {
  if (typeof exports === "object") {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    var f = factory();
    root.alk = f.alk;
    root.pcmws = f.pcmws;
  }
}(this, function () {
  var ALKMAPS = {};
  var goog = this.goog = {};
this.CLOSURE_NO_DEPS = true;
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will attempt to load Closure's deps file, unless
 * the global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects
 * to include their own deps file(s) from different locations.
 *
 * Avoid including base.js more than once. This is strictly discouraged and not
 * supported. goog.require(...) won't work properly in that case.
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
 * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
 * {@code goog.define} will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_DEFINES;


/**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
 * </pre>
 *
 * @type {Object<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Returns true if the specified value is not undefined.
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  // void 0 always evaluates to undefined and hence we do not need to depend on
  // the definition of the global variable named 'undefined'.
  return val !== void 0;
};

/**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is `goog.global`.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part] && cur[part] !== Object.prototype[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retrieved from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled the default can be overridden using the compiler
 * options or the value set in the CLOSURE_DEFINES object.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&
        // Anti DOM-clobbering runtime check (b/37736576).
        /** @type {?} */ (goog.global.CLOSURE_UNCOMPILED_DEFINES).nodeType ===
            undefined &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
    } else if (
        goog.global.CLOSURE_DEFINES &&
        // Anti DOM-clobbering runtime check (b/37736576).
        /** @type {?} */ (goog.global.CLOSURE_DEFINES).nodeType === undefined &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production. It can be easily stripped
 * by specifying --define goog.DEBUG=false to the Closure Compiler aka
 * JSCompiler. For example, most toString() methods should be declared inside an
 * "if (goog.DEBUG)" conditional because they are generally used for debugging
 * purposes and it is difficult for the JSCompiler to statically determine
 * whether they are used.
 */
goog.define('goog.DEBUG', true);


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as a compiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he).
 *
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the compiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * @define {boolean} Whether a project is expected to be running in strict mode.
 *
 * This define can be used to trigger alternate implementations compatible with
 * running in EcmaScript Strict mode or warn about unavailable functionality.
 * @see https://goo.gl/PudQ4y
 *
 */
goog.define('goog.STRICT_MODE_COMPATIBLE', false);


/**
 * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
 *     be disallowed in the compilation unit.
 */
goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);


/**
 * @define {boolean} Whether to use a Chrome app CSP-compliant method for
 *     loading scripts via goog.require. @see appendScriptSrcNode_.
 */
goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);


/**
 * Defines a namespace in Closure.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * The presence of one or more goog.provide() calls in a file indicates
 * that the file defines the given objects/namespaces.
 * Provided symbols must not be null or undefined.
 *
 * In addition, goog.provide() creates the object stubs for a namespace
 * (for example, goog.provide("goog.foo.bar") will create the object
 * goog.foo.bar if it does not already exist).
 *
 * Build tools also scan for provide/require/module statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 *
 * @see goog.require
 * @see goog.module
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (goog.isInModuleLoader_()) {
    throw new Error('goog.provide can not be used within a goog.module.');
  }
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
  }

  goog.constructNamespace_(name);
};


/**
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 * @param {Object=} opt_obj The object to embed in the namespace.
 * @private
 */
goog.constructNamespace_ = function(name, opt_obj) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name, opt_obj);
};


/**
 * Module identifier validation regexp.
 * Note: This is a conservative check, it is very possible to be more lenient,
 *   the primary exclusion here is "/" and "\" and a leading ".", these
 *   restrictions are intended to leave the door open for using goog.require
 *   with relative file paths rather than module identifiers.
 * @private
 */
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;


/**
 * Defines a module in Closure.
 *
 * Marks that this file must be loaded as a module and claims the namespace.
 *
 * A namespace may only be defined once in a codebase. It may be defined using
 * goog.provide() or goog.module().
 *
 * goog.module() has three requirements:
 * - goog.module may not be used in the same file as goog.provide.
 * - goog.module must be the first statement in the file.
 * - only one goog.module is allowed per file.
 *
 * When a goog.module annotated file is loaded, it is enclosed in
 * a strict function closure. This means that:
 * - any variables declared in a goog.module file are private to the file
 * (not global), though the compiler is expected to inline the module.
 * - The code must obey all the rules of "strict" JavaScript.
 * - the file will be marked as "use strict"
 *
 * NOTE: unlike goog.provide, goog.module does not declare any symbols by
 * itself. If declared symbols are desired, use
 * goog.module.declareLegacyNamespace().
 *
 *
 * See the public goog.module proposal: http://goo.gl/Va1hin
 *
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part", is expected but not required.
 * @return {void}
 */
goog.module = function(name) {
  if (!goog.isString(name) || !name ||
      name.search(goog.VALID_MODULE_RE_) == -1) {
    throw new Error('Invalid module identifier');
  }
  if (!goog.isInModuleLoader_()) {
    throw new Error(
        'Module ' + name + ' has been loaded incorrectly. Note, ' +
        'modules cannot be loaded as normal scripts. They require some kind of ' +
        'pre-processing step. You\'re likely trying to load a module via a ' +
        'script tag or as a part of a concatenated bundle without rewriting the ' +
        'module. For more info see: ' +
        'https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.');
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw new Error('goog.module may only be called once per module.');
  }

  // Store the module name for the loader.
  goog.moduleLoaderState_.moduleName = name;
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice.
    // A goog.module/goog.provide maps a goog.require to a specific file
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
  }
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 *
 * Note: This is not an alternative to goog.require, it does not
 * indicate a hard dependency, instead it is used to indicate
 * an optional dependency or to access the exports of a module
 * that has already been loaded.
 * @suppress {missingProvide}
 */
goog.module.get = function(name) {
  return goog.module.getInternal_(name);
};


/**
 * @param {string} name The module identifier.
 * @return {?} The module exports for an already loaded module or null.
 * @private
 */
goog.module.getInternal_ = function(name) {
  if (!COMPILED) {
    if (name in goog.loadedModules_) {
      return goog.loadedModules_[name];
    } else if (!goog.implicitNamespaces_[name]) {
      var ns = goog.getObjectByName(name);
      return ns != null ? ns : null;
    }
  }
  return null;
};


/**
 * @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}
 */
goog.moduleLoaderState_ = null;


/**
 * @private
 * @return {boolean} Whether a goog.module is currently being initialized.
 */
goog.isInModuleLoader_ = function() {
  return goog.moduleLoaderState_ != null;
};


/**
 * Provide the module's exports as a globally accessible object under the
 * module's declared name.  This is intended to ease migration to goog.module
 * for files that have existing usages.
 * @suppress {missingProvide}
 */
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInModuleLoader_()) {
    throw new Error(
        'goog.module.declareLegacyNamespace must be called from ' +
        'within a goog.module');
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw new Error(
        'goog.module must be called prior to ' +
        'goog.module.declareLegacyNamespace.');
  }
  goog.moduleLoaderState_.declareLegacyNamespace = true;
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    opt_message = opt_message || '';
    throw new Error(
        'Importing test-only code into non-debug environment' +
        (opt_message ? ': ' + opt_message : '.'));
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 * Before using goog.forwardDeclare, please read the documentation at
 * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to
 * understand the options and tradeoffs when working with forward declarations.
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 */
goog.forwardDeclare = function(name) {};


/**
 * Forward declare type information. Used to assign types to goog.global
 * referenced object that would otherwise result in unknown type references
 * and thus block property disambiguation.
 */
goog.forwardDeclare('Document');
goog.forwardDeclare('HTMLScriptElement');
goog.forwardDeclare('XMLHttpRequest');


if (!COMPILED) {
  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return (name in goog.loadedModules_) ||
        (!goog.implicitNamespaces_[name] &&
         goog.isDefAndNotNull(goog.getObjectByName(name)));
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {!Object<string, (boolean|undefined)>}
   * @private
   */
  goog.implicitNamespaces_ = {'goog.module': true};

  // NOTE: We add goog.module as an implicit namespace as goog.module is defined
  // here and because the existing module package has not been moved yet out of
  // the goog.module namespace. This satisifies both the debug loader and
  // ahead-of-time dependency management.
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var i = 0; i < parts.length; i++) {
    cur = cur[parts[i]];
    if (!goog.isDefAndNotNull(cur)) {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {!Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {!Array<string>} provides An array of strings with
 *     the names of the objects this file provides.
 * @param {!Array<string>} requires An array of strings with
 *     the names of the objects this file requires.
 * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
 *     how the file must be loaded.  The boolean 'true' is equivalent
 *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
 *     and values include {'module': 'goog'} and {'lang': 'es6'}.
 */
goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {
      opt_loadFlags = opt_loadFlags ? {'module': 'goog'} : {};
    }
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      deps.loadFlags[path] = opt_loadFlags;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};




// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
//
// User-defined namespaces may need their own deps file. For a reference on
// creating a deps file, see:
// Externally: https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work was done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * @param {string} msg
 * @private
 */
goog.logToConsole_ = function(msg) {
  if (goog.global.console) {
    goog.global.console['error'](msg);
  }
};


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the compiler.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 * @return {?} If called within a goog.module file, the associated namespace or
 *     module otherwise null.
 */
goog.require = function(name) {
  // If the object already exists we do not need to do anything.
  if (!COMPILED) {
    if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {
      goog.maybeProcessDeferredDep_(name);
    }

    if (goog.isProvided_(name)) {
      if (goog.isInModuleLoader_()) {
        return goog.module.getInternal_(name);
      }
    } else if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.writeScripts_(path);
      } else {
        var errorMessage = 'goog.require could not find: ' + name;
        goog.logToConsole_(errorMessage);

        throw new Error(errorMessage);
      }
    }

    return null;
  }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to attempt to load Closure's deps file. By default, when uncompiled,
 * deps files will attempt to be loaded.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 * @type {(function(string): boolean)|undefined}
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function() {
  throw new Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  // instance_ is immediately set to prevent issues with sealed constructors
  // such as are encountered when a constructor is returned as the export object
  // of a goog.module in unoptimized code.
  ctor.instance_ = undefined;
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * @define {boolean} Whether to load goog.modules using {@code eval} when using
 * the debug loader.  This provides a better debugging experience as the
 * source is unmodified and can be edited using Chrome Workspaces or similar.
 * However in some environments the use of {@code eval} is banned
 * so we provide an alternative.
 */
goog.define('goog.LOAD_MODULE_USING_EVAL', true);


/**
 * @define {boolean} Whether the exports of goog.modules should be sealed when
 * possible.
 */
goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);


/**
 * The registry of initialized modules:
 * the module identifier to module exports map.
 * @private @const {!Object<string, ?>}
 */
goog.loadedModules_ = {};


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


/**
 * @define {string} How to decide whether to transpile.  Valid values
 * are 'always', 'never', and 'detect'.  The default ('detect') is to
 * use feature detection to determine which language levels need
 * transpilation.
 */
// NOTE(user): we could expand this to accept a language level to bypass
// detection: e.g. goog.TRANSPILE == 'es5' would transpile ES6 files but
// would leave ES3 and ES5 files alone.
goog.define('goog.TRANSPILE', 'detect');


/**
 * @define {string} Path to the transpiler.  Executing the script at this
 * path (relative to base.js) should define a function $jscomp.transpile.
 */
goog.define('goog.TRANSPILER', 'transpile.js');


if (goog.DEPENDENCIES_ENABLED) {
  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {{
   *   loadFlags: !Object<string, !Object<string, string>>,
   *   nameToPath: !Object<string, string>,
   *   requires: !Object<string, !Object<string, boolean>>,
   *   visited: !Object<string, boolean>,
   *   written: !Object<string, boolean>,
   *   deferred: !Object<string, string>
   * }}
   */
  goog.dependencies_ = {
    loadFlags: {},  // 1 to 1

    nameToPath: {},  // 1 to 1

    requires: {},  // 1 to many

    // Used when resolving dependencies to prevent us from visiting file twice.
    visited: {},

    written: {},  // Used to keep track of script files we have written.

    deferred: {}  // Used to track deferred module evaluations in old IEs
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    /** @type {Document} */
    var doc = goog.global.document;
    return doc != null && 'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.isDef(goog.global.CLOSURE_BASE_PATH) &&
        // Anti DOM-clobbering runtime check (b/37736576).
        goog.isString(goog.global.CLOSURE_BASE_PATH)) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    /** @type {Document} */
    var doc = goog.global.document;
    // If we have a currentScript available, use it exclusively.
    var currentScript = doc.currentScript;
    if (currentScript) {
      var scripts = [currentScript];
    } else {
      var scripts = doc.getElementsByTagName('SCRIPT');
    }
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);
      var src = script.src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @private
   */
  goog.importScript_ = function(src, opt_sourceText) {
    var importScript =
        goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    if (importScript(src, opt_sourceText)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /**
   * Whether the browser is IE9 or earlier, which needs special handling
   * for deferred modules.
   * @const @private {boolean}
   */
  goog.IS_OLD_IE_ =
      !!(!goog.global.atob && goog.global.document && goog.global.document.all);


  /**
   * Whether IE9 or earlier is waiting on a dependency.  This ensures that
   * deferred modules that have no non-deferred dependencies actually get
   * loaded, since if we defer them and then never pull in a non-deferred
   * script, then `goog.loadQueuedModules_` will never be called.  Instead,
   * if not waiting on anything we simply don't defer in the first place.
   * @private {boolean}
   */
  goog.oldIeWaiting_ = false;


  /**
   * Given a URL initiate retrieval and execution of a script that needs
   * pre-processing.
   * @param {string} src Script source URL.
   * @param {boolean} isModule Whether this is a goog.module.
   * @param {boolean} needsTranspile Whether this source needs transpilation.
   * @private
   */
  goog.importProcessedScript_ = function(src, isModule, needsTranspile) {
    // In an attempt to keep browsers from timing out loading scripts using
    // synchronous XHRs, put each load in its own script block.
    var bootstrap = 'goog.retrieveAndExec_("' + src + '", ' + isModule + ', ' +
        needsTranspile + ');';

    goog.importScript_('', bootstrap);
  };


  /** @private {!Array<string>} */
  goog.queuedModules_ = [];


  /**
   * Return an appropriate module text. Suitable to insert into
   * a script tag (that is unescaped).
   * @param {string} srcUrl
   * @param {string} scriptText
   * @return {string}
   * @private
   */
  goog.wrapModule_ = function(srcUrl, scriptText) {
    if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
      return '' +
          'goog.loadModule(function(exports) {' +
          '"use strict";' + scriptText +
          '\n' +  // terminate any trailing single line comment.
          ';return exports' +
          '});' +
          '\n//# sourceURL=' + srcUrl + '\n';
    } else {
      return '' +
          'goog.loadModule(' +
          goog.global.JSON.stringify(
              scriptText + '\n//# sourceURL=' + srcUrl + '\n') +
          ');';
    }
  };

  // On IE9 and earlier, it is necessary to handle
  // deferred module loads. In later browsers, the
  // code to be evaluated is simply inserted as a script
  // block in the correct order. To eval deferred
  // code at the right time, we piggy back on goog.require to call
  // goog.maybeProcessDeferredDep_.
  //
  // The goog.requires are used both to bootstrap
  // the loading process (when no deps are available) and
  // declare that they should be available.
  //
  // Here we eval the sources, if all the deps are available
  // either already eval'd or goog.require'd.  This will
  // be the case when all the dependencies have already
  // been loaded, and the dependent module is loaded.
  //
  // But this alone isn't sufficient because it is also
  // necessary to handle the case where there is no root
  // that is not deferred.  For that there we register for an event
  // and trigger goog.loadQueuedModules_ handle any remaining deferred
  // evaluations.

  /**
   * Handle any remaining deferred goog.module evals.
   * @private
   */
  goog.loadQueuedModules_ = function() {
    var count = goog.queuedModules_.length;
    if (count > 0) {
      var queue = goog.queuedModules_;
      goog.queuedModules_ = [];
      for (var i = 0; i < count; i++) {
        var path = queue[i];
        goog.maybeProcessDeferredPath_(path);
      }
    }
    goog.oldIeWaiting_ = false;
  };


  /**
   * Eval the named module if its dependencies are
   * available.
   * @param {string} name The module to load.
   * @private
   */
  goog.maybeProcessDeferredDep_ = function(name) {
    if (goog.isDeferredModule_(name) && goog.allDepsAreAvailable_(name)) {
      var path = goog.getPathFromDeps_(name);
      goog.maybeProcessDeferredPath_(goog.basePath + path);
    }
  };

  /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose evaluation has been deferred.
   * @private
   */
  goog.isDeferredModule_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    var loadFlags = path && goog.dependencies_.loadFlags[path] || {};
    var languageLevel = loadFlags['lang'] || 'es3';
    if (path && (loadFlags['module'] == 'goog' ||
                 goog.needsTranspile_(languageLevel))) {
      var abspath = goog.basePath + path;
      return (abspath) in goog.dependencies_.deferred;
    }
    return false;
  };

  /**
   * @param {string} name The module to check.
   * @return {boolean} Whether the name represents a
   *     module whose declared dependencies have all been loaded
   *     (eval'd or a deferred module load)
   * @private
   */
  goog.allDepsAreAvailable_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    if (path && (path in goog.dependencies_.requires)) {
      for (var requireName in goog.dependencies_.requires[path]) {
        if (!goog.isProvided_(requireName) &&
            !goog.isDeferredModule_(requireName)) {
          return false;
        }
      }
    }
    return true;
  };


  /**
   * @param {string} abspath
   * @private
   */
  goog.maybeProcessDeferredPath_ = function(abspath) {
    if (abspath in goog.dependencies_.deferred) {
      var src = goog.dependencies_.deferred[abspath];
      delete goog.dependencies_.deferred[abspath];
      goog.globalEval(src);
    }
  };


  /**
   * Load a goog.module from the provided URL.  This is not a general purpose
   * code loader and does not support late loading code, that is it should only
   * be used during page load. This method exists to support unit tests and
   * "debug" loaders that would otherwise have inserted script tags. Under the
   * hood this needs to use a synchronous XHR and is not recommeneded for
   * production code.
   *
   * The module's goog.requires must have already been satisified; an exception
   * will be thrown if this is not the case. This assumption is that no
   * "deps.js" file exists, so there is no way to discover and locate the
   * module-to-be-loaded's dependencies and no attempt is made to do so.
   *
   * There should only be one attempt to load a module.  If
   * "goog.loadModuleFromUrl" is called for an already loaded module, an
   * exception will be throw.
   *
   * @param {string} url The URL from which to attempt to load the goog.module.
   */
  goog.loadModuleFromUrl = function(url) {
    // Because this executes synchronously, we don't need to do any additional
    // bookkeeping. When "goog.loadModule" the namespace will be marked as
    // having been provided which is sufficient.
    goog.retrieveAndExec_(url, true, false);
  };


  /**
   * Writes a new script pointing to {@code src} directly into the DOM.
   *
   * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for
   * the fallback mechanism.
   *
   * @param {string} src The script URL.
   * @private
   */
  goog.writeScriptSrcNode_ = function(src) {
    goog.global.document.write(
        '<script type="text/javascript" src="' + src + '"></' +
        'script>');
  };


  /**
   * Appends a new script node to the DOM using a CSP-compliant mechanism. This
   * method exists as a fallback for document.write (which is not allowed in a
   * strict CSP context, e.g., Chrome apps).
   *
   * NOTE: This method is not analogous to using document.write to insert a
   * <script> tag; specifically, the user agent will execute a script added by
   * document.write immediately after the current script block finishes
   * executing, whereas the DOM-appended script node will not be executed until
   * the entire document is parsed and executed. That is to say, this script is
   * added to the end of the script execution queue.
   *
   * The page must not attempt to call goog.required entities until after the
   * document has loaded, e.g., in or after the window.onload callback.
   *
   * @param {string} src The script URL.
   * @private
   */
  goog.appendScriptSrcNode_ = function(src) {
    /** @type {Document} */
    var doc = goog.global.document;
    var scriptEl =
        /** @type {HTMLScriptElement} */ (doc.createElement('script'));
    scriptEl.type = 'text/javascript';
    scriptEl.src = src;
    scriptEl.defer = false;
    scriptEl.async = false;
    doc.head.appendChild(scriptEl);
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script url.
   * @param {string=} opt_sourceText The optionally source text to evaluate
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src, opt_sourceText) {
    if (goog.inHtmlDocument_()) {
      /** @type {!HTMLDocument} */
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page. This does not apply to the CSP-compliant method
      // of writing script tags.
      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
          doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw new Error('Cannot write "' + src + '" after document load');
        }
      }

      if (opt_sourceText === undefined) {
        if (!goog.IS_OLD_IE_) {
          if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
            goog.appendScriptSrcNode_(src);
          } else {
            goog.writeScriptSrcNode_(src);
          }
        } else {
          goog.oldIeWaiting_ = true;
          var state = ' onreadystatechange=\'goog.onScriptLoad_(this, ' +
              ++goog.lastNonModuleScriptIndex_ + ')\' ';
          doc.write(
              '<script type="text/javascript" src="' + src + '"' + state +
              '></' +
              'script>');
        }
      } else {
        doc.write(
            '<script type="text/javascript">' +
            goog.protectScriptTag_(opt_sourceText) + '</' +
            'script>');
      }
      return true;
    } else {
      return false;
    }
  };

  /**
   * Rewrites closing script tags in input to avoid ending an enclosing script
   * tag.
   *
   * @param {string} str
   * @return {string}
   * @private
   */
  goog.protectScriptTag_ = function(str) {
    return str.replace(/<\/(SCRIPT)/ig, '\\x3c/$1');
  };

  /**
   * Determines whether the given language needs to be transpiled.
   * @param {string} lang
   * @return {boolean}
   * @private
   */
  goog.needsTranspile_ = function(lang) {
    if (goog.TRANSPILE == 'always') {
      return true;
    } else if (goog.TRANSPILE == 'never') {
      return false;
    } else if (!goog.requiresTranspilation_) {
      goog.requiresTranspilation_ = goog.createRequiresTranspilation_();
    }
    if (lang in goog.requiresTranspilation_) {
      return goog.requiresTranspilation_[lang];
    } else {
      throw new Error('Unknown language mode: ' + lang);
    }
  };

  /** @private {?Object<string, boolean>} */
  goog.requiresTranspilation_ = null;


  /** @private {number} */
  goog.lastNonModuleScriptIndex_ = 0;


  /**
   * A readystatechange handler for legacy IE
   * @param {?} script
   * @param {number} scriptIndex
   * @return {boolean}
   * @private
   */
  goog.onScriptLoad_ = function(script, scriptIndex) {
    // for now load the modules when we reach the last script,
    // later allow more inter-mingling.
    if (script.readyState == 'complete' &&
        goog.lastNonModuleScriptIndex_ == scriptIndex) {
      goog.loadQueuedModules_();
    }
    return true;
  };

  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @param {string} pathToLoad The path from which to start discovering
   *     dependencies.
   * @private
   */
  goog.writeScripts_ = function(pathToLoad) {
    /** @type {!Array<string>} The scripts we need to write this time. */
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    /** @param {string} path */
    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // We have already visited this one. We can get here if we have cyclic
      // dependencies.
      if (path in deps.visited) {
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw new Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    visitNode(pathToLoad);

    // record that we are going to load all these scripts.
    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      goog.dependencies_.written[path] = true;
    }

    // If a module is loaded synchronously then we need to
    // clear the current inModuleLoader value, and restore it when we are
    // done loading the current "requires".
    var moduleState = goog.moduleLoaderState_;
    goog.moduleLoaderState_ = null;

    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      if (path) {
        var loadFlags = deps.loadFlags[path] || {};
        var languageLevel = loadFlags['lang'] || 'es3';
        var needsTranspile = goog.needsTranspile_(languageLevel);
        if (loadFlags['module'] == 'goog' || needsTranspile) {
          goog.importProcessedScript_(
              goog.basePath + path, loadFlags['module'] == 'goog',
              needsTranspile);
        } else {
          goog.importScript_(goog.basePath + path);
        }
      } else {
        goog.moduleLoaderState_ = moduleState;
        throw new Error('Undefined script input');
      }
    }

    // restore the current "module loading state"
    goog.moduleLoaderState_ = moduleState;
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}


/**
 * @package {?boolean}
 * Visible for testing.
 */
goog.hasBadLetScoping = null;


/**
 * @return {boolean}
 * @package Visible for testing.
 */
goog.useSafari10Workaround = function() {
  if (goog.hasBadLetScoping == null) {
    var hasBadLetScoping;
    try {
      hasBadLetScoping = !eval(
          '"use strict";' +
          'let x = 1; function f() { return typeof x; };' +
          'f() == "number";');
    } catch (e) {
      // Assume that ES6 syntax isn't supported.
      hasBadLetScoping = false;
    }
    goog.hasBadLetScoping = hasBadLetScoping;
  }
  return goog.hasBadLetScoping;
};


/**
 * @param {string} moduleDef
 * @return {string}
 * @package Visible for testing.
 */
goog.workaroundSafari10EvalBug = function(moduleDef) {
  return '(function(){' + moduleDef +
      '\n' +  // Terminate any trailing single line comment.
      ';' +   // Terminate any trailing expression.
      '})();\n';
};


/**
 * @param {function(?):?|string} moduleDef The module definition.
 */
goog.loadModule = function(moduleDef) {
  // NOTE: we allow function definitions to be either in the from
  // of a string to eval (which keeps the original source intact) or
  // in a eval forbidden environment (CSP) we allow a function definition
  // which in its body must call {@code goog.module}, and return the exports
  // of the module.
  var previousState = goog.moduleLoaderState_;
  try {
    goog.moduleLoaderState_ = {
      moduleName: undefined,
      declareLegacyNamespace: false
    };
    var exports;
    if (goog.isFunction(moduleDef)) {
      exports = moduleDef.call(undefined, {});
    } else if (goog.isString(moduleDef)) {
      if (goog.useSafari10Workaround()) {
        moduleDef = goog.workaroundSafari10EvalBug(moduleDef);
      }

      exports = goog.loadModuleFromSource_.call(undefined, moduleDef);
    } else {
      throw new Error('Invalid module definition');
    }

    var moduleName = goog.moduleLoaderState_.moduleName;
    if (!goog.isString(moduleName) || !moduleName) {
      throw new Error('Invalid module name \"' + moduleName + '\"');
    }

    // Don't seal legacy namespaces as they may be uses as a parent of
    // another namespace
    if (goog.moduleLoaderState_.declareLegacyNamespace) {
      goog.constructNamespace_(moduleName, exports);
    } else if (
        goog.SEAL_MODULE_EXPORTS && Object.seal && typeof exports == 'object' &&
        exports != null) {
      Object.seal(exports);
    }

    goog.loadedModules_[moduleName] = exports;
  } finally {
    goog.moduleLoaderState_ = previousState;
  }
};


/**
 * @private @const
 */
goog.loadModuleFromSource_ = /** @type {function(string):?} */ (function() {
  // NOTE: we avoid declaring parameters or local variables here to avoid
  // masking globals or leaking values into the module definition.
  'use strict';
  var exports = {};
  eval(arguments[0]);
  return exports;
});


/**
 * Normalize a file path by removing redundant ".." and extraneous "." file
 * path components.
 * @param {string} path
 * @return {string}
 * @private
 */
goog.normalizePath_ = function(path) {
  var components = path.split('/');
  var i = 0;
  while (i < components.length) {
    if (components[i] == '.') {
      components.splice(i, 1);
    } else if (
        i && components[i] == '..' && components[i - 1] &&
        components[i - 1] != '..') {
      components.splice(--i, 2);
    } else {
      i++;
    }
  }
  return components.join('/');
};


/**
 * Provides a hook for loading a file when using Closure's goog.require() API
 * with goog.modules.  In particular this hook is provided to support Node.js.
 *
 * @type {(function(string):string)|undefined}
 */
goog.global.CLOSURE_LOAD_FILE_SYNC;


/**
 * Loads file by synchronous XHR. Should not be used in production environments.
 * @param {string} src Source URL.
 * @return {?string} File contents, or null if load failed.
 * @private
 */
goog.loadFileSync_ = function(src) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
  } else {
    try {
      /** @type {XMLHttpRequest} */
      var xhr = new goog.global['XMLHttpRequest']();
      xhr.open('get', src, false);
      xhr.send();
      // NOTE: Successful http: requests have a status of 200, but successful
      // file: requests may have a status of zero.  Any other status, or a
      // thrown exception (particularly in case of file: requests) indicates
      // some sort of error, which we treat as a missing or unavailable file.
      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;
    } catch (err) {
      // No need to rethrow or log, since errors should show up on their own.
      return null;
    }
  }
};


/**
 * Retrieve and execute a script that needs some sort of wrapping.
 * @param {string} src Script source URL.
 * @param {boolean} isModule Whether to load as a module.
 * @param {boolean} needsTranspile Whether to transpile down to ES3.
 * @private
 */
goog.retrieveAndExec_ = function(src, isModule, needsTranspile) {
  if (!COMPILED) {
    // The full but non-canonicalized URL for later use.
    var originalPath = src;
    // Canonicalize the path, removing any /./ or /../ since Chrome's debugging
    // console doesn't auto-canonicalize XHR loads as it does <script> srcs.
    src = goog.normalizePath_(src);

    var importScript =
        goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;

    var scriptText = goog.loadFileSync_(src);
    if (scriptText == null) {
      throw new Error('Load of "' + src + '" failed');
    }

    if (needsTranspile) {
      scriptText = goog.transpile_.call(goog.global, scriptText, src);
    }

    if (isModule) {
      scriptText = goog.wrapModule_(src, scriptText);
    } else {
      scriptText += '\n//# sourceURL=' + src;
    }
    var isOldIE = goog.IS_OLD_IE_;
    if (isOldIE && goog.oldIeWaiting_) {
      goog.dependencies_.deferred[originalPath] = scriptText;
      goog.queuedModules_.push(originalPath);
    } else {
      importScript(src, scriptText);
    }
  }
};


/**
 * Lazily retrieves the transpiler and applies it to the source.
 * @param {string} code JS code.
 * @param {string} path Path to the code.
 * @return {string} The transpiled code.
 * @private
 */
goog.transpile_ = function(code, path) {
  var jscomp = goog.global['$jscomp'];
  if (!jscomp) {
    goog.global['$jscomp'] = jscomp = {};
  }
  var transpile = jscomp.transpile;
  if (!transpile) {
    var transpilerPath = goog.basePath + goog.TRANSPILER;
    var transpilerCode = goog.loadFileSync_(transpilerPath);
    if (transpilerCode) {
      // This must be executed synchronously, since by the time we know we
      // need it, we're about to load and write the ES6 code synchronously,
      // so a normal script-tag load will be too slow.
      eval(transpilerCode + '\n//# sourceURL=' + transpilerPath);
      // Even though the transpiler is optional, if $gwtExport is found, it's
      // a sign the transpiler was loaded and the $jscomp.transpile *should*
      // be there.
      if (goog.global['$gwtExport'] && goog.global['$gwtExport']['$jscomp'] &&
          !goog.global['$gwtExport']['$jscomp']['transpile']) {
        throw new Error(
            'The transpiler did not properly export the "transpile" ' +
            'method. $gwtExport: ' + JSON.stringify(goog.global['$gwtExport']));
      }
      // transpile.js only exports a single $jscomp function, transpile. We
      // grab just that and add it to the existing definition of $jscomp which
      // contains the polyfills.
      goog.global['$jscomp'].transpile =
          goog.global['$gwtExport']['$jscomp']['transpile'];
      jscomp = goog.global['$jscomp'];
      transpile = jscomp.transpile;
    }
  }
  if (!transpile) {
    // The transpiler is an optional component.  If it's not available then
    // replace it with a pass-through function that simply logs.
    var suffix = ' requires transpilation but no transpiler was found.';
    transpile = jscomp.transpile = function(code, path) {
      // TODO(user): figure out some way to get this error to show up
      // in test results, noting that the failure may occur in many
      // different ways, including in loadModule() before the test
      // runner even comes up.
      goog.logToConsole_(path + suffix);
      return code;
    };
  }
  // Note: any transpilation errors/warnings will be logged to the console.
  return transpile(code, path);
};


//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {?} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals typeof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {!Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case.
           typeof value.length == 'number' &&
               typeof value.splice != 'undefined' &&
               typeof value.propertyIsEnumerable != 'undefined' &&
               !value.propertyIsEnumerable('splice')

               )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
           typeof value.call != 'undefined' &&
               typeof value.propertyIsEnumerable != 'undefined' &&
               !value.propertyIsEnumerable('call'))) {
        return 'function';
      }

    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox typeof
    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
    // would like to return object for those and we can detect an invalid
    // function by making sure that the function object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property. As a special case, a function value is not array like, because its
 * length property is fixed to correspond to the number of expected arguments.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  // We do not use goog.isObject here in order to exclude function values.
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is already assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {!Object} obj The object to check.
 * @return {boolean} Whether there is an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if (obj !== null && 'removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }

  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @private
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function goog.bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like goog.bind(), except that a 'this object' is not required. Useful when
 * the target function is already bound.
 *
 * Usage:
 * var g = goog.partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function goog.partial()
 *     was invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {
             // Unary plus operator converts its operand to a number which in
             // the case of
             // a date is done by calling getTime().
             return +new Date();
           });


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _evalTest_ = 1;');
      if (typeof goog.global['_evalTest_'] != 'undefined') {
        try {
          delete goog.global['_evalTest_'];
        } catch (ignore) {
          // Microsoft edge fails the deletion above in strict mode.
        }
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      /** @type {Document} */
      var doc = goog.global.document;
      var scriptElt =
          /** @type {!HTMLScriptElement} */ (doc.createElement('SCRIPT'));
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(user): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw new Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @private {!Object<string, string>|undefined}
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;



/**
 * A hook for modifying the default behavior goog.getCssName. The function
 * if present, will recieve the standard output of the goog.getCssName as
 * its input.
 *
 * @type {(function(string):string)|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAP_FN;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x = 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  // String() is used for compatibility with compiled soy where the passed
  // className can be non-string objects.
  if (String(className).charAt(0) == '.') {
    throw new Error(
        'className passed in goog.getCssName must not start with ".".' +
        ' You passed: ' + className);
  }

  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename =
        goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  var result =
      opt_modifier ? className + '-' + rename(opt_modifier) : rename(className);

  // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further
  // processing of the class name.
  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {
    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);
  }

  return result;
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --process_closure_primitives flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {!Object<string, string>|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * This function produces a string which should be treated as plain text. Use
 * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to
 * produce SafeHtml.
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object<string, string>=} opt_values Maps place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
      return (opt_values != null && key in opt_values) ? opt_values[key] :
                                                         match;
    });
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { };
 *
 * function ChildClass(a, b, c) {
 *   ChildClass.base(this, 'constructor', a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * @param {!Function} childCtor Child class.
 * @param {!Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {}
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) {
      args[i - 2] = arguments[i];
    }
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * constructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 * @suppress {es5Strict} This method can not be used in strict mode, but
 *     all Closure Library consumers must depend on this file.
 * @deprecated goog.base is not strict mode compatible.  Prefer the static
 *     "base" method added to the constructor by goog.inherits
 *     or ES6 classes and the "super" keyword.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;

  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {
    throw new Error(
        'arguments.caller not defined.  goog.base() cannot be used ' +
        'with strict mode code. See ' +
        'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
  }

  if (caller.superClass_) {
    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var ctorArgs = new Array(arguments.length - 1);
    for (var i = 1; i < arguments.length; i++) {
      ctorArgs[i - 1] = arguments[i];
    }
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(me, ctorArgs);
  }

  // Copying using loop to avoid deop due to passing arguments object to
  // function. This is faster in many JS engines as of late 2014.
  var args = new Array(arguments.length - 2);
  for (var i = 2; i < arguments.length; i++) {
    args[i - 2] = arguments[i];
  }
  var foundCaller = false;
  for (var ctor = me.constructor; ctor;
       ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain, then one of two
  // things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw new Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 *
 *
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  if (goog.isInModuleLoader_()) {
    throw new Error('goog.scope is not supported within a goog.module.');
  }
  fn.call(goog.global);
};


/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
  goog.global['COMPILED'] = COMPILED;
}


//==============================================================================
// goog.defineClass implementation
//==============================================================================


/**
 * Creates a restricted form of a Closure "class":
 *   - from the compiler's perspective, the instance returned from the
 *     constructor is sealed (no new properties may be added).  This enables
 *     better checks.
 *   - the compiler will rewrite this definition to a form that is optimal
 *     for type checking and optimization (initially this will be a more
 *     traditional form).
 *
 * @param {Function} superClass The superclass, Object or null.
 * @param {goog.defineClass.ClassDescriptor} def
 *     An object literal describing
 *     the class.  It may have the following properties:
 *     "constructor": the constructor function
 *     "statics": an object literal containing methods to add to the constructor
 *        as "static" methods or a function that will receive the constructor
 *        function as its only parameter to which static properties can
 *        be added.
 *     all other properties are added to the prototype.
 * @return {!Function} The class constructor.
 */
goog.defineClass = function(superClass, def) {
  // TODO(johnlenz): consider making the superClass an optional parameter.
  var constructor = def.constructor;
  var statics = def.statics;
  // Wrap the constructor prior to setting up the prototype and static methods.
  if (!constructor || constructor == Object.prototype.constructor) {
    constructor = function() {
      throw new Error(
          'cannot instantiate an interface (no constructor defined).');
    };
  }

  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
  if (superClass) {
    goog.inherits(cls, superClass);
  }

  // Remove all the properties that should not be copied to the prototype.
  delete def.constructor;
  delete def.statics;

  goog.defineClass.applyProperties_(cls.prototype, def);
  if (statics != null) {
    if (statics instanceof Function) {
      statics(cls);
    } else {
      goog.defineClass.applyProperties_(cls, statics);
    }
  }

  return cls;
};


/**
 * @typedef {{
 *   constructor: (!Function|undefined),
 *   statics: (Object|undefined|function(Function):void)
 * }}
 */
goog.defineClass.ClassDescriptor;


/**
 * @define {boolean} Whether the instances returned by goog.defineClass should
 *     be sealed when possible.
 *
 * When sealing is disabled the constructor function will not be wrapped by
 * goog.defineClass, making it incompatible with ES6 class methods.
 */
goog.define('goog.defineClass.SEAL_CLASS_INSTANCES', goog.DEBUG);


/**
 * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is
 * defined, this function will wrap the constructor in a function that seals the
 * results of the provided constructor function.
 *
 * @param {!Function} ctr The constructor whose results maybe be sealed.
 * @param {Function} superClass The superclass constructor.
 * @return {!Function} The replacement constructor.
 * @private
 */
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {
    // Do now wrap the constructor when sealing is disabled. Angular code
    // depends on this for injection to work properly.
    return ctr;
  }

  // Compute whether the constructor is sealable at definition time, rather
  // than when the instance is being constructed.
  var superclassSealable = !goog.defineClass.isUnsealable_(superClass);

  /**
   * @this {Object}
   * @return {?}
   */
  var wrappedCtr = function() {
    // Don't seal an instance of a subclass when it calls the constructor of
    // its super class as there is most likely still setup to do.
    var instance = ctr.apply(this, arguments) || this;
    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];

    if (this.constructor === wrappedCtr && superclassSealable &&
        Object.seal instanceof Function) {
      Object.seal(instance);
    }
    return instance;
  };

  return wrappedCtr;
};


/**
 * @param {Function} ctr The constructor to test.
 * @return {boolean} Whether the constructor has been tagged as unsealable
 *     using goog.tagUnsealableClass.
 * @private
 */
goog.defineClass.isUnsealable_ = function(ctr) {
  return ctr && ctr.prototype &&
      ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
};


// TODO(johnlenz): share these values with the goog.object
/**
 * The names of the fields that are defined on Object.prototype.
 * @type {!Array<string>}
 * @private
 * @const
 */
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [
  'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
  'toLocaleString', 'toString', 'valueOf'
];


// TODO(johnlenz): share this function with the goog.object
/**
 * @param {!Object} target The object to add properties to.
 * @param {!Object} source The object to copy properties from.
 * @private
 */
goog.defineClass.applyProperties_ = function(target, source) {
  // TODO(johnlenz): update this to support ES5 getters/setters

  var key;
  for (key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }

  // For IE the for-in-loop does not contain any properties that are not
  // enumerable on the prototype object (for example isPrototypeOf from
  // Object.prototype) and it will also not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
};


/**
 * Sealing classes breaks the older idiom of assigning properties on the
 * prototype rather than in the constructor. As such, goog.defineClass
 * must not seal subclasses of these old-style classes until they are fixed.
 * Until then, this marks a class as "broken", instructing defineClass
 * not to seal subclasses.
 * @param {!Function} ctr The legacy constructor to tag as unsealable.
 */
goog.tagUnsealableClass = function(ctr) {
  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {
    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;
  }
};


/**
 * Name for unsealable tag property.
 * @const @private {string}
 */
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = 'goog_defineClass_legacy_unsealable';


/**
 * Returns a newly created map from language mode string to a boolean
 * indicating whether transpilation should be done for that mode.
 *
 * Guaranteed invariant:
 * For any two modes, l1 and l2 where l2 is a newer mode than l1,
 * `map[l1] == true` implies that `map[l2] == true`.
 * @private
 * @return {!Object<string, boolean>}
 */
goog.createRequiresTranspilation_ = function() {
  var /** !Object<string, boolean> */ requiresTranspilation = {'es3': false};
  var transpilationRequiredForAllLaterModes = false;

  /**
   * Adds an entry to requiresTranspliation for the given language mode.
   *
   * IMPORTANT: Calls must be made in order from oldest to newest language
   * mode.
   * @param {string} modeName
   * @param {function(): boolean} isSupported Returns true if the JS engine
   *     supports the given mode.
   */
  function addNewerLanguageTranspilationCheck(modeName, isSupported) {
    if (transpilationRequiredForAllLaterModes) {
      requiresTranspilation[modeName] = true;
    } else if (isSupported()) {
      requiresTranspilation[modeName] = false;
    } else {
      requiresTranspilation[modeName] = true;
      transpilationRequiredForAllLaterModes = true;
    }
  }

  /**
   * Does the given code evaluate without syntax errors and return a truthy
   * result?
   */
  function /** boolean */ evalCheck(/** string */ code) {
    try {
      return !!eval(code);
    } catch (ignored) {
      return false;
    }
  }

  var userAgent = goog.global.navigator && goog.global.navigator.userAgent ?
      goog.global.navigator.userAgent :
      '';

  // Identify ES3-only browsers by their incorrect treatment of commas.
  addNewerLanguageTranspilationCheck('es5', function() {
    return evalCheck('[1,].length==1');
  });
  addNewerLanguageTranspilationCheck('es6', function() {
    // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:
    // https://github.com/Microsoft/ChakraCore/issues/1496.
    var re = /Edge\/(\d+)(\.\d)*/i;
    var edgeUserAgent = userAgent.match(re);
    if (edgeUserAgent && Number(edgeUserAgent[1]) < 15) {
      return false;
    }
    // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]
    //   (a) default params (specifically shadowing locals),
    //   (b) destructuring, (c) block-scoped functions,
    //   (d) for-of (const), (e) new.target/Reflect.construct
    var es6fullTest =
        'class X{constructor(){if(new.target!=String)throw 1;this.x=42}}' +
        'let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof ' +
        'String))throw 1;for(const a of[2,3]){if(a==2)continue;function ' +
        'f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()' +
        '==3}';

    return evalCheck('(()=>{"use strict";' + es6fullTest + '})()');
  });
  // TODO(joeltine): Remove es6-impl references for b/31340605.
  // Consider es6-impl (widely-implemented es6 features) to be supported
  // whenever es6 is supported. Technically es6-impl is a lower level of
  // support than es6, but we don't have tests specifically for it.
  addNewerLanguageTranspilationCheck('es6-impl', function() {
    return true;
  });
  // ** and **= are the only new features in 'es7'
  addNewerLanguageTranspilationCheck('es7', function() {
    return evalCheck('2 ** 2 == 4');
  });
  // async functions are the only new features in 'es8'
  addNewerLanguageTranspilationCheck('es8', function() {
    return evalCheck('async () => 1, true');
  });
  return requiresTranspilation;
};
/**
 * This option is included at the beginning of the concatenation
 * of the source files in dependency order. It nullifies the
 * calls to goog.provide and goog.require.
 * @define {boolean}
 */
COMPILED = true;


goog.provide('alk');

var alk = {};

/**
 * @define {boolean} Assume touch.  Default is `false`.
 */
alk.DEBUG_WEBGL = false;


/**
 * @define {string} ALK Maps Logo
 */
alk.ALK_LOGO_URL = 'data:image/png;base64,'+
  'iVBORw0KGgoAAAANSUhEUgAAAEAAAAAPCAYAAABUZ8lnAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZV'+
  'JlYWR5ccllPAAAAopJREFUeNpiLKibEM7AwLCCgbbgQ39jvmDN8qv1QHYDw+ABEUx08DwDK9t/gbLWCSDP'+
  'NzIMLrCCiR62/P7FyDDIYh4OiA0ARhxskkBLpPagCwCWweIQUOAsPfyI4fqTz2A+BxszQ02wBsPUHXcZnr'+
  '//ARazUhcG08duvgXTkoIcDNkeynAztp17AZYD6QWpddIRBYuvO/GU4dz9D4M7AGAehAWAkaIAJCBYmeHy'+
  'XkYSKAEAk5u79wGDIDcrQ5CFNFwtyPOgAJUU5ASL4woAeBYAltKMMAxN5huIdHcgVM8HSgNAUYwbjJE9Cw'+
  'OaMrxY2SBw/9VXuAdBsQ/CIAAKzH2XXzEAax/CWaCwfuJ/JHHBCU0FgcAq8j8BNycCPb8BTS/ZAJTUjZQE'+
  'wLH54etvBgEgDQPRtnLgJA7yHIiN7ClY1oCY8R2s10pNCF7mIGctYgvB+QTc+hDq+QVAz6+nVhY4Dkzahs'+
  'CkD0qyoJiDAViM/vj1l+HDl18oYrDUAsKgrADyKCggW9beAJcf+668BgcYsnpiyoAAYOzjc6sBKMlTK+Zh'+
  '4D0w5s5DkzIoScPytDc0OyDncZDYuXsQtehJ3AgaiCBxUKCBygNOViYwG1sALADFJqktO2ggUB1sBSZzQa'+
  'SkDwKgVAEr4WFJ3gspALABUMkPywKgQAUFLq4UAPJ8BxCX46n7UQCwfABRFwikEpIAKLmCHAmKpefQmAIl'+
  '6ecffsBpGAClDlDBB1IP0ocOQPKgJP8eqO/D1184PQ/3JNAjoIzFikXuPx62ISgQkMQJNYcZuqoLGIHJ8j'+
  '/DIAKwQnAaGdXYfmg2ILZlOKibwgXQqo8RhIn0lAAJgfABGPuN0N7gYAIRAAEGAK2YF6+T50GTAAAAAElF'+
  'TkSuQmCC';


/**
 * @description
 * This function changes the static URL enums.
 * @param {Object.<string,string>} obj
 * @param {string} url
 * @param {Object.<string,string>} base
 * @param {string} suffix
 * @api
 */
alk.setURL = function(obj, url, base, suffix) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      obj[key] = url + base[key] + suffix;
    }
  }
};

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
alk.getUid = function(obj) {
  return obj.alk_uid ||
    (obj.alk_uid = ++alk.uidCounter_);
};


/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
alk.uidCounter_ = 0;
goog.provide('alk.ext');

goog.require('alk');
alk.ext = {};
goog.provide('alk.ext.rbush');
goog.require('alk.ext');
/**
 * @constructor
 * @param {number} opt_maxEntries
 * @param {string=} format
 */
alk.ext.rbush;

(function () {
  var module = {};
  var exports = {};

  // From ol.rbush;
(function () {
  /**
   * @fileoverview
   * @suppress {suspiciousCode, accessControls, ambiguousFunctionDecl, checkDebuggerStatement, checkRegExp, checkTypes, checkVars, const, constantProperty, deprecated, duplicate, es5Strict, fileoverviewTags, missingProperties, nonStandardJsDocs, strictModuleDepCheck, suspiciousCode, undefinedNames, undefinedVars, unknownDefines, unusedLocalVariables, uselessCode, visibility}
   */
  (function (f) {
    if (typeof exports === "object" &&
      typeof module !== "undefined") {
      module.exports = f()
    }
    else if (typeof define === "function" && define.amd) {
      define([], f)
    } else {
      var g;
      if (typeof window !== "undefined") {
        g = window
      }
      else if (typeof global !== "undefined") {
        g = global
      }
      else if (typeof self !== "undefined") {
        g = self
      } else {
        g = this
      }
      g.rbush = f()
    }
  })(function () {
    var define, module, exports;
    return (function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == "function" &&
              require;
            if (!u && a) return a(o, !0);
            if (i)
              return i(o, !0);
            var f = new Error("Cannot find module '" + o + "'");
            throw f.code = "MODULE_NOT_FOUND", f
          }
          var l = n[o] = {exports: {}};
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e)
          }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
      }

      var i = typeof require == "function" &&
        require;
      for (var o = 0; o < r.length; o++) s(r[o]);
      return s
    })(
      {
        1: [function (_dereq_, module, exports) {

          'use strict';

          module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

          function partialSort(arr, k, left, right, compare) {
            left = left || 0;
            right = right || (arr.length - 1);
            compare = compare || defaultCompare;

            while (right > left) {
              if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                partialSort(arr, k, newLeft, newRight, compare);
              }

              var t = arr[k];
              var i = left;
              var j = right;

              swap(arr, left, k);
              if (compare(arr[right], t) > 0) swap(arr, left, right);

              while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) i++;
                while (compare(arr[j], t) > 0) j--;
              }

              if (compare(arr[left], t) === 0) swap(arr, left, j);
              else {
                j++;
                swap(arr, j, right);
              }

              if (j <= k) left = j + 1;
              if (k <= j) right = j - 1;
            }
          }

          function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
          }

          function defaultCompare(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
          }

        }, {}], 2: [function (_dereq_, module, exports) {
        'use strict';

        module.exports = rbush;

        var quickselect = _dereq_('quickselect');

        /**
         * @constructor
         * @param {number} maxEntries
         * @param {string=} format
         */
        function rbush(maxEntries, format) {
          if (!(this instanceof rbush)) return new rbush(maxEntries, format);

          // max entries in a node is 9 by default; min node fill is 40% for best performance
          this._maxEntries = Math.max(4, maxEntries || 9);
          this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

          if (format) {
            this._initFormat(format);
          }

          this.clear();
        }

        rbush.prototype = {

          all: function () {
            return this._all(this.data, []);
          },

          search: function (bbox) {

            var node = this.data,
              result = [],
              toBBox = this.toBBox;

            if (!intersects(bbox, node)) return result;

            var nodesToSearch = [],
              i, len, child, childBBox;

            while (node) {
              for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                  if (node.leaf) result.push(child);
                  else if (contains(bbox, childBBox)) this._all(child, result);
                  else nodesToSearch.push(child);
                }
              }
              node = nodesToSearch.pop();
            }

            return result;
          },

          collides: function (bbox) {

            var node = this.data,
              toBBox = this.toBBox;

            if (!intersects(bbox, node)) return false;

            var nodesToSearch = [],
              i, len, child, childBBox;

            while (node) {
              for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                  if (node.leaf || contains(bbox, childBBox)) return true;
                  nodesToSearch.push(child);
                }
              }
              node = nodesToSearch.pop();
            }

            return false;
          },

          load: function (data) {
            if (!(data && data.length)) return this;

            if (data.length < this._minEntries) {
              for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
              }
              return this;
            }

            // recursively build the tree with the given data from stratch using OMT algorithm
            var node = this._build(data.slice(), 0, data.length - 1, 0);

            if (!this.data.children.length) {
              // save as is if tree is empty
              this.data = node;

            } else if (this.data.height === node.height) {
              // split root if trees have the same height
              this._splitRoot(this.data, node);

            } else {
              if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
              }

              // insert the small tree into the large tree at appropriate level
              this._insert(node, this.data.height - node.height - 1, true);
            }

            return this;
          },

          insert: function (item) {
            if (item) this._insert(item, this.data.height - 1);
            return this;
          },

          clear: function () {
            this.data = createNode([]);
            return this;
          },

          remove: function (item, equalsFn) {
            if (!item) return this;

            var node = this.data,
              bbox = this.toBBox(item),
              path = [],
              indexes = [],
              i, parent, index, goingUp;

            // depth-first iterative tree traversal
            while (node || path.length) {

              if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
              }

              if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                  // item found, remove the item and condense tree upwards
                  node.children.splice(index, 1);
                  path.push(node);
                  this._condense(path);
                  return this;
                }
              }

              if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

              } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

              } else node = null; // nothing found
            }

            return this;
          },

          toBBox: function (item) {
            return item;
          },

          compareMinX: compareNodeMinX,
          compareMinY: compareNodeMinY,

          toJSON: function () {
            return this.data;
          },

          fromJSON: function (data) {
            this.data = data;
            return this;
          },

          _all: function (node, result) {
            var nodesToSearch = [];
            while (node) {
              if (node.leaf) result.push.apply(result, node.children);
              else nodesToSearch.push.apply(nodesToSearch, node.children);

              node = nodesToSearch.pop();
            }
            return result;
          },

          _build: function (items, left, right, height) {

            var N = right - left + 1,
              M = this._maxEntries,
              node;

            if (N <= M) {
              // reached leaf level; return leaf
              node = createNode(items.slice(left, right + 1));
              calcBBox(node, this.toBBox);
              return node;
            }

            if (!height) {
              // target height of the bulk-loaded tree
              height = Math.ceil(Math.log(N) / Math.log(M));

              // target number of root entries to maximize storage utilization
              M = Math.ceil(N / Math.pow(M, height - 1));
            }

            node = createNode([]);
            node.leaf = false;
            node.height = height;

            // split the items into M mostly square tiles

            var N2 = Math.ceil(N / M),
              N1 = N2 * Math.ceil(Math.sqrt(M)),
              i, j, right2, right3;

            multiSelect(items, left, right, N1, this.compareMinX);

            for (i = left; i <= right; i += N1) {

              right2 = Math.min(i + N1 - 1, right);

              multiSelect(items, i, right2, N2, this.compareMinY);

              for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
              }
            }

            calcBBox(node, this.toBBox);

            return node;
          },

          _chooseSubtree: function (bbox, node, level, path) {

            var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

            while (true) {
              path.push(node);

              if (node.leaf || path.length - 1 === level) break;

              minArea = minEnlargement = Infinity;

              for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                  minEnlargement = enlargement;
                  minArea = area < minArea ? area : minArea;
                  targetNode = child;

                } else if (enlargement === minEnlargement) {
                  // otherwise choose one with the smallest area
                  if (area < minArea) {
                    minArea = area;
                    targetNode = child;
                  }
                }
              }

              node = targetNode || node.children[0];
            }

            return node;
          },

          _insert: function (item, level, isNode) {

            var toBBox = this.toBBox,
              bbox = isNode ? item : toBBox(item),
              insertPath = [];

            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);

            // put the item into the node
            node.children.push(item);
            extend(node, bbox);

            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
              if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
              } else break;
            }

            // adjust bboxes along the insertion path
            this._adjustParentBBoxes(bbox, insertPath, level);
          },

          // split overflowed node into two
          _split: function (insertPath, level) {

            var node = insertPath[level],
              M = node.children.length,
              m = this._minEntries;

            this._chooseSplitAxis(node, m, M);

            var splitIndex = this._chooseSplitIndex(node, m, M);

            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;

            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);

            if (level) insertPath[level - 1].children.push(newNode);
            else this._splitRoot(node, newNode);
          },

          _splitRoot: function (node, newNode) {
            // split root node
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
          },

          _chooseSplitIndex: function (node, m, M) {

            var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

            minOverlap = minArea = Infinity;

            for (i = m; i <= M - m; i++) {
              bbox1 = distBBox(node, 0, i, this.toBBox);
              bbox2 = distBBox(node, i, M, this.toBBox);

              overlap = intersectionArea(bbox1, bbox2);
              area = bboxArea(bbox1) + bboxArea(bbox2);

              // choose distribution with minimum overlap
              if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

              } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                  minArea = area;
                  index = i;
                }
              }
            }

            return index;
          },

          // sorts node children by the best axis for split
          _chooseSplitAxis: function (node, m, M) {

            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
              xMargin = this._allDistMargin(node, m, M, compareMinX),
              yMargin = this._allDistMargin(node, m, M, compareMinY);

            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin) node.children.sort(compareMinX);
          },

          // total margin of all possible split distributions where each node is at least m full
          _allDistMargin: function (node, m, M, compare) {

            node.children.sort(compare);

            var toBBox = this.toBBox,
              leftBBox = distBBox(node, 0, m, toBBox),
              rightBBox = distBBox(node, M - m, M, toBBox),
              margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
              i, child;

            for (i = m; i < M - m; i++) {
              child = node.children[i];
              extend(leftBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(leftBBox);
            }

            for (i = M - m - 1; i >= m; i--) {
              child = node.children[i];
              extend(rightBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(rightBBox);
            }

            return margin;
          },

          _adjustParentBBoxes: function (bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
              extend(path[i], bbox);
            }
          },

          _condense: function (path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
              if (path[i].children.length === 0) {
                if (i > 0) {
                  siblings = path[i - 1].children;
                  siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

              } else calcBBox(path[i], this.toBBox);
            }
          },

          _initFormat: function (format) {
            // data format (minX, minY, maxX, maxY accessors)

            // uses eval-type function compilation instead of just accepting a toBBox function
            // because the algorithms are very sensitive to sorting functions performance,
            // so they should be dead simple and without inner calls

            var compareArr = ['return a', ' - b', ';'];

            this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
            this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

            this.toBBox = new Function('a',
              'return {minX: a' + format[0] +
              ', minY: a' + format[1] +
              ', maxX: a' + format[2] +
              ', maxY: a' + format[3] + '};');
          }
        };

        function findItem(item, items, equalsFn) {
          if (!equalsFn) return items.indexOf(item);

          for (var i = 0; i < items.length; i++) {
            if (equalsFn(item, items[i])) return i;
          }
          return -1;
        }

// calculate node's bbox from bboxes of its children
        function calcBBox(node, toBBox) {
          distBBox(node, 0, node.children.length, toBBox, node);
        }

// min bounding rectangle of node children from k to p-1
        function distBBox(node, k, p, toBBox, destNode) {
          if (!destNode) destNode = createNode(null);
          destNode.minX = Infinity;
          destNode.minY = Infinity;
          destNode.maxX = -Infinity;
          destNode.maxY = -Infinity;

          for (var i = k, child; i < p; i++) {
            child = node.children[i];
            extend(destNode, node.leaf ? toBBox(child) : child);
          }

          return destNode;
        }

        function extend(a, b) {
          a.minX = Math.min(a.minX, b.minX);
          a.minY = Math.min(a.minY, b.minY);
          a.maxX = Math.max(a.maxX, b.maxX);
          a.maxY = Math.max(a.maxY, b.maxY);
          return a;
        }

        function compareNodeMinX(a, b) {
          return a.minX - b.minX;
        }

        function compareNodeMinY(a, b) {
          return a.minY - b.minY;
        }

        function bboxArea(a) {
          return (a.maxX - a.minX) * (a.maxY - a.minY);
        }

        function bboxMargin(a) {
          return (a.maxX - a.minX) + (a.maxY - a.minY);
        }

        function enlargedArea(a, b) {
          return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
            (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
        }

        function intersectionArea(a, b) {
          var minX = Math.max(a.minX, b.minX),
            minY = Math.max(a.minY, b.minY),
            maxX = Math.min(a.maxX, b.maxX),
            maxY = Math.min(a.maxY, b.maxY);

          return Math.max(0, maxX - minX) *
            Math.max(0, maxY - minY);
        }

        function contains(a, b) {
          return a.minX <= b.minX &&
            a.minY <= b.minY &&
            b.maxX <= a.maxX &&
            b.maxY <= a.maxY;
        }

        function intersects(a, b) {
          return b.minX <= a.maxX &&
            b.minY <= a.maxY &&
            b.maxX >= a.minX &&
            b.maxY >= a.minY;
        }

        function createNode(children) {
          return {
            children: children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
          };
        }

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

        function multiSelect(arr, left, right, n, compare) {
          var stack = [left, right],
            mid;

          while (stack.length) {
            right = stack.pop();
            left = stack.pop();

            if (right - left <= n) continue;

            mid = left + Math.ceil((right - left) / n / 2) * n;
            quickselect(arr, mid, left, right, compare);

            stack.push(left, mid, mid, right);
          }
        }

      }, {"quickselect": 1}]
      }, {}, [2])(2)
  });
})();

  alk.ext.rbush = module.exports;

})();
goog.provide('alk.ATTRIBUTION');

goog.require('alk');

/**
 * The attribution containing a link to the ALK Copyright and License
 * page.
 * @type {string}
 * @api
 */
alk.ATTRIBUTION = '<a href="http://alkmaps.com" target="_blank"><img src="'+
             alk.ALK_LOGO_URL +'">Copyright &copy; ' + new Date().getFullYear() + ' ALK Technologies Inc. Portions &copy; OpenStreetMap contributors.</a>';
goog.provide('alk.color');

goog.require('alk');

alk.color = {};

/**
 * This function takes a color and returns a new {@link ol.Color} that shades
 * the color according to the shade parameter, which is between -1 and 1.
 * @example
 * console.log(JSON.stringify(alk.color.shadeColor([128,20,100],-1)));
 * console.log(JSON.stringify(alk.color.shadeColor([128,20,100],-0.5)));
 * console.log(JSON.stringify(alk.color.shadeColor([128,20,100],0.0)));
 * console.log(JSON.stringify(alk.color.shadeColor([128,20,100],0.5)));
 * console.log(JSON.stringify(alk.color.shadeColor([128,20,100],1)));
 *
 * [0,0,0]
 * [64,10,50]
 * [128,20,100]
 * [192,138,178]
 * [255,255,255]
 *
 * @param {ol.Color|ol.ColorLike} color The color to shade
 * @param {number} shade A number between -1 and 1;
 * @return {ol.Color} This method returns a new color structure.
 * @api
 */
alk.color.shadeColor = function(color, shade) {
  var cs = ol.color.asArray(/** @type {Array.<number>|string} */ (color));
  var t = shade < 0 ? 0 : 255;
  var p = shade < 0 ? shade * -1 : shade;
  var nc = [];
  nc[0] = Math.round((t-cs[0])*p + cs[0]);
  nc[1] = Math.round((t-cs[1])*p + cs[1]);
  nc[2] = Math.round((t-cs[2])*p + cs[2]);

  return nc;
};
goog.provide('alk.control');

goog.require('alk');

alk.control = {};
goog.provide('alk.control.ContextMenu');

goog.require('alk');
goog.require('alk.control');

goog.require('alkx.ContextMenuOptions');

/**
 * @classdesc
 * The context menu control allows you to create a right-click menu to expose any custom functions.
 *
 * @description
 * This constructor creates a control that may be added to the Open Layers Map.
 * @example
 * var map = new ol.Map();
 * var menu = new alk.control.ContextMenu({
 *     'ctxMenuItems': [
 *         { separator: false, text: 'Zoom In', onclick: function(evt) { alert(evt); }},
 *         { separator: true },
 *         { separator: false, text: 'Zoom Out', onclick: function(evt) { alert(evt); }}
 *      ],
 * });
 * map.addControl(menu);
 * @param {alkx.ContextMenuOptions=} opt_options
 * @extends {ol.control.Control}
 * @constructor
 * @api
 */

alk.control.ContextMenu = function (opt_options) {
  var options = opt_options ? opt_options : {};

  this.normalizeItems(options);

  this.container = this.createContainer(true);
  this.eventHandler = this.handleEvent.bind(this);

  alk.control.ContextMenu.base(this, 'constructor', {
    element: this.container
  });
};
goog.inherits(alk.control.ContextMenu, ol.control.Control);

/**
 * @type {number}
 * @private
 */
alk.control.ContextMenu.prototype.lineheight;
/**
 * @type {ol.PluggableMap}
 * @private
 */
alk.control.ContextMenu.prototype.map_;

/**
 * @type {Element}
 * @private
 */
alk.control.ContextMenu.prototype.viewport_;

/**
 * @type {ol.Pixel}
 */
alk.control.ContextMenu.prototype.pixel;
/**
 * @type {ol.Coordinate}
 */
alk.control.ContextMenu.prototype.coordinate;
/**
 * @type {boolean}
 */
alk.control.ContextMenu.prototype.disabled;

/**
 * @type {Element}
 */
alk.control.ContextMenu.prototype.container;

/**
 * This method handles an event for the control.
 * @param {Event} evt
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.handleEvent = function (evt) {
  var self = this;

  self.coordinate = self.map_.getEventCoordinate(evt);
  self.pixel = self.map_.getEventPixel(evt);

  self.dispatchEvent({
    type: "beforeopen",
    pixel: self.pixel,
    coordinate: this.coordinate
  });

  if (self.disabled) {
    return;
  }
  if (evt.type === "contextmenu") {
    evt.stopPropagation();
    evt.preventDefault();
  }
  self.openMenu(self.pixel, self.coordinate);

  var listener = /** @type {EventListener} */({
    handleEvent:
      /**
       * @param {ol.MapBrowserEvent} e
       * @return {boolean}
       */
      function (e) {
        self.closeMenu();

        evt.target.removeEventListener(e.type, /** @type {EventListener} */(this), false);
        return true;
      }
  });
  // one time fire of the mousedown
  evt.target.addEventListener('mousedown', listener, false);
};

/**
 * This method sets the listeners on the view port.
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.setListeners = function () {
  this.viewport_.addEventListener("contextmenu", this.eventHandler, false);
};

/**
 * @description
 * This property configures the menu to handle right clicks. Default is true;
 * @type {boolean}
 * @api
 */
alk.control.ContextMenu.prototype.handleRightClicks = true;

/**
 * @description
 * Activates the control when it is added to a map. Default is true.
 * @type {boolean}
 * @api
 */
alk.control.ContextMenu.prototype.autoActivate = true;

/**
 * @description
 * Contains the context menu items.
 * @type {Object}
 * @api
 */
alk.control.ContextMenu.prototype.ctxMenuItems;

/**
 * @type {Array.<{
 *   index: (number),
 *   callback: (Function|undefined),
 *   separator: (boolean),
 *   name: (string|undefined),
 *   onclick: (boolean|string|undefined)
 *   }>}
 * @api
 */
alk.control.ContextMenu.prototype.items;

/**
 * This method creates a HTML Div container for the control.
 * @param {boolean} hidden
 * @returns {Element}
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.createContainer = function(hidden) {
  var container = document.createElement('div');
  container.id = 'ContextMenu';
  var css_classes = ['ol-control', 'ol-unselectable', 'alk-ctx-menu'];
  if (hidden) {
    css_classes.push('hidden');
  }
  container.className = css_classes.join(' ');
  container.style.width = parseInt(this.width, 10) + 'px';
  return container;
};

/**
 *
 * @param {alkx.ContextMenuOptions=} options
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.normalizeItems = function(options) {
  var self = this;
  this.items = [];
  if (options.ctxMenuItems !== undefined) {
    options.ctxMenuItems.forEach(function(optItem, index) {
      var item = {};
      item.index = index;
      if (optItem.separator === true) {
        item.separator = true;
      } else {
        item.name = optItem.text;
        item.callback = optItem.onclick;
      }
      self.items.push(item);
    });
  } else if (options.menuItems !== undefined) {
    Object.keys(/**@type{Object!}*/(options.menuItems)).forEach(function (key, index) {
      var item = {};
      item.index = index;
      item.name = key;
      if (key === 'separator' && !!options.menuItems[key]) {
        item.separator = true;
      } else {
        item.onclick = options.menuItems[key];
      }
      self.items.push(item);
    });
  }
};

/**
 * @type {number}
 * @private
 */
alk.control.ContextMenu.prototype.idCounter_ = 0;

/**
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.createMenu = function () {

  var ul = document.createElement('ul');

  for (var index = 0; index < this.items.length; index++) {
    var item = this.items[index];

    var li = document.createElement('li');
    if (item.separator) {
      li.className = 'separator';
    } else {
      var aTag = document.createElement('a');
      aTag.innerHTML = item.name;
      aTag.id = 'alkCTxMenu_item_' + this.idCounter_++;
      aTag.className = 'button';
      li.appendChild(aTag);
    }
    this.setItemListener(li, item);
    ul.appendChild(li);
    this.container.appendChild(ul);
  }
};

/**
 * @param {Element} li
 * @param {Object} item
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.setItemListener = function (li, item) {
  var self = this;
  if (li && typeof item.callback === 'function') {
    (function (callback) {
      li.addEventListener('click', function (evt) {
        evt.preventDefault();
        self.closeMenu();
        //TODO: This doesn't give any meaningful data to the click.
        callback(evt);
      });
    })(item.callback);
  } else if (li && typeof item.onclick === 'string') {
    li.innerHTML = '<a onclick="' + item.onclick + '">' + item.name + '</a>';
  }
};

/**
 * @description
 * The destroy method is used to perform any clean up before the control
 * is dereferenced.
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.destroy = function () {
    this.deactivate();
    alk.control.ContextMenu.base(this, 'destroy');
};

/**
 * Activates the control.
 * @returns {boolean} The control was effectively activated.
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.activate = function () {
  return alk.control.ContextMenu.base(this, 'activate');
};

/**
 * @description
 * Deactivates the control.
 * @return {boolean} The control was effectively deactivated.
 * @this {alk.control.ContextMenu}
 */
alk.control.ContextMenu.prototype.deactivate = function () {
  this.closeMenu();
  return alk.control.ContextMenu.base(this, 'deactivate');
};


/**
 * Remove the control from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.PluggableMap} map Map.
 * @this {alk.control.ContextMenu}
 * @override
 * @api
 */
alk.control.ContextMenu.prototype.setMap = function (map){
    alk.control.ContextMenu.base(this, 'setMap', map);
  this.viewport_ = map.getViewport();
  this.createMenu();
  this.setListeners();
  this.lineheight = this.items.length > 0
    ? this.container.offsetHeight / this.items.length
    : this.getLineHeight();
  };

/**
 * Update the mouseposition element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {alk.control.ContextMenu}
 * @override
 * @api
 */
alk.control.ContextMenu.prototype.render = function(mapEvent) {
};


/**
 * Update the mouseposition element.
 * @param {ol.Pixel} pixel The pixel on which the right click happened.
 * @this {alk.control.ContextMenu}
 * @api
 */
alk.control.ContextMenu.prototype.positionContainer = function (pixel) {
  var mapSize = this.map_.getSize();
  var width = mapSize[0];
  var height = mapSize[1];
  var remaining_width = width - pixel[0];
  var remaining_height = height - pixel[1];
  var size = {
    w: this.container.offsetWidth,
    h: Math.round(this.lineheight * this.items.length)
  };

  if (remaining_width >= size.w) {
    this.container.style.right = 'auto';
    this.container.style.left = '' + (pixel[0] + 5) + 'px';
  } else {
    this.container.style.left = 'auto';
    this.container.style.right = '15px';
  }

  if (remaining_height > -size.h) {
    this.container.style.bottom = 'auto';
    this.container.style.top = '' + (pixel[1] - 10) + 'px';
  } else {
    this.container.style.top = 'auto';
    this.container.style.bottom = '0';
  }
  var classNames = this.container.className;
  classNames = classNames.replace(/ ?hidden/ig, '');
  this.container.className = classNames;
};

/**
 * @description
 * Opens the menu given the coordinate and its corresponding pixel position.
 * @param {ol.Pixel} pixel
 * @param {ol.Coordinate} coordinate
 * @this {alk.control.ContextMenu}
 * @api
 */
alk.control.ContextMenu.prototype.openMenu = function(pixel, coordinate) {
    this.dispatchEvent({
      type: "open",
      pixel: pixel,
      coordinate: coordinate
    });
    var classNames = this.container.className;
    classNames = classNames.replace(/ ?hidden/i,'');
    this.container.className = classNames;
    this.positionContainer(pixel);
};

/**
 * @description
 * This method hides the context menu.
 * @this {alk.control.ContextMenu}
 * @api
 */
alk.control.ContextMenu.prototype.closeMenu = function () {
  var classNames = this.container.className;
  classNames = classNames + ' hidden';
  this.container.className = classNames;
};

/**
 * @description
 * This function returns the line height in pixels.
 * @this {alk.control.ContextMenu}
 * @returns {number}
 */
alk.control.ContextMenu.prototype.getLineHeight = function() {
  function createFrag(html) {
    var frag = document.createDocumentFragment();
    var temp = document.createElement('div');
    temp.innerHTML = html;
    while(temp.firstChild) {
      frag.appendChild(temp.firstChild);
    }
    return frag;
  }

  var cloned = this.container.cloneNode(false);
  var element1 = document.createElement('li');
  var element2 = document.createElement('li');
  var frag1 = createFrag('<span>Foo</span>');
  var frag2 = createFrag('<span>Foo</span>');
  element1.appendChild(frag1);
  element2.appendChild(frag2);
  cloned.appendChild(element1);
  cloned.appendChild(element2);
  this.container.parentNode.appendChild(cloned);
  var height = cloned.offsetHeight / 2;
  this.container.parentNode.removeChild(cloned);
  return height;

};
goog.provide('alk.img');

goog.require('alk');

alk.img = {};
goog.provide('alk.img.Hazmat');

goog.require('alk.img');
/**
 * This enum contains the Image URLs for Hazmat Conditions.
 * @enum {string}
 * @api
 */
// This is a place holder object. Elements will be reassigned with CDN based URLs.
alk.img.Hazmat = {
  /** @api */
  Caustic: 'hazmat_caustic',
  /** @api */
  Explosive: 'hazmat_explosive',
  /** @api */
  Flammable: 'hazmat_flammable',
  /** @api */
  Inhalants: 'hazmat_inhalants',
  /** @api */
  Radioactive: 'hazmat_radioactive',
  /** @api */
  GenericEU: 'hazmat_restr_eu',
  /** @api */
  GenericUS: 'hazmat_restr_na',
  /** @api */
  Water: 'hazmat_water'
};
goog.provide('alk.img.HazmatName');

goog.require('alk.img');
/**
 * This object is used to assign {@link alk.img.Hazmat} class once the CDN is set.
 * @enum {string}
 */
alk.img.HazmatName = {
  Caustic: 'hazmat_caustic',
  Explosive: 'hazmat_explosive',
  Flammable: 'hazmat_flammable',
  Inhalants: 'hazmat_inhalants',
  Radioactive: 'hazmat_radioactive',
  GenericEU: 'hazmat_restr_eu',
  GenericUS: 'hazmat_restr_na',
  Water: 'hazmat_water'
};
goog.provide('alk.img.Misc');

goog.require('alk.img');
/**
 * This enum contains the Image URLs for miscellaneous images.
 * @enum {string}
 * @api
 */
// This is a place holder class. This will be transformed on load when the CDN is set.
alk.img.Misc = {
  /** @api */
  AllowRoad: 'allow_road',
  /** @api */
  AvoidRoad: 'avoid_road',
  /** @api */
  Check: 'icon_fav_saved',
  /** @api */
  FlagEnd: 'flag_end',
  /** @api */
  FlagStart: 'flag_start',
  /** @api */
  FlagStop: 'flag_stop',
  /** @api */
  FlagWaypoint: 'flag_waypoint',
  /** @api */
  Help: 'icon_help',
  /** @api */
  LoadBlue: 'load_blue',
  /** @api */
  LoadGray: 'load_gray',
  /** @api */
  LoadGreen: 'load_green',
  /** @api */
  LoadRed: 'load_red',
  /** @api */
  No: 'hide_poi',
  /** @api */
  OilGas: 'oil_gas',
  /** @api */
  PinGreen: 'pin_green',
  /** @api */
  PinRed: 'pin_red',
  /** @api */
  Route: 'icon_edit_trip',
  /** @api */
  TruckBlue: 'truck_blue',
  /** @api */
  TruckGray: 'truck_gray',
  /** @api */
  TruckGreen: 'truck_green',
  /** @api */
  TruckRed: 'truck_red'
};
goog.provide('alk.img.MiscName');

goog.require('alk.img');
/**
 * This object is used to reassign the {@link alk.img.Misc} class with a CDN URL.
 * @enum {string}
 */
alk.img.MiscName = {
  AllowRoad: 'allow_road',
  AvoidRoad: 'avoid_road',
  Check: 'icon_fav_saved',
  FlagEnd: 'flag_end',
  FlagStart: 'flag_start',
  FlagStop: 'flag_stop',
  FlagWaypoint: 'flag_waypoint',
  Help: 'icon_help',
  LoadBlue: 'load_blue',
  LoadGray: 'load_gray',
  LoadGreen: 'load_green',
  LoadRed: 'load_red',
  No: 'hide_poi',
  OilGas: 'oil_gas',
  PinGreen: 'pin_green',
  PinRed: 'pin_red',
  Route: 'icon_edit_trip',
  TruckBlue: 'truck_blue',
  TruckGray: 'truck_gray',
  TruckGreen: 'truck_green',
  TruckRed: 'truck_red'
};
goog.provide('alk.img.POI');

goog.require('alk.img');
/**
 * This enum holds the Image URLs for Points of Interest.
 * @enum {string}
 * @api
 */
// This is a place holder class. This will be transformed on load when the CDN is set.
alk.img.POI = {
  /** @api */
  Address: 'address',
  /** @api */
  Airport: 'airport',
  /** @api */
  Atm: 'atm',
  /** @api */
  Attraction: 'attraction',
  /** @api */
  AutoDealer: 'auto_dealer',
  /** @api */
  AutoRental: 'auto_rental',
  /** @api */
  AutoRepair: 'auto_repair',
  /** @api */
  Bank: 'bank',
  /** @api */
  Blank: 'blank',
  /** @api */
  BorderCrossing: 'border_crossing',
  /** @api */
  BridgeTunnel: 'bridge_tunnel',
  /** @api */
  BusStop:'bus_stop',
  /** @api */
  CatScale: 'catscale',
  /** @api */
  City: 'city',
  /** @api */
  CommuterRail: 'commuter_rail',
  /** @api */
  DieselExhaustFluid: 'def',
  /** @api */
  Entertainment: 'entertainment',
  /** @api */
  Favorite: 'fav',
  /** @api */
  Ferry: 'ferry',
  /** @api */
  Fuel: 'fuel',
  /** @api */
  GameVenues: 'game_venues',
  /** @api */
  GenericResult: 'generic_result',
  /** @api */
  GeographicFeature: 'geographic_feature',
  /** @api */
  Grocery: 'grocery',
  /** @api */
  Home: 'home',
  /** @api */
  Hotel: 'hotel',
  /** @api */
  IndustrialEstate: 'industrial_estate',
  /** @api */
  LiveLink: 'live_link',
  /** @api */
  LiveSearch: 'live_search',
  /** @api */
  Marina: 'marina',
  /** @api */
  Marker: 'marker',
  /** @api */
  Medical: 'medical',
  /** @api */
  MotorcycleDealer: 'motorcycle_dealer',
  /** @api */
  Municipal: 'municipal',
  /** @api */
  MyCar: 'mycar',
  /** @api */
  OtherAirport: 'other_airport',
  /** @api */
  OtherLodging: 'other_lodging',
  /** @api */
  Other: 'other',
  /** @api */
  Park: 'park',
  /** @api */
  Parking: 'parking',
  /** @api */
  PlaceOfWorship: 'place_of_worship',
  /** @api */
  PublicVenue: 'public_venue',
  /** @api */
  Recent: 'recent',
  /** @api */
  Recreation: 'recreation',
  /** @api */
  RestArea: 'rest_area',
  /** @api */
  Restaurant: 'restaurant',
  /** @api */
  Retail: 'retail',
  /** @api */
  RV: 'rv',
  /** @api */
  SafetyCamera: 'safety_camera',
  /** @api */
  School: 'school',
  /** @api */
  TandemTrailer: 'tandem_trailer',
  /** @api */
  TollBooth: 'toll_booth',
  /** @api */
  TrainStation: 'train_station',
  /** @api */
  Truck: 'truck',
  /** @api */
  TruckStop: 'truck_stop',
  /** @api */
  VehicleChargingStation: 'vehicle_charging_station',
  /** @api */
  Wikipedia: 'wikipedia',
  /** @api */
  Work: 'work'
};
goog.provide('alk.img.POIName');

goog.require('alk.img');
/**
 * This object is used to reassign the {@link alk.img.POI} class with a CDN URL.
 * @enum {string}
 */
alk.img.POIName = {
  Address: 'address',
  Airport: 'airport',
  Atm: 'atm',
  Attraction: 'attraction',
  AutoDealer: 'auto_dealer',
  AutoRental: 'auto_rental',
  AutoRepair: 'auto_repair',
  Bank: 'bank',
  Blank: 'blank',
  BorderCrossing: 'border_crossing',
  BridgeTunnel: 'bridge_tunnel',
  BusStop:'bus_stop',
  CatScale: 'catscale',
  City: 'city',
  CommuterRail: 'commuter_rail',
  DieselExhaustFluid: 'def',
  Entertainment: 'entertainment',
  Favorite: 'fav',
  Ferry: 'ferry',
  Fuel: 'fuel',
  GameVenues: 'game_venues',
  GenericResult: 'generic_result',
  GeographicFeature: 'geographic_feature',
  Grocery: 'grocery',
  Home: 'home',
  Hotel: 'hotel',
  IndustrialEstate: 'industrial_estate',
  LiveLink: 'live_link',
  LiveSearch: 'live_search',
  Marina: 'marina',
  Marker: 'marker',
  Medical: 'medical',
  MotorcycleDealer: 'motorcycle_dealer',
  Municipal: 'municipal',
  MyCar: 'mycar',
  OtherAirport: 'other_airport',
  OtherLodging: 'other_lodging',
  Other: 'other',
  Park: 'park',
  Parking: 'parking',
  PlaceOfWorship: 'place_of_worship',
  PublicVenue: 'public_venue',
  Recent: 'recent',
  Recreation: 'recreation',
  RestArea: 'rest_area',
  Restaurant: 'restaurant',
  Retail: 'retail',
  RV: 'rv',
  SafetyCamera: 'safety_camera',
  School: 'school',
  TandemTrailer: 'tandem_trailer',
  TollBooth: 'toll_booth',
  TrainStation: 'train_station',
  Truck: 'truck',
  TruckStop: 'truck_stop',
  VehicleChargingStation: 'vehicle_charging_station',
  Wikipedia: 'wikipedia',
  Work: 'work'
};
goog.provide('alk.img.Traffic');

goog.require('alk.img');
/**
 * This enum holds the Image URLs for Traffic Conditions.
 * @enum {string}
 * @api
 */
// This is a place holder class. This will be transformed on load when the CDN is set.
alk.img.Traffic = {
  /** @api */
  MapAccident: 'map_accident',
  /** @api */
  MapConstruction: 'map_construction',
  /** @api */
  MapIncident: 'map_incident',
  /** @api */
  MapTrafficJam: 'map_trafficjam',
  /** @api */
  MapWeather: 'map_weather',
  /** @api */
  Severity1: 'severity_1',
  /** @api */
  Severity2: 'severity_2',
  /** @api */
  Severity3: 'severity_3'
};
goog.provide('alk.img.TrafficName');

goog.require('alk.img');
/**
 * This object is used to reassign the {@link alk.img.Traffic} class with a CDN URL.
 * @enum {string}
 */
alk.img.TrafficName = {
  MapAccident: 'map_accident',
  MapConstruction: 'map_construction',
  MapIncident: 'map_incident',
  MapTrafficJam: 'map_trafficjam',
  MapWeather: 'map_weather',
  Severity1: 'severity_1',
  Severity2: 'severity_2',
  Severity3: 'severity_3'
};
goog.provide('alk.img.TruckRestr');

goog.require('alk.img');
/**
 * This enum holds the Image URLs for Truck Restrictions.
 * @enum {string}
 * @api
 */
alk.img.TruckRestr = {
  /** @api */
  HeightEU: 'truck_restr_height_eu',
  /** @api */
  HeightNA: 'truck_restr_height_na',
  /** @api */
  LengthEU: 'truck_restr_length_eu',
  /** @api */
  LengthNA: 'truck_restr_length_na',
  /** @api */
  MultiEU: 'truck_restr_multi_eu',
  /** @api */
  MultiNA: 'truck_restr_multi_na',
  /** @api */
  NoTruckEU: 'truck_restr_notruck_eu',
  /** @api */
  NoTruckNA: 'truck_restr_notruck_na',
  /** @api */
  WeightEU: 'truck_restr_weight_eu',
  /** @api */
  WeightNA: 'truck_restr_weight_na',
  /** @api */
  WeightPerAxleEU: 'truck_restr_weight_per_axle_eu',
  /** @api */
  WeightPerAxleNA: 'truck_restr_weight_per_axle_na',
  /** @api */
  WidthEU: 'truck_restr_width_eu',
  /** @api */
  WidthNA: 'truck_restr_width_na'
};
goog.provide('alk.img.TruckRestrName');

goog.require('alk.img');
/**
 * This object is used to assign the {@link alk.img.TruckRestr} enum once the CDN is set.
 * @enum {string}
 */
alk.img.TruckRestrName = {
  HeightEU: 'truck_restr_height_eu',
  HeightNA: 'truck_restr_height_na',
  LengthEU: 'truck_restr_length_eu',
  LengthNA: 'truck_restr_length_na',
  MultiEU: 'truck_restr_multi_eu',
  MultiNA: 'truck_restr_multi_na',
  NoTruckEU: 'truck_restr_notruck_eu',
  NoTruckNA: 'truck_restr_notruck_na',
  WeightEU: 'truck_restr_weight_eu',
  WeightNA: 'truck_restr_weight_na',
  WeightPerAxleEU: 'truck_restr_weight_per_axle_eu',
  WeightPerAxleNA: 'truck_restr_weight_per_axle_na',
  WidthEU: 'truck_restr_width_eu',
  WidthNA: 'truck_restr_width_na'
};
/**
 * This option is included at the beginning of the concatenation
 * of the source files in dependency order. It nullifies the
 * calls to goog.provide and goog.require.
 * @define {boolean}
 */
COMPILED = true;


goog.provide('pcmws');

var pcmws = {};

pcmws.ARG_CHECK = false;
pcmws.ARG_PERMISSIVE = true;

/**
 * @define {string} ALK Maps Logo
 */
pcmws.ALK_LOGO_URL = 'data:image/png;base64,'+
  'iVBORw0KGgoAAAANSUhEUgAAAEAAAAAPCAYAAABUZ8lnAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZV'+
  'JlYWR5ccllPAAAAopJREFUeNpiLKibEM7AwLCCgbbgQ39jvmDN8qv1QHYDw+ABEUx08DwDK9t/gbLWCSDP'+
  'NzIMLrCCiR62/P7FyDDIYh4OiA0ARhxskkBLpPagCwCWweIQUOAsPfyI4fqTz2A+BxszQ02wBsPUHXcZnr'+
  '//ARazUhcG08duvgXTkoIcDNkeynAztp17AZYD6QWpddIRBYuvO/GU4dz9D4M7AGAehAWAkaIAJCBYmeHy'+
  'XkYSKAEAk5u79wGDIDcrQ5CFNFwtyPOgAJUU5ASL4woAeBYAltKMMAxN5huIdHcgVM8HSgNAUYwbjJE9Cw'+
  'OaMrxY2SBw/9VXuAdBsQ/CIAAKzH2XXzEAax/CWaCwfuJ/JHHBCU0FgcAq8j8BNycCPb8BTS/ZAJTUjZQE'+
  'wLH54etvBgEgDQPRtnLgJA7yHIiN7ClY1oCY8R2s10pNCF7mIGctYgvB+QTc+hDq+QVAz6+nVhY4Dkzahs'+
  'CkD0qyoJiDAViM/vj1l+HDl18oYrDUAsKgrADyKCggW9beAJcf+668BgcYsnpiyoAAYOzjc6sBKMlTK+Zh'+
  '4D0w5s5DkzIoScPytDc0OyDncZDYuXsQtehJ3AgaiCBxUKCBygNOViYwG1sALADFJqktO2ggUB1sBSZzQa'+
  'SkDwKgVAEr4WFJ3gspALABUMkPywKgQAUFLq4UAPJ8BxCX46n7UQCwfABRFwikEpIAKLmCHAmKpefQmAIl'+
  '6ecffsBpGAClDlDBB1IP0ocOQPKgJP8eqO/D1184PQ/3JNAjoIzFikXuPx62ISgQkMQJNYcZuqoLGIHJ8j'+
  '/DIAKwQnAaGdXYfmg2ILZlOKibwgXQqo8RhIn0lAAJgfABGPuN0N7gYAIRAAEGAK2YF6+T50GTAAAAAElF'+
  'TkSuQmCC';

  pcmws.AERIS_WEATHER_LOGO_URL = 'data:image/png;base64,'+
  'iVBORw0KGgoAAAANSUhEUgAAADkAAAAUCAYAAAA3KpVtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZV'+
  'JlYWR5ccllPAAAAvBJREFUeNrcV7tuE1EQXRv3+A+8dHRefgBvfiDkC7D9AQij0KI4oo7slAikNX0kB7pU'+
  'u6FDFHY6UArbLc1uOpLGmSudkQ6Xeze2lQJnpCPv7tzXzJnHdRBsLqFgIJgJlvhNBRNBJ3gAYozIYZh5rl'+
  'v6CNhqAw1zSfDAxLCyJ+jDwImDvf9WKiU6Y0RP0Eb+FYKppZ8LjgXZtjI3o7CMShxhwjem9xQIHeMHpLeh'+
  '+/r0Pet8qVXg3gkuBTfAD8GRoFHzHFw3fWaxZ4thd0TvPTL4QNB1OM/oD0ucFiMyzvHtMVLFOKiJNXWcjn'+
  'kJIxeC9/jWEryiMf94e7lhdZxRK8kdeZtibZ/E0Pc9ay89407AXsvhtKDq2Wh0B4O+qhsiRz9TKN+HhFiv'+
  '8Ogv8PsJ7DUo0v4KowQG5h5PupzhYknZ0z6qodUnNjjXxgjzkBiakV7nLMlpLsaPKB81J00YBzUYOEb+FW'+
  'tUyjnmqSfrYD/GmgW+5RjDkeHKyT1y0By51ILxGXJxXnKefeTjLsEw+1xjfWAxlK4ZShMYwwwlxMqmOalO'+
  'yq1qXZa7KiZkfxtWq5jMFShDTq2aTwX10R1CF+yFnnay6tpaTccl45S1XZdSC89r6/vojtCwC445xKlDd0'+
  'zthGXpgE9OgciKOJYmDDyhnLzEufYf4dbTwSJngj+UF1oMfpYc4ily8oOj+pk1rqGfYq8LRI4NrQVXeGYn'+
  'n2Gda8+4b4KPgu+CX3g3eCv4av+ryOGtiCpkGGy5VBxXtBdWe1ilspUVJZ6XYC0N8SGceoVCscB+GfXdPt'+
  'Aixg+Q9wF0Ge7YC4pAvS0tqlaSDzG5gpayQ7eNFAvGJezGOFyCwxeOph0hh5pYZ0G6jFpNC4esY99zMkh7'+
  'b2ytnVFtMM9fzD7VEhamGGgMfYIJDXhxYhUNbR9tzH0DFI4i0iandjwFS5muWxfzdcU4+rC2RuMf3kN6zO'+
  'H9LoVv33HfbFMUjT2tJfPcvEJi0ji6cyvAAPqOA3rZixvJAAAAAElFTkSuQmCC';
goog.provide('pcmws.api');

goog.require('pcmws');

pcmws.api = {};
goog.provide('pcmws.api.Param');

goog.require('pcmws.api');

/**
 * @classdesc
 *
 * An instance of this class holds the parameter name and value of a parameter in a PCMiler webservice. Subtypes
 * of this class checks the value against known values for the parameter.
 *
 * @param {string} name The name of the parameter.
 * @param {*=} value The value of the parameter.
 * @constructor
 *
 */
pcmws.api.Param = function (name, value) {
  this.shouldEncodeName = false;
  this.shouldEncodeValue = false;

  this.name = name;
  this.value = value;
};

/**
 * @description
 * Contains the value of this parameter. It should only be assigned by the constructor.
 * @type {*}
 */
pcmws.api.Param.prototype.value;

/**
 * @description
 * This function is used internally to check the validity of the value. Returns the value or undefined, or
 * possibly throws an exception based on the subtype.
 *
 * @param  {*} value The value to check. Default is to pass through.
 * @returns {*}
 */
pcmws.api.Param.prototype.check = function (value) {
  return value;
};

/**
 * @description
 * This utility function is used internally to check the validity of the value against a particular string or number.
 *
 * @param {*} val The value to check
 * @param {string} str The string to check the value against
 * @param {number|string} num The number to check the value against.
 * @returns {boolean}
 */
pcmws.api.Param.prototype.checkValue = function (val, str, num) {
  return val === str || val === num || val === ('' + num);
};

/**
 * @returns {*}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getValue = function () {
  return this.value;
};

/**
 * This function checks the value of the parameter.
 * @returns {*}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getCheckedValue = function () {
  return this.check(this.value);
};

/**
 * This function checks the value of the parameter as string.
 * @returns {string|undefined}
 * @this {pcmws.api.Param}
 */

pcmws.api.Param.prototype.getCheckedStringValue = function () {
  var value = this.getCheckedValue();
  if (value === undefined && this.value !== undefined) {
    if (typeof this.value === 'string') {
      return this.value;
    }
  }
  if (value !== undefined) {
    return ''+value;
  }
};

/**
 * This function checks the value of the parameter as a data value.
 * @returns {string|undefined}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getCheckedDataValue = function () {
  var value = this.getCheckedValue();
  if (value === undefined && this.value !== undefined) {
    if (typeof this.value === 'string') {
      return this.value;
    }
  }
  if (value !== undefined) {
    return ''+value;
  }
};

/**
 * @returns {string|undefined}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getValueForURL = function () {
  var value = this.getCheckedStringValue();
  if (value !== undefined) {
    if (this.shouldEncodeValue) {
      value = encodeURIComponent(value);
    }
  } else {
    if (this.value !== undefined && pcmws.ARG_PERMISSIVE) {
      if (this.shouldEncodeValue) {
        value = encodeURIComponent(""+this.value);
      }
    }
  }
  return value;
};

/**
 * @returns {*}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getValueForData = function () {
  var value = this.getCheckedDataValue();
  if (value !== undefined) {
    if (this.shouldEncodeValue) {
      value = encodeURIComponent(value);
    }
  } else {
    if (this.value !== undefined && pcmws.ARG_PERMISSIVE) {
      if (this.shouldEncodeValue) {
        value = encodeURIComponent(""+this.value);
      }
    }
  }
  return value;
};

/**
 * @description
 * This function returns the string parameter in the form of 'name=value' for this instance. The name and/or
 * value can be URI encoded by setting the shouldEncodeName, or shouldEncodeValue property, respectively.
 * @returns {string|undefined}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getURLParam = function () {
  var value = this.getValueForURL();
  var n = this.shouldEncodeName ? encodeURIComponent(this.name) : this.name;
  if (value !== undefined) {
    return n + '=' + value;
  } else {
    if (this.value !== undefined && pcmws.ARG_PERMISSIVE) {
      return n + '=' + this.value;
    }
    return undefined;
  }
};

/**
 * @description
 * This function returns the string parameter in the form of '"name" : "value" ' for this instance. The name and/or
 * value can be URI encoded by setting the shouldEncodeName, or shouldEncodeValue property, respectively.
 * @returns {string|undefined}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getDataParam = function () {
  var value = this.getValueForData();
  if (this.value !== undefined) {
    var n = this.shouldEncodeName ? encodeURIComponent(this.name) : this.name;
    if (value === undefined && pcmws.ARG_PERMISSIVE) {
      return '"'+ n + '":"' + this.value + '"';
    }
    return '"'+ n + '":"' + value +'"';
  } else {
    return undefined;
  }
};

/**
 * @description
 * This function returns the parameter in the form of ["name", obj] for this instance. The name and/or
 * value can be URI encoded by setting the shouldEncodeName, or shouldEncodeValue property, respectively.
 * @returns {Array.<string|Object>|undefined}
 * @this {pcmws.api.Param}
 */
pcmws.api.Param.prototype.getDataPair = function () {
  var value = this.getCheckedValue();
  if (this.value !== undefined) {
    var n = this.shouldEncodeName ? encodeURIComponent(this.name) : this.name;
    if (value === undefined && pcmws.ARG_PERMISSIVE) {
      return [n, this.value];
    }
    return [n, value];
  } else {
    return undefined;
  }
};
goog.provide('pcmws.api.AuthToken');

goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class contains the AuthToken parameter for a PCM service.
 *
 * @param {string=} value Authentication Token
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.AuthToken = function (value) {
  pcmws.api.AuthToken.base(this, 'constructor', 'authToken', value);
};
goog.inherits(pcmws.api.AuthToken, pcmws.api.Param);
goog.provide('pcmws.api.StaticServiceURL');

goog.require('pcmws.api');
/**
 * @classdesc
 * This class is used to construct a host + path URL.
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path.
 * @constructor
 * @api
 *
 */
pcmws.api.StaticServiceURL = function (hosturl, path) {
  if (hosturl !== undefined) {
    this.hostURL = hosturl;
  }
  if (path !== undefined) {
    this.path = path;
  }
};

/**
 * @description
 * This value contains the host url part (minus the path).
 * @type {string}
 * @api
 *
 */
pcmws.api.StaticServiceURL.prototype.hostURL;

/**
 * @description
 * This value contains the path of the url.
 * @type {string}
 * @api
 *
 */
pcmws.api.StaticServiceURL.prototype.path;

/**
 * @description
 * This function returns the combination of its hostURL and its path.
 * @this {pcmws.api.StaticServiceURL}
 * @returns {string}
 */
pcmws.api.StaticServiceURL.prototype.value = function () {
  if (this.hostURL !== undefined) {
    if (this.path !== undefined) {
      return this.hostURL + this.path;
    } else {
      return this.hostURL;
    }
  } else {
    return '';
  }
};

/**
 * @returns {string}
 * @this {pcmws.api.StaticServiceURL}
 * @override
 */
pcmws.api.StaticServiceURL.prototype.toString = function () {
  return this.value();
};
goog.provide('pcmws.api.ContentServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * This class is used to construct a host + path URL for ALK Content Services, which are
 * different than PC Miler web services. Since it extends {@link pcmws.api.StaticServiceURL} it
 * exists merely to set a different hostURL for ALK Content Services vs. PCM Services.
 *
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path.
 * @extends {pcmws.api.StaticServiceURL}
 * @constructor
 * @api
 *
 */
pcmws.api.ContentServiceURL = function (hosturl, path) {
  pcmws.api.ContentServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.ContentServiceURL, pcmws.api.StaticServiceURL);

goog.provide('pcmws.api.SingleSearchServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * This class is used to construct a host + path URL for ALK Single Search Services, which are
 * different than ALK Content web services. Since it extends {@link pcmws.api.StaticServiceURL} it
 * exists merely to set a different hostURL for PCM Services vs ALK Single Search Services.
 *
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path.
 * @extends {pcmws.api.StaticServiceURL}
 * @constructor
 *
 */
pcmws.api.SingleSearchServiceURL = function (hosturl, path) {
  pcmws.api.SingleSearchServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.SingleSearchServiceURL, pcmws.api.StaticServiceURL);

goog.provide('pcmws.api.CountriesSingleSearchURL');

goog.require('pcmws.api');
goog.require('pcmws.api.SingleSearchServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the Single Search Countries service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.SingleSearchServiceURL}
 *
 */
pcmws.api.CountriesSingleSearchURL = function (hosturl, path) {
  pcmws.api.CountriesSingleSearchURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.CountriesSingleSearchURL, pcmws.api.SingleSearchServiceURL);

/**
 * @description
 * The default path for the Single Search Countries URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.CountriesSingleSearchURL.prototype.path;
goog.provide('pcmws.api.RestServiceURL');

goog.require('pcmws.api');
/**
 * @classdesc
 * This class is used to hold the host and base path of a URL for a Rest Service.
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path.
 * @constructor
 * @api
 *
 */
pcmws.api.RestServiceURL = function (hosturl, path) {
  if (hosturl !== undefined) {
    this.hostURL = hosturl;
  }
  if (path !== undefined) {
    this.path = path;
  }
};

/**
 * @description
 * This value contains the host url part (minus the path).
 * @type {string}
 * @api
 *
 */
pcmws.api.RestServiceURL.prototype.hostURL;

/**
 * @description
 * This value contains the path of the url.
 * @type {string}
 * @api
 *
 */
pcmws.api.RestServiceURL.prototype.path;
goog.provide('pcmws.api.CustomCategoriesRestServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.RestServiceURL');
/**
 * @classdesc
 * This class is used to hold the host and base path of a URL for the Custom Categories Rest Service.
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path. See {@link pcmws.api.CustomCategoriesRestServiceURL#path} for documentation.
 * @extends {pcmws.api.RestServiceURL}
 * @constructor
 *
 */
pcmws.api.CustomCategoriesRestServiceURL = function (hosturl, path) {
  pcmws.api.CustomCategoriesRestServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.CustomCategoriesRestServiceURL, pcmws.api.RestServiceURL);

/**
 * @description
 * This value contains the path of the url. The path should contain the following
 * strings:
 *     '{XDR}'   This string gets replaced with 'XDR/', and is used only
 *               when dealing with IE 8 & 9.
 * Example:
 *   new pcmws.api.CustomCategoriesRestServiceURL(
 *       'https://pcmiler.alk.com',
 *       '/apis/rest/v1.0/service.svc/{XDR}customCategories');
 * @type {string}
 *
 */
pcmws.api.CustomCategoriesRestServiceURL.prototype.path;
goog.provide('pcmws.api.CustomPlaceSetsRestServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.RestServiceURL');
/**
 * @classdesc
 * This class is used to hold the host and base path of a URL for the Custom Place Sets Rest Service.
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path. See {@link pcmws.api.CustomPlaceSetsRestServiceURL#path} for documentation.
 * @extends {pcmws.api.RestServiceURL}
 * @constructor
 *
 */
pcmws.api.CustomPlaceSetsRestServiceURL = function (hosturl, path) {
  pcmws.api.CustomPlaceSetsRestServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.CustomPlaceSetsRestServiceURL, pcmws.api.RestServiceURL);

/**
 * @description
 * This value contains the path of the url. The path should contain the following
 * strings:
 *     '{XDR}'   This string gets replaced with 'XDR/', and is used only
 *               when dealing with IE 8 & 9.
 * Example:
 *   new pcmws.api.CustomPlacesRestServiceURL(
 *       'https://pcmiler.alk.com',
 *       '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets');
 * @type {string}
 *
 */
pcmws.api.CustomPlaceSetsRestServiceURL.prototype.path;
goog.provide('pcmws.api.CustomPlacesRestServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.RestServiceURL');
/**
 * @classdesc
 * This class is used to hold the host and base path of a URL for the Custom Places Rest Service.
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path. See {@link pcmws.api.CustomPlacesRestServiceURL#path} for documentation.
 * @extends {pcmws.api.RestServiceURL}
 * @constructor
 *
 */
pcmws.api.CustomPlacesRestServiceURL = function (hosturl, path) {
  pcmws.api.CustomPlacesRestServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.CustomPlacesRestServiceURL, pcmws.api.RestServiceURL);

/**
 * @description
 * This value contains the path of the url. The path should contain the following
 * strings:
 *     '{XDR}'   This string gets replaced with 'XDR/', and is used only
 *               when dealing with IE 8 & 9.
 *     '{setId}' This string gets replaced with the Set Id number for which the
 *               places belong.
 * Example:
 *   new pcmws.api.CustomPlacesRestServiceURL(
 *       'https://pcmiler.alk.com',
 *       '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets/{setId}/customPlace');
 *
 * @type {string}
 *
 */
pcmws.api.CustomPlacesRestServiceURL.prototype.path;
goog.provide('pcmws.api.DriveTimePolygonURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Drive Time Polygon service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.DriveTimePolygonURL = function (hosturl, path) {
  pcmws.api.DriveTimePolygonURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.DriveTimePolygonURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Drive Time Polygon URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.DriveTimePolygonURL.prototype.path;
goog.provide('pcmws.api.LocationsReverseURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Locations Reverse service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.LocationsReverseURL = function (hosturl, path) {
  pcmws.api.LocationsReverseURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.LocationsReverseURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Locations Reverse URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.LocationsReverseURL.prototype.path;
goog.provide('pcmws.api.LocationsURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Locations service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.LocationsURL = function (hosturl, path) {
  pcmws.api.LocationsURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.LocationsURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Locations URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.LocationsURL.prototype.path;
goog.provide('pcmws.api.PCMServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * This class is used to construct a host + path URL for ALK PC Miler Services, which are
 * different than ALK Content web services. Since it extends {@link pcmws.api.StaticServiceURL} it
 * exists merely to set a different hostURL for PCM Services vs ALK Content Services.
 *
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path.
 * @extends {pcmws.api.StaticServiceURL}
 * @constructor
 * @api
 *
 */
pcmws.api.PCMServiceURL = function (hosturl, path) {
  pcmws.api.PCMServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.PCMServiceURL, pcmws.api.StaticServiceURL);

goog.provide('pcmws.api.MapTileURL');

goog.require('pcmws.api');
goog.require('pcmws.api.PCMServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Maptile service
 * Since it extends the {@link pcmws.api.PCMServiceURL} it exists here merely to set a default
 * path for it in the prototype.
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.PCMServiceURL}
 * @api
 *
 */
pcmws.api.MapTileURL = function (hosturl, path) {
  pcmws.api.MapTileURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.MapTileURL, pcmws.api.PCMServiceURL);
goog.provide('pcmws.api.MapURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Map service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.MapURL = function (hosturl, path) {
  pcmws.api.MapURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.MapURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Map URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.MapURL.prototype.path;
goog.provide('pcmws.api.NATrafficTileURL');

goog.require('pcmws.api');
goog.require('pcmws.api.PCMServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the ALK Traffic Tile service for the NA region
 * from the PCM Server.
 * Since it extends the {@link pcmws.api.PCMServiceURL} it exists here merely to set a default
 * path for it in the prototype.
 *
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.PCMServiceURL}
 *
 */
pcmws.api.NATrafficTileURL = function (hosturl, path) {
  pcmws.api.NATrafficTileURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.NATrafficTileURL, pcmws.api.PCMServiceURL);
goog.provide('pcmws.api.POICategoriesSingleSearchURL');

goog.require('pcmws.api');
goog.require('pcmws.api.SingleSearchServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the Single Search POICategories service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.SingleSearchServiceURL}
 *
 */
pcmws.api.POICategoriesSingleSearchURL = function (hosturl, path) {
  pcmws.api.POICategoriesSingleSearchURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.POICategoriesSingleSearchURL, pcmws.api.SingleSearchServiceURL);

/**
 * @description
 * The default path for the Single Search POICategories URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.POICategoriesSingleSearchURL.prototype.path;
goog.provide('pcmws.api.POIURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler POI service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.POIURL = function (hosturl, path) {
  pcmws.api.POIURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.POIURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the POI URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.POIURL.prototype.path;
goog.provide('pcmws.api.PolygonsCountyURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Locations service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.PolygonsCountyURL = function (hosturl, path) {
  pcmws.api.PolygonsCountyURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.PolygonsCountyURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Locations URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.PolygonsCountyURL.prototype.path;
goog.provide('pcmws.api.RoadSurfaceRouteURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Route Reports service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.RoadSurfaceRouteURL = function (hosturl, path) {
  pcmws.api.RoadSurfaceRouteURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.RoadSurfaceRouteURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Route Reports URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.RoadSurfaceRouteURL.prototype.path;
goog.provide('pcmws.api.RoadSurfaceTileURL');

goog.require('pcmws.api');
goog.require('pcmws.api.PCMServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the ALK Traffic Tile service for the NA region
 * from the PCM Server.
 * Since it extends the {@link pcmws.api.PCMServiceURL} it exists here merely to set a default
 * path for it in the prototype.
 *
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.PCMServiceURL}
 *
 */
pcmws.api.RoadSurfaceTileURL = function (hosturl, path) {
  pcmws.api.RoadSurfaceTileURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.RoadSurfaceTileURL, pcmws.api.PCMServiceURL);
goog.provide('pcmws.api.RouteReportsURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Route Reports service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.RouteReportsURL = function (hosturl, path) {
  pcmws.api.RouteReportsURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.RouteReportsURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Routr Reports URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.RouteReportsURL.prototype.path;
goog.provide('pcmws.api.RouteURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Route service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.RouteURL = function (hosturl, path) {
  pcmws.api.RouteURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.RouteURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Route URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.RouteURL.prototype.path;
goog.provide('pcmws.api.SatelliteTileURL');

goog.require('pcmws.api');
goog.require('pcmws.api.ContentServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the Satellite Tile service from the Content Server.
 * Since it extends the {@link pcmws.api.ContentServiceURL} it exists here merely to set a default
 * path for it in the prototype.
 *
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.ContentServiceURL}
 *
 */
pcmws.api.SatelliteTileURL = function (hosturl, path) {
  pcmws.api.SatelliteTileURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.SatelliteTileURL, pcmws.api.ContentServiceURL);
goog.provide('pcmws.api.SearchSingleSearchURL');

goog.require('pcmws.api');
goog.require('pcmws.api.SingleSearchServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the Single Search States service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.SingleSearchServiceURL}
 *
 */
pcmws.api.SearchSingleSearchURL = function (hosturl, path) {
  pcmws.api.SearchSingleSearchURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.SearchSingleSearchURL, pcmws.api.SingleSearchServiceURL);

/**
 * @description
 * The default path for the Single Search States URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.SearchSingleSearchURL.prototype.path;
goog.provide('pcmws.api.SearchTypesSingleSearchURL');

goog.require('pcmws.api');
goog.require('pcmws.api.SingleSearchServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the Single Search SearchTypes service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.SingleSearchServiceURL}
 *
 */
pcmws.api.SearchTypesSingleSearchURL = function (hosturl, path) {
  pcmws.api.SearchTypesSingleSearchURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.SearchTypesSingleSearchURL, pcmws.api.SingleSearchServiceURL);

/**
 * @description
 * The default path for the Single Search SearchTypes URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.SearchTypesSingleSearchURL.prototype.path;
goog.provide('pcmws.api.StatesSingleSearchURL');

goog.require('pcmws.api');
goog.require('pcmws.api.SingleSearchServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the Single Search States service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.SingleSearchServiceURL}
 *
 */
pcmws.api.StatesSingleSearchURL = function (hosturl, path) {
  pcmws.api.StatesSingleSearchURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.StatesSingleSearchURL, pcmws.api.SingleSearchServiceURL);

/**
 * @description
 * The default path for the Single Search States URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.StatesSingleSearchURL.prototype.path;
goog.provide('pcmws.api.XMLHttpRequest');

/**
 * This object is used to mimic an XMLHttpRequest. Its purpose is
 * to replace the 'response' key, because we cannot modify it in
 * XMLHttpRequest. This object is necessary because some browsers
 * ignore the 'json' xhr.responseType parameter.
 * @param {XMLHttpRequest} xhr
 * @param {Object} response
 * @constructor
 * @extends {XMLHttpRequest}
 */
pcmws.api.XMLHttpRequest = function (xhr, response) {
  Object.keys(/** @type {Object!} */(xhr)).forEach(function (k) {
    this[k] = xhr[k];
  });
  this['response'] = response;
};
goog.inherits(pcmws.api.XMLHttpRequest, XMLHttpRequest);
goog.provide('pcmws.api.Service');

goog.require('pcmws.api');
goog.require('pcmws.api.XMLHttpRequest');

/**
 * This class holds the base operations for everything we call a
 * pcmws Service.
 * @constructor
 * @abstract
 */
pcmws.api.Service = function () {};

/**
 * This method returns a pcmws.api.XMLHttpRequest if the
 * response type was 'json' and it didn't work in the browser.
 * Some browsers do not do the conversion. It is used in all
 * xhr* methods and wraps the response xhr.
 * @param {string?} responseType
 * @param {XMLHttpRequest} xhr
 * @return {XMLHttpRequest}
 * @private
 */
pcmws.api.Service.prototype.jsonFix_ = function (responseType, xhr) {
  var nxhr = xhr;
  try {
    if (responseType === 'json') {
      var response = xhr.response;
      if (response) {
        if (typeof response === 'string') {
          var obj = /** @type {Object} */ (JSON.parse(response));
          nxhr = new pcmws.api.XMLHttpRequest(xhr, obj);
        }
      }
    }
  } catch (e) {
  }
  return nxhr;
};

/**
 * Adds headers to an XHR.
 * Notably, this implementation does NOT take into consideration
 * multiple occurrences of the same header.
 * @param {XMLHttpRequest} xhr
 * @param {Object} headers
 * @private
 */
pcmws.api.Service.prototype.addHeaders_ = function (xhr, headers) {
  if (headers) {
    Object.keys(headers).forEach(function(key) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    });
  }
};

/**
 * @param {string} url
 * @param {string} method
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {string|null} data
 * @param {Function} success
 * @param {Function} failure
 * @protected
 * @this {pcmws.api.Service}
 */
pcmws.api.Service.prototype.xhrInvoke = function (url, method, type, headers, data, success, failure) {
  var self = this;
  var xhr = new XMLHttpRequest();
  xhr.open(method, url, true);
  if (type) {
    xhr.responseType = type;
  }
  this.addHeaders_(xhr, headers);
  xhr.onload = function (event) {
    if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
      success.call(self, self.jsonFix_(type, xhr));
    } else {
      failure.call(self, self.jsonFix_(type, xhr));
    }
  };
  xhr.onerror = function () {
    failure.call(self, self.jsonFix_(type, xhr));
  };
  if (data) {
    xhr.send(data);
  } else {
    xhr.send();
  }
};

/**
 *
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {Function} success
 * @param {Function} failure
 * @protected
 * @this {pcmws.api.Service}
 */
pcmws.api.Service.prototype.xhrGet = function (url, type, headers, success, failure) {
  this.xhrInvoke(url, 'GET', type, headers, null, success, failure);
};
/**
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {string|null} data
 * @param {Function} success
 * @param {Function} failure
 * @protected
 * @this {pcmws.api.Service}
 */
pcmws.api.Service.prototype.xhrPost = function (url, type, headers, data, success, failure) {
  this.xhrInvoke(url, 'POST', type, headers, data, success, failure);
};

/**
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {string|null} data
 * @param {Function} success
 * @param {Function} failure
 * @protected
 * @this {pcmws.api.Service}
 */
pcmws.api.Service.prototype.xhrPut = function (url, type, headers, data, success, failure) {
  this.xhrInvoke(url, 'PUT', type, headers, data, success, failure);
};


/**
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {Function} success
 * @param {Function} failure
 * @protected
 * @this {pcmws.api.Service}
 */
pcmws.api.Service.prototype.xhrDelete = function (url, type, headers, success, failure) {
  this.xhrInvoke(url, 'DELETE', type, headers, null, success, failure);
};
goog.provide('pcmws.api.StaticService');

goog.require('pcmws.api');
goog.require('pcmws.api.Service');

goog.require('pcmws.api.StaticServiceOptions');

/**
 *
 * @param {Array.<Array.<string|Function>>} specs
 * @param {Object=} opt_options
 * @extends {pcmws.api.Service}
 * @constructor
 * @api
 */
pcmws.api.StaticService = function (specs, opt_options) {
  this.formalParameters = {};
  this.formalParameterDefaults = {};
  var self = this;
  specs.forEach(function (spec) {
    var optionKey = /** @type {string} */(spec[0]);
    var type = /** @type {Function} */(spec[1]);
    var def = spec[2];
    self.formalParameters[optionKey] = type;
    self.formalParameterDefaults[optionKey] = def;
  });
  this.processOptions(opt_options);
};
goog.inherits(pcmws.api.StaticService, pcmws.api.Service);

/**
 * @type {Object.<string,Function>}
 */
pcmws.api.StaticService.prototype.formalParameters;

/**
 * @type {Object.<string,*>}
 */
pcmws.api.StaticService.prototype.formalParameterDefaults;

/**
 * @description
 * Contains the service URL, which is the hostURL and path.
 * @type {pcmws.api.StaticServiceURL}
 */
pcmws.api.StaticService.prototype.serviceURL_;

/**
 * @description
 * Returns the combination of the host and path of the for this particular service.
 * @this {pcmws.api.StaticService}
 * @return {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.StaticService.prototype.getServiceURL = function () {
  return this.serviceURL_;
};

/**
 * @description
 * Returns the combination of the host and path of for the attribution of this particular service.
 * @this {pcmws.api.StaticService}
 * @return {pcmws.api.StaticServiceURL|string|undefined}
 *
 */
pcmws.api.StaticService.prototype.getServiceAttributionURL = function () {
  return new pcmws.api.StaticServiceURL(this.getServiceURL().hostURL,
      this.getServiceURL().path + '/attribution');
};

/**
 * This method is meant to clone this object from its given options.
 * This method must be overridden or it will throw an error.
 *
 */
pcmws.api.StaticService.prototype.clone = function () {
  throw "Needs to be overridden by the particular service";
  // constructor(this.toServiceOptions());
};

/**
 * This function processes options for both URL creation and requests.
 * @param {Object=} opt_options Options
 * @this {pcmws.api.StaticService}
 * @protected
 */
pcmws.api.StaticService.prototype.processOptions = function (opt_options) {

  var options = opt_options !== undefined ? opt_options : {};
  var self = this;
  Object.keys(/** @type {!Object} */(this.formalParameters)).forEach(function (optionKey) {
    if (self.formalParameters.hasOwnProperty(optionKey)) {
      var value = options[optionKey];
      if (value === undefined) {
        value = self.formalParameterDefaults[optionKey];
      }
      if (value !== undefined) {
        /** @constructor @param {Object} options
         */
        //var constructor = /** @type {function(new:constructor, Object)} */(self.formalParameters[optionKey]);
        //self[optionKey] = (new constructor(/** @type {!Object} */(value)));
        var constructor = self.formalParameters[optionKey];
        self[optionKey] = new constructor(value);
      } else {
        var param = self[optionKey];
        if (param instanceof pcmws.api.Param) {
          self[optionKey] = param;
        }
      }
    }
  });
};

/**
 * Returns the relevant properties.
 * @this {pcmws.api.StaticService}
 * @returns {Object}
 * @protected
 */
pcmws.api.StaticService.prototype.toServiceOptions = function () {
  var opts = /** @type{pcmws.api.StaticServiceOptions} */({});
  var self = this;
  var keys = Object.keys(/** @type {!Object} */(this.formalParameters));
  keys.forEach(function (optionKey) {
    if (self.formalParameters.hasOwnProperty(optionKey)) {
      if (self[optionKey] !== undefined) {
        var val = self[optionKey];
        opts[optionKey] = val.getValue();
      }
    }
  });
  opts['hostURL'] = this.getServiceURL().hostURL;
  opts['path'] = this.getServiceURL().path;
  return opts;
};

/**
 * This method returns the combined parameter array.
 * @param {Object=} opt_options Possible overriding options.
 * @this {pcmws.api.StaticService}
 * @returns {Array}
 * @protected
 */
pcmws.api.StaticService.prototype.getParamsArray = function(opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  var service = this.clone();
  service.processOptions(options);
  var params = [];
  Object.keys(/** @type {!Object} */(service.formalParameters)).forEach(function (optionKey) {
    if (service.formalParameters.hasOwnProperty(optionKey)) {
      if (service[optionKey] instanceof pcmws.api.Param) {
        params.push(service[optionKey]);
      }
    }
  });
  return params;
};

/**
 * @description
 * This method returns the complete URL for this service. It takes all relevant options used in
 * the construction of this object combined with, possibly overriding any base options with
 * the supplied options.
 *
 * @param {Object=} opt_options The options that will combine with the base options
 *               overriding any options set in the base. See {@link pcmws.api.StaticServiceOptions} for
 *               details;
 * @this {pcmws.api.StaticService}
 * @return {string} A string containing the URL with encoded parameters, which may be further used
 *         against replacement matches, such as 'https://maps.host.com/tile?x={x}&y={y}&z={z}'
 *
 */
pcmws.api.StaticService.prototype.getURL = function (opt_options) {
  var params = this.getParamsArray(opt_options);
  var url = this.getServiceURL();
  return this.constructURL(url.hostURL, url.path, params);
};

/**
 * @description
 * This method returns the complete URL for this service's attribution, which is comprised of the
 * hostURL, the attribution path, and all of the set or default parameters.
 * The attribution may change with different regions, datasets, etc.
 * @param {Object=} opt_options The options that will combine with the base options
 *               overriding any options set in the base. See {@link pcmws.api.StaticServiceOptions} for
 *               details;
 * @this {pcmws.api.StaticService}
 * @return {string} A string containing the Attribution URL with encoded parameters.
 *
 */
pcmws.api.StaticService.prototype.getAttributionURL = function (opt_options) {
  var params = this.getParamsArray(opt_options);
  var url = this.getServiceAttributionURL();
  return this.constructURL(url.hostURL, url.path, params);
};


/**
 * This method is called on a successful query before being handed to
 * the response callback.
 * @param {Object} obj
 * @returns {Object}
 * @protected
 */
pcmws.api.StaticService.prototype.processResponse = function (obj) {
  return obj;
};

/**
 * This method is called on a failed query before being handed to
 * the response callback.
 * @param {Object} obj
 * @returns {Object}
 * @protected
 */
pcmws.api.StaticService.prototype.processErrorResponse = function (obj) {
  return obj;
};

/**
 * @description
 * This method will get an HTTP JSON response from this configured service using the
 * URL that is generated by {@link pcmws.api.StaticService#getURL} any supplied
 * options. Both a success callback and a failure callback may be supplied.
 * There must be a success callback. If there is no error callback, the
 * success callback will be called.
 *
 * @param {(Object|function(Object))=} opts_or_callback The options
 *               that will combine with the base options
 *               overriding any options set in the base, or the response callback.
 * @param {function(Object)=} responseSuccessErrorCallback
 * @param {function(Object)=} responseErrorCallback
 * @this {pcmws.api.StaticService}
 *
 */
pcmws.api.StaticService.prototype.get = function (opts_or_callback, responseSuccessErrorCallback, responseErrorCallback) {
  var self = this;
  var options = {};
  var successCallback;
  var errorCallback;
  if (typeof opts_or_callback === 'function') {
    successCallback = opts_or_callback;
    errorCallback = responseSuccessErrorCallback;
  } else {
    options = opts_or_callback || {};
    successCallback = responseSuccessErrorCallback;
    errorCallback = responseErrorCallback;
  }
  if (errorCallback === undefined) {
    errorCallback = successCallback;
  }
  if (typeof successCallback !== 'function') {
    throw "pcmws.api.StaticService#get: no or illegal response callback specified.";
  }
  var url = this.getURL(options);
  this.xhrGet(url, 'json', null, function (xhr) {
    successCallback(self.processResponse(xhr.response));
  }, function (xhr) {
    errorCallback(self.processErrorResponse(xhr.response));
  });
};

/**
 * This method constructs the URL using the hostURL, path, and the parameters.
 * @param {string} hostURL
 * @param {string} path
 * @param {Array.<pcmws.api.Param>} paramsArray
 * @returns {string}
 * @protected
 */
pcmws.api.StaticService.prototype.constructURL = function (hostURL, path, paramsArray) {
  function not_null(v) {
    return !!v;
  }
  var params = paramsArray.map(function (param) {return param.getURLParam();});
  params = params.filter(not_null);
  var query = params.length > 0 ? '?' + params.join('&') : '';
  return hostURL + path + query;
};

/**
 * @description
 * This method will get an HTTP response from this configured service using the
 * URL that is generated by {@link pcmws.api.StaticService#getAttributionURL}.
 *
 * @param {(Object|function(Object))=} opts_or_callback The options
 *               that will combine with the base options
 *               overriding any options set in the base, or the response callback.
 * @param {function(Object)=} responseSuccessErrorCallback
 * @param {function(Object)=} responseErrorCallback
 * @this {pcmws.api.StaticService}
 *
 */
pcmws.api.StaticService.prototype.getAttribution = function (opts_or_callback, responseSuccessErrorCallback, responseErrorCallback) {
  var options = {};
  var successCallback;
  var errorCallback;
  if (typeof opts_or_callback === 'function') {
    successCallback = opts_or_callback;
    errorCallback = responseSuccessErrorCallback;
  } else {
    options = opts_or_callback || {};
    successCallback = responseSuccessErrorCallback;
    errorCallback = responseErrorCallback;
  }
  if (errorCallback === undefined) {
    errorCallback = successCallback;
  }
  if (typeof successCallback !== 'function') {
    throw "pcmws.api.StaticService#getAttribution: no or illegal response callback specified.";
  }
  var url = this.getAttributionURL(options);
  this.xhrGet(url, 'json', null, function (xhr) {
    successCallback(xhr.response);
  }, function (xhr) {
    errorCallback(xhr.response);
  });
};
goog.provide('pcmws.api.TrafficCameraImageURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Traffic Camera Image service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.TrafficCameraImageURL = function (hosturl, path) {
  pcmws.api.TrafficCameraImageURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.TrafficCameraImageURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the TrafficCameraImage URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.TrafficCameraImageURL.prototype.path;
goog.provide('pcmws.api.TrafficCameraMetadataURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Traffic Camera Image service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.TrafficCameraMetadataURL = function (hosturl, path) {
  pcmws.api.TrafficCameraMetadataURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.TrafficCameraMetadataURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the TrafficCameraMetadata URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.TrafficCameraMetadataURL.prototype.path;
goog.provide('pcmws.api.TrafficCamerasURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler TrafficCamera service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.TrafficCamerasURL = function (hosturl, path) {
  pcmws.api.TrafficCamerasURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.TrafficCamerasURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the TrafficCamera URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.TrafficCamerasURL.prototype.path;
goog.provide('pcmws.api.TrafficIncidentsURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler TrafficIncident service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.TrafficIncidentsURL = function (hosturl, path) {
  pcmws.api.TrafficIncidentsURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.TrafficIncidentsURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the TrafficIncident URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.TrafficIncidentsURL.prototype.path;
goog.provide('pcmws.api.TrafficTileURL');

goog.require('pcmws.api');
goog.require('pcmws.api.ContentServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the ALK Traffic Tile service from the Content Server.
 * Since it extends the {@link pcmws.api.ContentServiceURL} it exists here merely to set a default
 * path for it in the prototype.
 *
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.ContentServiceURL}
 *
 */
pcmws.api.TrafficTileURL = function (hosturl, path) {
  pcmws.api.TrafficTileURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.TrafficTileURL, pcmws.api.ContentServiceURL);

goog.provide('pcmws.api.TrafficURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Traffic service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.TrafficURL = function (hosturl, path) {
  pcmws.api.TrafficURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.TrafficURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Traffic URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.TrafficURL.prototype.path;
goog.provide('pcmws.api.WeatherAlertsURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Weather Alerts service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.WeatherAlertsURL = function (hosturl, path) {
  pcmws.api.WeatherAlertsURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.WeatherAlertsURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the POI URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.WeatherAlertsURL.prototype.path;
goog.provide('pcmws.api.WeatherImageTileURL');

goog.require('pcmws.api');
goog.require('pcmws.api.ContentServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the ALK Content Tile Service for Weather tiles.
 * Since it extends the {@link pcmws.api.ContentServiceURL} it exists here merely to set a default
 * path for it in the prototype.
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.ContentServiceURL}
 *
 */
pcmws.api.WeatherImageTileURL = function (hosturl, path) {
  pcmws.api.WeatherImageTileURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.WeatherImageTileURL, pcmws.api.ContentServiceURL);
goog.provide('pcmws.api.WeatherURL');

goog.require('pcmws.api');
goog.require('pcmws.api.StaticServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the PCMiler Weather service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.StaticServiceURL}
 *
 */
pcmws.api.WeatherURL = function (hosturl, path) {
  pcmws.api.WeatherURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.WeatherURL, pcmws.api.StaticServiceURL);

/**
 * @description
 * The default path for the Weather URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.WeatherURL.prototype.path;
goog.provide('alk.defaults');

goog.require('alk');
goog.require('alk.img.Hazmat');
goog.require('alk.img.HazmatName');
goog.require('alk.img.Misc');
goog.require('alk.img.MiscName');
goog.require('alk.img.POI');
goog.require('alk.img.POIName');
goog.require('alk.img.Traffic');
goog.require('alk.img.TrafficName');
goog.require('alk.img.TruckRestr');
goog.require('alk.img.TruckRestrName');

goog.require('alkx.DefaultOptions');

goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.ContentServiceURL');
goog.require('pcmws.api.CountriesSingleSearchURL');
goog.require('pcmws.api.CustomCategoriesRestServiceURL');
goog.require('pcmws.api.CustomPlaceSetsRestServiceURL');
goog.require('pcmws.api.CustomPlacesRestServiceURL');
goog.require('pcmws.api.DriveTimePolygonURL');
goog.require('pcmws.api.LocationsReverseURL');
goog.require('pcmws.api.LocationsURL');
goog.require('pcmws.api.MapTileURL');
goog.require('pcmws.api.MapURL');
goog.require('pcmws.api.NATrafficTileURL');
goog.require('pcmws.api.PCMServiceURL');
goog.require('pcmws.api.POICategoriesSingleSearchURL');
goog.require('pcmws.api.POIURL');
goog.require('pcmws.api.PolygonsCountyURL');
goog.require('pcmws.api.RestServiceURL');
goog.require('pcmws.api.RoadSurfaceRouteURL');
goog.require('pcmws.api.RoadSurfaceTileURL');
goog.require('pcmws.api.RouteReportsURL');
goog.require('pcmws.api.RouteURL');
goog.require('pcmws.api.SatelliteTileURL');
goog.require('pcmws.api.SearchSingleSearchURL');
goog.require('pcmws.api.SearchTypesSingleSearchURL');
goog.require('pcmws.api.SingleSearchServiceURL');
goog.require('pcmws.api.StatesSingleSearchURL');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.StaticServiceURL');
goog.require('pcmws.api.TrafficCameraImageURL');
goog.require('pcmws.api.TrafficCameraMetadataURL');
goog.require('pcmws.api.TrafficCamerasURL');
goog.require('pcmws.api.TrafficIncidentsURL');
goog.require('pcmws.api.TrafficTileURL');
goog.require('pcmws.api.TrafficURL');
goog.require('pcmws.api.WeatherAlertsURL');
goog.require('pcmws.api.WeatherImageTileURL');
goog.require('pcmws.api.WeatherURL');

alk.defaults = {};

/**
 * This method sets the ALK API Key as the default for all ALK PCM and Content Services.
 * @param {string} key
 * @api
 */
alk.defaults.setApiKey = function (key) {
  pcmws.api.StaticService.prototype.authToken = new pcmws.api.AuthToken(key);
};

/**
 * This method sets the defaults for all accessing all production ALK PCM and Content Services.
 * @param {alkx.DefaultOptions=} opt_options Options
 * @api
 */
alk.defaults.setProductionDefaults = function (opt_options) {
  opt_options = opt_options || {};
  var https = opt_options.https === false ? false : true;
  var httpProtocol = https ? 'https' : 'http';

  pcmws.api.StaticServiceURL.prototype.hostURL = httpProtocol + '://pcmiler.alk.com';
  /** @override */
  pcmws.api.ContentServiceURL.prototype.hostURL = httpProtocol + '://contentsvc.alk.com';
  /** @override */
  pcmws.api.SingleSearchServiceURL.prototype.hostURL = httpProtocol + '://singlesearch-aws-qa.alk.com';
  pcmws.api.RestServiceURL.prototype.hostURL = httpProtocol + '://pcmiler.alk.com';

  /** @override */
  pcmws.api.MapURL.prototype.path = '/apis/rest/v1.0/Service.svc/map';
  /** @override */
  pcmws.api.TrafficURL.prototype.path = '/apis/rest/v1.0/Service.svc/traffic';
  /** @override */
  pcmws.api.WeatherURL.prototype.path = '/apis/rest/v1.0/Service.svc/weather';
  /** @override */
  pcmws.api.MapTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/maptile';
  /** @override */
  pcmws.api.RouteURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/routePath';
  /** @override */
  pcmws.api.RouteReportsURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/routeReports';
  /** @override */
  pcmws.api.DriveTimePolygonURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/driveTimePolygon';
  /** @override */
  pcmws.api.POIURL.prototype.path = '/apis/rest/v1.0/Service.svc/poi';
  /** @override */
  pcmws.api.WeatherAlertsURL.prototype.path = '/apis/rest/v1.0/Service.svc/WeatherAlerts';
  /** @override */
  pcmws.api.TrafficIncidentsURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficIncidents/box';
  /** @override */
  pcmws.api.TrafficCamerasURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCams/box';
  /** @override */
  pcmws.api.TrafficCameraImageURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCam/img';
  /** @override */
  pcmws.api.TrafficCameraMetadataURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCam/metadata';
  /** @override */
  pcmws.api.NATrafficTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/traffictile';
  /** @override */
  pcmws.api.PolygonsCountyURL.prototype.path = '/apis/rest/v1.0/Service.svc/polygons/county';
  /** @override */
  pcmws.api.LocationsURL.prototype.path = '/apis/rest/v1.0/Service.svc/locations';
  /** @override */
  pcmws.api.LocationsReverseURL.prototype.path = '/apis/rest/v1.0/Service.svc/locations/reverse';
  /** @override */
  pcmws.api.RoadSurfaceTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/roadSurface/tile';
  /** @override */
  pcmws.api.RoadSurfaceRouteURL.prototype.path = '/apis/rest/v1.0/Service.svc/roadSurface/route';

  /** @override */
  pcmws.api.CustomCategoriesRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customCategories';
  /** @override */
  pcmws.api.CustomPlaceSetsRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets';
  /** @override */
  pcmws.api.CustomPlacesRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets/{setId}/customPlace';

  /** @override */
  pcmws.api.TrafficTileURL.prototype.path = '/contentservice.svc/xml/traffic/tile';
  /** @override */
  pcmws.api.WeatherImageTileURL.prototype.path = '/contentservice.svc/xml/weatherimagetile';
  /** @override */
  pcmws.api.SatelliteTileURL.prototype.path = '/ContentService.svc/xml/SatImageTile';

  /** @override */
  pcmws.api.CountriesSingleSearchURL.prototype.path = '/{region}/api/search/countries';
  /** @override */
  pcmws.api.StatesSingleSearchURL.prototype.path = '/{region}/api/search/states';
  /** @override */
  pcmws.api.SearchTypesSingleSearchURL.prototype.path = '/{region}/api/search/types';
  /** @override */
  pcmws.api.POICategoriesSingleSearchURL.prototype.path = '/{region}/api/search/poiCategories';
  /** @override */
  pcmws.api.SearchSingleSearchURL.prototype.path = '/{region}/api/search';

  // For now, our images are coming from the build/hosted/Content/Images.
  var hostURL = opt_options.imageHostURL || '../../../../../..';

  alk.setURL(alk.img.Hazmat, hostURL + '/Content/Images/', alk.img.HazmatName, '.png');
  alk.setURL(alk.img.Misc, hostURL + '/Content/Images/', alk.img.MiscName, '.png');
  alk.setURL(alk.img.POI, hostURL + '/Content/Images/icons/cat_poi_', alk.img.POIName, '_2d.png');
  alk.setURL(alk.img.Traffic, hostURL + '/Content/Images/icons/cat_traffic_', alk.img.TrafficName, '_2d.png');
  alk.setURL(alk.img.TruckRestr, hostURL + '/Content/Images/cat_truck_restr_', alk.img.TruckRestrName, '_2d.png');
};


/**
 * This method sets the defaults for all accessing all development ALK PCM and Content Services.
 * @param {alkx.DefaultOptions=} opt_options Options
 * @api
 */
alk.defaults.setDevelopmentDefaults = function (opt_options) {
  opt_options = opt_options || {};
  var https = opt_options.https === false ? false : true;
  var httpProtocol = https ? 'https' : 'http';
  pcmws.api.StaticServiceURL.prototype.hostURL = httpProtocol + '://dev.pcmiler.alk.com';
  pcmws.api.RestServiceURL.prototype.hostURL = httpProtocol + '://dev.pcmiler.alk.com';

  /** @override */
  pcmws.api.ContentServiceURL.prototype.hostURL = httpProtocol + '://contentsvc.dev.alk.com';
  /** @override */
  pcmws.api.SingleSearchServiceURL.prototype.hostURL = httpProtocol + '://singlesearch-aws-qa.alk.com';

  /** @override */
  pcmws.api.MapTileURL.prototype.hostURL = httpProtocol + '://dev.pcmiler-{a-d}.alk.com';
  /** @override */
  pcmws.api.NATrafficTileURL.prototype.hostURL = httpProtocol + '://dev.pcmiler-{a-d}.alk.com';

  /** @override */
  pcmws.api.MapURL.prototype.path = '/apis/rest/v1.0/Service.svc/map';
  /** @override */
  pcmws.api.TrafficURL.prototype.path = '/apis/rest/v1.0/Service.svc/traffic';
  /** @override */
  pcmws.api.WeatherURL.prototype.path = '/apis/rest/v1.0/Service.svc/weather';
  /** @override */
  pcmws.api.MapTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/maptile';
  /** @override */
  pcmws.api.RouteURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/routePath';
  /** @override */
  pcmws.api.RouteReportsURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/routeReports';
  /** @override */
  pcmws.api.DriveTimePolygonURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/driveTimePolygon';
  /** @override */
  pcmws.api.POIURL.prototype.path = '/apis/rest/v1.0/Service.svc/poi';
  /** @override */
  pcmws.api.WeatherAlertsURL.prototype.path = '/apis/rest/v1.0/Service.svc/WeatherAlerts';
  /** @override */
  pcmws.api.TrafficIncidentsURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficIncidents/box';
  /** @override */
  pcmws.api.TrafficCamerasURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCams/box';
  /** @override */
  pcmws.api.TrafficCameraImageURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCam/img';
  /** @override */
  pcmws.api.TrafficCameraMetadataURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCam/metadata';
  /** @override */
  pcmws.api.NATrafficTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/traffictile';
  /** @override */
  pcmws.api.PolygonsCountyURL.prototype.path = '/apis/rest/v1.0/Service.svc/polygons/county';
  /** @override */
  pcmws.api.LocationsURL.prototype.path = '/apis/rest/v1.0/Service.svc/locations';
  /** @override */
  pcmws.api.LocationsReverseURL.prototype.path = '/apis/rest/v1.0/Service.svc/locations/reverse';
  /** @override */
  pcmws.api.RoadSurfaceTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/roadSurface/tile';
  /** @override */
  pcmws.api.RoadSurfaceRouteURL.prototype.path = '/apis/rest/v1.0/Service.svc/roadSurface/route';

  /** @override */
  pcmws.api.CustomCategoriesRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customCategories';
  /** @override */
  pcmws.api.CustomPlaceSetsRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets';
  /** @override */
  pcmws.api.CustomPlacesRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets/{setId}/customPlace';

  /** @override */
  pcmws.api.TrafficTileURL.prototype.path = '/contentservice.svc/xml/traffic/tile';
  /** @override */
  pcmws.api.WeatherImageTileURL.prototype.path = '/contentservice.svc/xml/weatherimagetile';
  /** @override */
  pcmws.api.SatelliteTileURL.prototype.path = '/ContentService.svc/xml/SatImageTile';

  /** @override */
  pcmws.api.CountriesSingleSearchURL.prototype.path = '/{region}/api/search/countries';
  /** @override */
  pcmws.api.StatesSingleSearchURL.prototype.path = '/{region}/api/search/states';
  /** @override */
  pcmws.api.SearchTypesSingleSearchURL.prototype.path = '/{region}/api/search/types';
  /** @override */
  pcmws.api.POICategoriesSingleSearchURL.prototype.path = '/{region}/api/search/poiCategories';
  /** @override */
  pcmws.api.SearchSingleSearchURL.prototype.path = '/{region}/api/search';

  // For now, our images are coming from the build/hosted/Content/Images.
  var hostURL = opt_options.imageHostURL || '../../../../../..';


  alk.setURL(alk.img.Hazmat, hostURL + '/Content/Images/', alk.img.HazmatName, '.png');
  alk.setURL(alk.img.Misc, hostURL + '/Content/Images/', alk.img.MiscName, '.png');
  alk.setURL(alk.img.POI, hostURL + '/Content/Images/icons/cat_poi_', alk.img.POIName, '_2d.png');
  alk.setURL(alk.img.Traffic, hostURL + '/Content/Images/icons/cat_traffic_', alk.img.TrafficName, '_2d.png');
  alk.setURL(alk.img.TruckRestr, hostURL + '/Content/Images/cat_truck_restr_', alk.img.TruckRestrName, '_2d.png');
};


/**
 * This method sets the defaults for all accessing all quality assurance ALK PCM and Content Services.
 * @param {alkx.DefaultOptions=} opt_options Options
 * @api
 */
alk.defaults.setQADefaults = function (opt_options) {
  opt_options = opt_options || {};
  var https = opt_options.https === false ? false : true;
  var httpProtocol = https ? 'https' : 'http';

  pcmws.api.StaticServiceURL.prototype.hostURL = httpProtocol + '://pcmiler-aws-qa.alk.com';
  pcmws.api.RestServiceURL.prototype.hostURL = httpProtocol + '://pcmiler-aws-qa.alk.com';

  /** @override */
  pcmws.api.ContentServiceURL.prototype.hostURL = httpProtocol + '://aws.contentsvc.qa.alk.com';
  /** @override */
  pcmws.api.SingleSearchServiceURL.prototype.hostURL = httpProtocol + '://singlesearch-aws-qa.alk.com';

  /** @override */
  pcmws.api.MapTileURL.prototype.hostURL = httpProtocol + '://pcmiler-aws-qa-{a-d}.alk.com';
  /** @override */
  pcmws.api.NATrafficTileURL.prototype.hostURL = httpProtocol + '://pcmiler-aws-qa-{a-d}.alk.com';

  /** @override */
  pcmws.api.MapURL.prototype.path = '/apis/rest/v1.0/Service.svc/map';
  /** @override */
  pcmws.api.TrafficURL.prototype.path = '/apis/rest/v1.0/Service.svc/traffic';
  /** @override */
  pcmws.api.WeatherURL.prototype.path = '/apis/rest/v1.0/Service.svc/weather';
  /** @override */
  pcmws.api.MapTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/maptile';
  /** @override */
  pcmws.api.RouteURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/routePath';
  /** @override */
  pcmws.api.RouteReportsURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/routeReports';
  /** @override */
  pcmws.api.DriveTimePolygonURL.prototype.path = '/apis/rest/v1.0/Service.svc/route/driveTimePolygon';
  /** @override */
  pcmws.api.POIURL.prototype.path = '/apis/rest/v1.0/Service.svc/poi';
  /** @override */
  pcmws.api.WeatherAlertsURL.prototype.path = '/apis/rest/v1.0/Service.svc/WeatherAlerts';
  /** @override */
  pcmws.api.TrafficIncidentsURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficIncidents/box';
  /** @override */
  pcmws.api.TrafficCamerasURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCams/box';
  /** @override */
  pcmws.api.TrafficCameraImageURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCam/img';
  /** @override */
  pcmws.api.TrafficCameraMetadataURL.prototype.path = '/apis/rest/v1.0/Service.svc/trafficCam/metadata';
  /** @override */
  pcmws.api.NATrafficTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/traffictile';
  /** @override */
  pcmws.api.PolygonsCountyURL.prototype.path = '/apis/rest/v1.0/Service.svc/polygons/county';
  /** @override */
  pcmws.api.LocationsURL.prototype.path = '/apis/rest/v1.0/Service.svc/locations';
  /** @override */
  pcmws.api.LocationsReverseURL.prototype.path = '/apis/rest/v1.0/Service.svc/locations/reverse';
  /** @override */
  pcmws.api.RoadSurfaceTileURL.prototype.path = '/apis/rest/v1.0/Service.svc/roadSurface/tile';
  /** @override */
  pcmws.api.RoadSurfaceRouteURL.prototype.path = '/apis/rest/v1.0/Service.svc/roadSurface/route';

  /** @override */
  pcmws.api.CustomCategoriesRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customCategories';
  /** @override */
  pcmws.api.CustomPlaceSetsRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets';
  /** @override */
  pcmws.api.CustomPlacesRestServiceURL.prototype.path = '/apis/rest/v1.0/service.svc/{XDR}customPlaceSets/{setId}/customPlace';

  /** @override */
  pcmws.api.TrafficTileURL.prototype.path = '/contentservice.svc/xml/traffic/tile';
  /** @override */
  pcmws.api.WeatherImageTileURL.prototype.path = '/contentservice.svc/xml/weatherimagetile';
  /** @override */
  pcmws.api.SatelliteTileURL.prototype.path = '/ContentService.svc/xml/SatImageTile';

  /** @override */
  pcmws.api.CountriesSingleSearchURL.prototype.path = '/{region}/api/search/countries';
  /** @override */
  pcmws.api.StatesSingleSearchURL.prototype.path = '/{region}/api/search/states';
  /** @override */
  pcmws.api.SearchTypesSingleSearchURL.prototype.path = '/{region}/api/search/types';
  /** @override */
  pcmws.api.POICategoriesSingleSearchURL.prototype.path = '/{region}/api/search/poiCategories';
  /** @override */
  pcmws.api.SearchSingleSearchURL.prototype.path = '/{region}/api/search';

  // For now, our images are coming from the build/hosted/Content/Images.
  var hostURL = opt_options.imageHostURL || '../../../../../..';


  alk.setURL(alk.img.Hazmat, hostURL + '/Content/Images/', alk.img.HazmatName, '.png');
  alk.setURL(alk.img.Misc, hostURL + '/Content/Images/', alk.img.MiscName, '.png');
  alk.setURL(alk.img.POI, hostURL + '/Content/Images/icons/cat_poi_', alk.img.POIName, '_2d.png');
  alk.setURL(alk.img.Traffic, hostURL + '/Content/Images/icons/cat_traffic_', alk.img.TrafficName, '_2d.png');
  alk.setURL(alk.img.TruckRestr, hostURL + '/Content/Images/cat_truck_restr_', alk.img.TruckRestrName, '_2d.png');
};

/**
 * This method sets the defaults for all accessing all ALK PCM and Content Services on a
 * configured hermetic server installation.
 * @param {string} hostURL  The URL starting with 'http://'. Example "http://pri-person.alk.com:94"
 *                          Note, avoid using "http://localhost:94" as you will only be able to
 *                          access servers on your machine. Nobody else can run them from
 *                          their machine.
 * @param {string=} imageHostURL The URL for the images.
 * @api
 */
alk.defaults.setHermeticDefaults = function (hostURL, imageHostURL) {
  pcmws.api.StaticServiceURL.prototype.hostURL = hostURL;
  pcmws.api.RestServiceURL.prototype.hostURL = hostURL;

  /** @override */
  pcmws.api.ContentServiceURL.prototype.hostURL = hostURL;
  /** @override */
  pcmws.api.SingleSearchServiceURL.prototype.hostURL = 'http://singlesearch-aws-qa.alk.com';

  // we will not have {a-d} urls for HermeticDefaults
  /** @override */
  pcmws.api.MapTileURL.prototype.hostURL = hostURL;
  /** @override */
  pcmws.api.NATrafficTileURL.prototype.hostURL = hostURL;

  /** @override */
  pcmws.api.MapURL.prototype.path = '/pcm-portal/Service.svc/map';
  /** @override */
  pcmws.api.TrafficURL.prototype.path = '/pcm-portal/Service.svc/traffic';
  /** @override */
  pcmws.api.WeatherURL.prototype.path = '/pcm-portal/Service.svc/weather';
  /** @override */
  pcmws.api.MapTileURL.prototype.path = '/pcm-portal/Service.svc/maptile';
  /** @override */
  pcmws.api.RouteURL.prototype.path = '/pcm-portal/Service.svc/route/routePath';
  /** @override */
  pcmws.api.RouteReportsURL.prototype.path = '/pcm-portal/Service.svc/route/routeReports';
  /** @override */
  pcmws.api.DriveTimePolygonURL.prototype.path = '/pcm-portal/Service.svc/route/driveTimePolygon';
  /** @override */
  pcmws.api.POIURL.prototype.path = '/pcm-portal/Service.svc/poi';
  /** @override */
  pcmws.api.WeatherAlertsURL.prototype.path = '/pcm-portal/Service.svc/WeatherAlerts';
  /** @override */
  pcmws.api.TrafficIncidentsURL.prototype.path = '/pcm-portal/Service.svc/trafficIncidents/box';
  /** @override */
  pcmws.api.TrafficCamerasURL.prototype.path = '/pcm-portal/Service.svc/trafficCams/box';
  /** @override */
  pcmws.api.TrafficCameraImageURL.prototype.path = '/pcm-portal/Service.svc/trafficCam/img';
  /** @override */
  pcmws.api.TrafficCameraMetadataURL.prototype.path = '/pcm-portal/Service.svc/trafficCam/metadata';
  /** @override */
  pcmws.api.NATrafficTileURL.prototype.path = '/pcm-portal/Service.svc/traffictile';
  /** @override */
  pcmws.api.PolygonsCountyURL.prototype.path = '/pcm-portal/Service.svc/polygons/county';
  /** @override */
  pcmws.api.LocationsURL.prototype.path = '/pcm-portal/Service.svc/locations';
  /** @override */
  pcmws.api.LocationsReverseURL.prototype.path = '/pcm-portal/Service.svc/locations/reverse';
  /** @override */
  pcmws.api.RoadSurfaceTileURL.prototype.path = '/pcm-portal/Service.svc/roadSurface/tile';
  /** @override */
  pcmws.api.RoadSurfaceRouteURL.prototype.path = '/pcm-portal/Service.svc/roadSurface/route';

  /** @override */
  pcmws.api.CustomCategoriesRestServiceURL.prototype.path = '/pcm-portal/Service.svc/{XDR}customCategories';
  /** @override */
  pcmws.api.CustomPlaceSetsRestServiceURL.prototype.path = '/pcm-portal/Service.svc/{XDR}customPlaceSets';
  /** @override */
  pcmws.api.CustomPlacesRestServiceURL.prototype.path = '/pcm-portal/Service.svc/{XDR}customPlaceSets/{setId}/customPlace';

  /** @override */
  pcmws.api.TrafficTileURL.prototype.path = '/copilot-contentsrv/ContentService.svc/traffic/tile';
  /** @override */
  pcmws.api.WeatherImageTileURL.prototype.path = '/copilot-contentsrv/ContentService.svc/weatherimagetile';
  /** @override */
  pcmws.api.SatelliteTileURL.prototype.path = '/copilot-contentsrv/ContentService.svc/xml/SatImageTile';

  /** @override */
  pcmws.api.CountriesSingleSearchURL.prototype.path = '/{region}/api/search/countries';
  /** @override */
  pcmws.api.StatesSingleSearchURL.prototype.path = '/{region}/api/search/states';
  /** @override */
  pcmws.api.SearchTypesSingleSearchURL.prototype.path = '/{region}/api/search/types';
  /** @override */
  pcmws.api.POICategoriesSingleSearchURL.prototype.path = '/{region}/api/search/poiCategories';
  /** @override */
  pcmws.api.SearchSingleSearchURL.prototype.path = '/{region}/api/search';

  // For now, our images are coming from the build/hosted/Content/Images.
  hostURL = imageHostURL || '../../../../../..';

  alk.setURL(alk.img.Hazmat, hostURL + '/Content/Images/', alk.img.HazmatName, '.png');
  alk.setURL(alk.img.Misc, hostURL + '/Content/Images/', alk.img.MiscName, '.png');
  alk.setURL(alk.img.POI, hostURL + '/Content/Images/icons/cat_poi_', alk.img.POIName, '_2d.png');
  alk.setURL(alk.img.Traffic, hostURL + '/Content/Images/icons/cat_traffic_', alk.img.TrafficName, '_2d.png');
  alk.setURL(alk.img.TruckRestr, hostURL + '/Content/Images/cat_truck_restr_', alk.img.TruckRestrName, '_2d.png');
};

/**
 * @api
 * @returns {*}
 */
alk.defaults.getMapTileUrl = function () {
  return pcmws.api.MapTileURL;
};


/**
 * @api
 * @returns {*}
 */
alk.defaults.getPCMServiceUrl = function () {
  return pcmws.api.PCMServiceURL;
};


/**
 * @api
 * @returns {*}
 */
alk.defaults.getStaticServiceUrl = function () {
  return pcmws.api.PCMServiceURL;
};


/**
 * @api
 * @returns {*}
 */
alk.defaults.getNewMapTileUrl = function () {
  return new pcmws.api.MapTileURL();
};


/**
 * @api
 * @returns {*}
 */
alk.defaults.getNewPCMServiceUrl = function () {
  return new pcmws.api.PCMServiceURL();
};


/**
 * @api
 * @returns {*}
 */
alk.defaults.getNewStaticServiceUrl = function () {
  return new pcmws.api.PCMServiceURL();
};
goog.provide('alk.format');

goog.require('alk');

alk.format = {};

/**
 * TODO: Check and replace
 * This is defined wrongly in OpenLayers 4.6.4
 * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options
 *     Options.
 * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.
 */
alk.format.Feature_transformWithOptions = function(
  geometry, write, opt_options) {
  var featureProjection = opt_options ?
    ol.proj.get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ?
    ol.proj.get(opt_options.dataProjection) : null;
  /**
   * @type {ol.geom.Geometry|ol.Extent}
   */
  var transformed;
  if (featureProjection && dataProjection &&
    !ol.proj.equivalent(featureProjection, dataProjection)) {
    if (geometry instanceof ol.geom.Geometry) {
      transformed = (write ? geometry.clone() : geometry).transform(
        write ? featureProjection : dataProjection,
        write ? dataProjection : featureProjection);
    } else {
      // FIXME this is necessary because ol.format.GML treats extents
      // as geometries
      transformed = ol.proj.transformExtent(
        geometry,
        dataProjection,
        featureProjection);
    }
  } else {
    transformed = geometry;
  }
  if (write && opt_options && opt_options.decimals !== undefined) {
    var power = Math.pow(10, opt_options.decimals);
    // if decimals option on write, round each coordinate appropriately
    /**
     * @param {Array.<number>} coordinates Coordinates.
     * @return {Array.<number>} Transformed coordinates.
     */
    var transform = function(coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power) / power;
      }
      return coordinates;
    };
    if (transformed === geometry) {
      transformed = transformed.clone();
    }
    transformed.applyTransform(transform);
  }
  return transformed;
};
goog.provide('alk.format.FormatType');


/**
 * @enum {string}
 * @api
 */
alk.format.FormatType = {
  /** @api */
  ARRAY_BUFFER: 'arraybuffer',
  /** @api */
  JSON: 'json',
  /** @api */
  TEXT: 'text',
  /** @api */
  XML: 'xml'
};
goog.provide('alk.format.HashedIdFactory');

goog.require('alk.format');

goog.require('alkx.HashedIdFactoryOptions');

/**
 * @classdesc
 * An instance of this class generates hashed identifiers based on given
 * strings using {@link alk.format.HashedIdFactory#getIdForString}.
 * @description
 * This constructor creates an object used in OpenLayers format readers.
 *
 * This class has a collision check apparatus that may be turned on, but this
 * base class does not provide a fix for a collision.
 * Override {@link alk.format.HashedIdFactory#hashCollisionFix}
 * to perform a suitable fix.
 *
 * @param {alkx.HashedIdFactoryOptions=} opt_options
 * @constructor
 * @api
 */
alk.format.HashedIdFactory = function (opt_options) {
  /** @type {alkx.HashedIdFactoryOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.performCollisionCheck_ = !!options.checkForCollisions;
  this.performCollisionLog_ = !!options.logCollisions;

  this.collisionMap_ = {};
};

/**
 * Boolean switch to induce collision checking.
 * @type {boolean}
 * @private
 */
alk.format.HashedIdFactory.prototype.performCollisionCheck_;

/**
 * Boolean switch to induce collision logging.
 * @type {boolean}
 * @private
 */
alk.format.HashedIdFactory.prototype.performCollisionLog_;

/**
 * Map for determining hash collisions.
 * @type {Object}
 * @private
 */
alk.format.HashedIdFactory.prototype.collisionMap_;

/**
 * This method is called when options.checkForCollisions and options.logCollisions is true, and
 * when a collision occurs during a call to {@link alk.format.HashedIdFactory#getIdForString}
 * to log the collision using console.log.
 *
 * @param {number|string} hash
 * @param {string} str1 The string generating the hash.
 * @param {string} str2 The previous string that generated the same hash.
 * @protected
 */
alk.format.HashedIdFactory.prototype.logCollision = function (hash, str1, str2) {
  console.log("Hash Collision: " + hash);
  console.log(str1);
  console.log(str2);
};

/**
 * This provides a hash function to try to associate with the
 * string. Collisions may occur.
 *
 * @param {string} str
 * @returns {number}
 * @private
 */
alk.format.HashedIdFactory.prototype.hashFnv32a_ = function(str) {
  var hval = 0x822c9dc5;
  for(var i = 0, l = str.length; i < l; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return hval >>> 0;
};

/**
 * This function returns a hashed Id for the given string.
 *
 * This implementation uses the Fnv32a algorithm.
 *
 * @param {string} str
 * @returns {number|string|undefined}
 * @protected
 * @this {alk.format.HashedIdFactory}
 */
alk.format.HashedIdFactory.prototype.getHashId = function (str) {
  return this.hashFnv32a_(str);
};

/**
 * This function returns true if the hash collides with one already
 * hashed out by this format object.
 *
 * @param {number|string} hash
 * @param {string} str
 * @returns {boolean}
 * @this {alk.format.HashedIdFactory}
 * @protected
 */
alk.format.HashedIdFactory.prototype.hasHashCollision = function (hash, str) {
  if (hash in this.collisionMap_) {
    var str2 = this.collisionMap_[hash];
    if (str !== str2) {
      this.logCollision(hash, str, str2);
      return true;
    }
  } else {
    this.collisionMap_[hash] = str;
  }
  return false;
};

/**
 * This function is called when hasHashCollision returns true.
 *
 * This implementation does not fix anything and just returns the given hash.
 * Override, if a fix is needed.
 *
 * @param {number|string} hash
 * @param {string} str
 * @returns {number|string}
 * @api
 */
alk.format.HashedIdFactory.prototype.hashCollisionFix = function (hash, str) {
  return hash;
};

/**
 * This function generates a hashed Id for this particular string.
 *
 * This implementation calls out to getHashId. If there is a collision,
 * then the hash from hashCollisionFix is returned.
 *
 * @param {string} str
 * @returns {number|string|undefined}
 * @this {alk.format.HashedIdFactory}
 * @api
 */
alk.format.HashedIdFactory.prototype.getIdForString = function (str) {
  var hash = this.getHashId(str);
  if (hash) {
    if (this.performCollisionCheck_) {
      var limit = 3;
      while (limit > 0 && this.hasHashCollision(hash, str)) {
        hash = this.hashCollisionFix(hash, str);
        limit -= 1;
      }
      if (limit > 0) {
        return hash;
      } else {
        throw "alk.format.HashedIdFactory: Limit on collisions reached for '" + str + "'";
      }
    }
  }
  return hash;
};


goog.provide('alk.format.JSONFeature');

goog.require('alk.format');
goog.require('alk.format.FormatType');


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 * @description
 * This constructor is used as a base constructor for various JSON features
 * that are read from data sources as part of the OpenLayers format scheme.
 *
 * @constructor
 * @abstract
 * @extends {ol.format.Feature}
 * @api
 */
alk.format.JSONFeature = function() {
  alk.format.JSONFeature.base(this, 'constructor');
};
goog.inherits(alk.format.JSONFeature, ol.format.Feature);


/**
 * @param {Document|Node|Object|string} source Source.
 * @private
 * @return {Object} Object.
 */
alk.format.JSONFeature.prototype.getObject_ = function(source) {
  if (typeof source === 'string') {
    var object = JSON.parse(source);
    return object ? /** @type {Object} */ (object) : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
};


/**
 * @inheritDoc
 */
alk.format.JSONFeature.prototype.getType = function() {
  return alk.format.FormatType.JSON;
};


/**
 * @param {Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 * @override
 * @this {alk.format.JSONFeature}
 */
alk.format.JSONFeature.prototype.readFeature = function(source, opt_options) {
  return this.readFeatureFromObject(
      this.getObject_(source), this.getReadOptions(source, opt_options));
};


/**
 * @param {Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 * @override
 * @this {alk.format.JSONFeature}
 */
alk.format.JSONFeature.prototype.readFeatures = function(source, opt_options) {
  return this.readFeaturesFromObject(
      this.getObject_(source), this.getReadOptions(source, opt_options));
};


/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.Feature} Feature.
 */
alk.format.JSONFeature.prototype.readFeatureFromObject = function(object, opt_options) {};


/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {Array.<ol.Feature>} Features.
 */
alk.format.JSONFeature.prototype.readFeaturesFromObject = function(object, opt_options) {};


/**
 * @param {Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Features.
 * @override
 * @this {alk.format.JSONFeature}
 */
alk.format.JSONFeature.prototype.readGeometry = function(source, opt_options) {
  return this.readGeometryFromObject(
      this.getObject_(source), this.getReadOptions(source, opt_options));
};


/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.geom.Geometry} Geometry.
 */
alk.format.JSONFeature.prototype.readGeometryFromObject = function(object, opt_options) {};


/**
 * @inheritDoc
 * @this {alk.format.JSONFeature}
 */
alk.format.JSONFeature.prototype.readProjection = function(source) {
  return this.readProjectionFromObject(this.getObject_(source));
};


/**
 * @abstract
 * @param {Object} object Object.
 * @protected
 * @return {ol.proj.Projection} Projection.
 */
alk.format.JSONFeature.prototype.readProjectionFromObject = function(object) {};


/**
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Features.
 * @override
 * @this {alk.format.JSONFeature}
 */
alk.format.JSONFeature.prototype.writeFeature = function(feature, opt_options) {
  return JSON.stringify(this.writeFeatureObject(feature, opt_options));
};


/**
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
alk.format.JSONFeature.prototype.writeFeatureObject = function(feature, opt_options) {};


/**
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Features.
 * @override
 * @this {alk.format.JSONFeature}
 */
alk.format.JSONFeature.prototype.writeFeatures = function(features, opt_options) {
  return JSON.stringify(this.writeFeaturesObject(features, opt_options));
};


/**
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
alk.format.JSONFeature.prototype.writeFeaturesObject = function(features, opt_options) {};


/**
 * @param {ol.geom.Geometry} geometry
 * @param {olx.format.WriteOptions=} opt_options
 * @return {string}
 * @override
 * @this {alk.format.JSONFeature}
 */
alk.format.JSONFeature.prototype.writeGeometry = function(geometry, opt_options) {
  return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
};


/**
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
alk.format.JSONFeature.prototype.writeGeometryObject = function(geometry, opt_options) {};
goog.provide('pcmws.val');

goog.require('pcmws');

pcmws.val = {};

/**
 * @param {number|string|undefined} value
 * @param {Object.<string,number>} enumType
 * @param {number=} base
 * @param {number=} def The default if no match.
 * @return {number|undefined}
 */
pcmws.val.toEnumNumber = function (value, enumType, base, def) {
  if (typeof value === 'number') {
    return value;
  }
  if (value !== undefined) {
    return enumType[value] || def;
  }
  return def;
};
goog.provide('pcmws.val.DistanceUnits');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the DistanceUnits parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.DistanceUnits = {
  /**  */
  Miles: 'Miles',
  /**  */
  Kilometers: 'Kilometers'
};
goog.provide('pcmws.api.DistanceUnits');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.DistanceUnits');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'DistUnits' parameter in a PCM service.
 *
 * This parameter specifies whether the units that measure distance are in miles or kilometers.
 * @param {pcmws.val.DistanceUnits|number|string=} value The DistanceUnits value for this parameter.
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.DistanceUnits = function (value) {
  pcmws.api.DistanceUnits.base(this, 'constructor', 'distUnits', value);
};
goog.inherits(pcmws.api.DistanceUnits, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.DistanceUnits}
 */
pcmws.api.DistanceUnits.prototype.check = function (value) {
  return this.checkDistanceUnits(value);
};

/**
 * @description
 * TODO: The number values need to be checked for DistanceUnits.
 * This function checks the validity of the DistanceUnits parameter against its known possible values.
 * @param {*}  value The value to be checked against
 * @returns {pcmws.val.DistanceUnits|string|undefined}
 * @this {pcmws.api.DistanceUnits}
 */
pcmws.api.DistanceUnits.prototype.checkDistanceUnits = function (value) {

  if (this.checkValue(value, pcmws.val.DistanceUnits.Miles, 0)) {
    return pcmws.val.DistanceUnits.Miles;
  }
  else if (this.checkValue(value, pcmws.val.DistanceUnits.Kilometers, 1)) {
    return pcmws.val.DistanceUnits.Kilometers;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal DistanceUnits parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.val.Region');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive Region parameters.
 *
 * @enum {string}
 * 
 */
pcmws.val.Region = {

  /**
   * @description
   * This value designates Africa.
   * 
   */
  AF: 'AF',

  /**
   * @description
   * This value designates Asia
   * 
   */
  AS: 'AS',

  /**
   * @description
   * This value designates Europe.
   * 
   */
  EU: 'EU',

  /**
   * @description
   * This value designates North America.
   * 
   */
  NA: 'NA',

  /**
   * @description
   * This value designates Other Countries.
   * 
   */
  OC: 'OC',

  /**
   * @description
   * This value designates South America.
   * 
   */
  SA: 'SA',

  /**
   * @description
   * This value designates Mediterranean.
   * 
   */
  ME: 'ME'
};
goog.provide('pcmws.api.Region');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.Region');

/**
 * @classdesc
 * An instance of this class generates the 'Region=Value' parameter.
 *
 * @param {number|string=} value The value from @link pcmws.val.Region.
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Region = function (value) {
  pcmws.api.Region .base(this, 'constructor', 'region', value);
};
goog.inherits(pcmws.api.Region, pcmws.api.Param);

/**
 * @inheritDoc
 */
pcmws.api.Region.prototype.check = function (value) {
  return this.checkRegion(value);
};

/**
 * @description
 * Checks the validity of the value for this parameter.
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.Region}
 */
pcmws.api.Region.prototype.checkRegion = function (value) {

  if (this.checkValue(value, pcmws.val.Region.NA, 4)) {
    return pcmws.val.Region.NA;
  }
  else if (this.checkValue(value, pcmws.val.Region.EU, 3)) {
    return pcmws.val.Region.EU;
  }
  else if (this.checkValue(value, pcmws.val.Region.OC, 5)) {
    return pcmws.val.Region.OC;
  }
  else if (this.checkValue(value, pcmws.val.Region.SA, 6)) {
    return pcmws.val.Region.SA;
  }
  else if (this.checkValue(value, pcmws.val.Region.AF, 1)) {
    return pcmws.val.Region.AF;
  }
  else if (this.checkValue(value, pcmws.val.Region.AS, 2)) {
    return pcmws.val.Region.AS;
  }
  else if (this.checkValue(value, pcmws.val.Region.ME, 7)) {
    return pcmws.val.Region.ME;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal Region parameter value: " + value;
  }
  // If it's a number, make it a string.
  return '' + value;
};
goog.provide('alk.val');

alk.val = {};

/**
 * @description
 * Finds the key in the enum object that matches the value.
 *
 * @param {Object} obj value to covert
 * @param {string} value value to covert
 * @return {string|undefined}
 */
alk.val.findKey = function (obj, value) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (value === obj[key]) {
        return key;
      }
    }
  }
};
goog.provide('pcmws.val.SRS');

goog.require('pcmws.val');
/**
 * @description
 * This object provides the definitive values for the SRS parameter.
 *
 * @enum {string}
 *
 */
pcmws.val.SRS = {
  /**
   * @description
   * This value is the designator for the Spherical Mercator Projection.
   *
   */
  EPSG900913: 'EPSG:900913',
  /**
   * @description
   * This value is the designator for the Flat Mercator Projection.
   *
   */
  EPSG4326: 'EPSG:4326',
  /**
   * @description
   * This value is the designator for the Web(Spherical) Mercator Projection.
   * It is synonymous with EPSG:900913 (Google)
   *
   */
  EPSG3857:'EPSG:3857'
};
goog.provide('alk.val.SRS');

goog.require('alk.val');
goog.require('pcmws.val.SRS');

/**
 * @description
 * This object provides the definitive values for the SRS parameter.
 *
 * @enum {string}
 * @api
 */
alk.val.SRS = {
  /** @api */
  EPSG900913: pcmws.val.SRS.EPSG900913,
  /** @api */
  EPSG4326: pcmws.val.SRS.EPSG4326,
  /** @api */
  EPSG3857: pcmws.val.SRS.EPSG3857
};
goog.provide('alk.format.POIJSON');

goog.require('pcmws.api.DistanceUnits');
goog.require('pcmws.api.Region');

goog.require('alk.format');
goog.require('alk.format.JSONFeature');
goog.require('alk.format.HashedIdFactory');
goog.require('alk.val.SRS');

goog.require('alkx.format.POIJSONOptions');

/**
 * @classdesc
 * An instance of this class provides a format for reading and writing data in the ALK JSON format.
 * See {@link pcmws.poi.POIObject}.
 * @description
 * This constructor creates a Format object with which to parse and decode ALK
 * POI data.
 *
 * Features with Point geometries are generated based on the data and are given
 * FeatureIds {@link ol.Feature#getId} based on the string of each object.
 * With this id, the vector source will not add new features with the same id,
 * thereby eliminating duplicates.
 *
 * If the optional HashedIdFactory is not replaced, a FnVA32 hash algorithm creates the
 * feature Id based on the entire stringified version of the JSON object for each POI.
 * The chances for collision is 1:2^32.
 *
 * If a strict adherence to uniqueness is absolutely needed, the idFactory may be replaced
 * with the options.idFactory.
 *
 * @constructor
 * @extends {alk.format.JSONFeature}
 * @param {alkx.format.POIJSONOptions=} opt_options Options.
 * @api
 */
alk.format.POIJSON = function(opt_options) {
  /** @type {alkx.format.POIJSONOptions} */
  var options = opt_options ? opt_options : {};

  alk.format.POIJSON.base(this, 'constructor');

  /**
   * @inheritDoc
   */
  this.defaultDataProjection = ol.proj.get(
    options.defaultDataProjection ?
      options.defaultDataProjection : alk.val.SRS.EPSG4326);


  if (options.featureProjection) {
    this.defaultFeatureProjection = ol.proj.get(options.featureProjection);
  }

  if (options.idFactory !== undefined) {
    this.idFactory_ = options.idFactory;
  }
  if (this.idFactory_ === undefined) {
    this.idFactory_ = new alk.format.HashedIdFactory();
  }
};
goog.inherits(alk.format.POIJSON, alk.format.JSONFeature);


/**
 * HashedIdFactory.
 * @type {alk.format.HashedIdFactory}
 * @private
 */
alk.format.POIJSON.prototype.idFactory_;

/**
 * @param {pcmws.poi.POIObject} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 * @this {alk.format.POIJSON}
 */
alk.format.POIJSON.prototype.readGeometry_ = function(object, opt_options) {
  if (!object) {
    return null;
  }
  // We only expect a Point Geometry, and this should not return null.
  // If it is, the data is corrupted, we will silently ignore this object.
  var geometry = this.readPointGeometry_(object);
  if (geometry) {
    return /** @type {ol.geom.Geometry} */ (alk.format.Feature_transformWithOptions(geometry, false, opt_options));
  } else {
    return null;
  }
};

/**
 * This function reads the coordinates from the POI Object and returns a Point geometry.
 * If it returns null, it is because the data is corrupted, which should not be the case.
 * @param {pcmws.poi.POIObject} object Object.
 * @private
 * @return {ol.geom.Point} Point.
 * @this {alk.format.POIJSON}
 */
alk.format.POIJSON.prototype.readPointGeometry_ = function(object) {
  if (object.POILocation && object.POILocation.Coords) {
    var lon = parseFloat(object.POILocation.Coords.Lon);
    var lat = parseFloat(object.POILocation.Coords.Lat);
    if (typeof lon === 'number' && typeof lat === 'number') {
      return new ol.geom.Point([lon, lat]);
    }
  }
  return null;
};

/**
 * This function generates a Feature Id for this particular object.
 * Its return is used as the id for the feature, i.e. {@link ol.Feature#getId}.
 * The id is meant to be a quick way to determine if the feature is a
 * duplicate of one already loaded by the a vector source {@link ol.source.Vector}.
 *
 * This implementation makes use of the HashedIdFactory set in the options, or
 * the default which is the @{link alk.format.HashedIdFactory} without collision
 * checking.
 *
 * @param {ol.geom.Geometry} geometry
 * @param {Object} object
 * @returns {number|string|undefined}
 * @protected
 * @this {alk.format.POIJSON}
 */
alk.format.POIJSON.prototype.getFeatureIdForObject = function (geometry, object) {
  var str = JSON.stringify(object);
  return this.idFactory_.getIdForString(str);
};

/**
 * @inheritDoc
 * @this {alk.format.POIJSON}
 */
alk.format.POIJSON.prototype.readFeatureFromObject = function(poi, opt_options) {
  var geometry = this.readGeometryFromObject(poi, opt_options);
  if (geometry) {
    var feature = new ol.Feature(geometry);
    if (poi.DistanceFromCenter && poi.DistanceFromCenter.DistanceUnits) {
      var units = /** @type {number|string} */(poi.DistanceFromCenter.DistanceUnits);
      poi.DistanceFromCenter.DistanceUnits = new pcmws.api.DistanceUnits(units).getCheckedValue();
    }
    if (poi.POILocation && poi.POILocation.Region) {
      var region = /** @type {number|string} */(poi.POILocation.Region);
      poi.POILocation.Region = new pcmws.api.Region(region).getCheckedValue();
    }

    feature.set('poi', poi);
    var hash = this.getFeatureIdForObject(geometry, poi);
    feature.setId(hash);
    return feature;
  }
  return null;
};


/**
 * @inheritDoc
 * @this {alk.format.POIJSON}
 */
alk.format.POIJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
  var features = [];
  var self = this;
  if (object instanceof Array) {
    var objs = /** @type {Array.<Object>} */(object);
    objs.forEach(function (obj) {
      var feature = self.readFeatureFromObject(obj, opt_options);
      if (feature) {
        features.push(feature);
      }
    });
  } else {
    var feature = this.readFeatureFromObject(object, opt_options);
    if (feature) {
      features.push(feature);
    }
  }
  return features;
};

/**
 * @inheritDoc
 * @this {alk.format.POIJSON}
 */
alk.format.POIJSON.prototype.readGeometryFromObject = function(object, opt_options) {
  return this.readGeometry_(
    /** @type {pcmws.poi.POIObject} */ (object), opt_options);
};

/**
 * @inheritDoc
 * @this {alk.format.POIJSON}
 */
alk.format.POIJSON.prototype.readProjectionFromObject = function(object) {
  var projection = this.defaultDataProjection;
  return /** @type {ol.proj.Projection} */ (projection);
};

/**
 * @param {ol.Feature} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.POIJSON.prototype.writeFeatureObject = function (object, opt_options) {
  return null;
};
/**
 * @param {Array.<ol.Feature>} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.POIJSON.prototype.writeFeaturesObject = function (object, opt_options) {
  return null;
};
/**
 * @param {ol.geom.Geometry} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.POIJSON.prototype.writeGeometryObject = function (object, opt_options) {
  return null;
};
goog.provide('alk.format.TrafficCamerasJSON');

goog.require('alk.format');
goog.require('alk.format.JSONFeature');
goog.require('alk.val.SRS');

goog.require('alkx.TrafficCameraSpec');
goog.require('alkx.format.TrafficCamerasJSONOptions');

/**
 * @classdesc
 * An instance of this class provides a format for reading and writing Traffic Cameras JSON.
 * See {@link alkx.TrafficCameraSpec}.
 * @description
 * This constructor creates a Format object with which to parse and deocde
 * ALK Traffic Camera data.
 *
 * Features with Point geometries are generated based on the data and are given
 * FeatureIds {@link ol.Feature#getId} based on the string id of each object.
 * With this id, the vector source will not add new features with the same id,
 * thereby eliminating duplicates.
 *
 * If the optional HashedIdFactory is not replaced, a FnVA32 hash algorithm creates the
 * feature Id based on the entire stringified version of the JSON object for each POI.
 * The chances for collision is 1:2^32.
 *
 * If a strict adherence to uniqueness is absolutely needed, the idFactory may be replaced
 * with the options.idFactory.
 *
 * @constructor
 * @extends {alk.format.JSONFeature}
 * @param {alkx.format.TrafficCamerasJSONOptions=} opt_options Options.
 * @api
 */
alk.format.TrafficCamerasJSON = function(opt_options) {

  var options = opt_options ? opt_options : {};

  alk.format.TrafficCamerasJSON.base(this, 'constructor');

  /**
   * @inheritDoc
   */
  this.defaultDataProjection = ol.proj.get(
    options.defaultDataProjection ?
      options.defaultDataProjection : alk.val.SRS.EPSG4326);


  if (options.featureProjection) {
    this.defaultFeatureProjection = ol.proj.get(options.featureProjection);
  }

  if (options.idFactory !== undefined) {
    this.idFactory_ = options.idFactory;
  }
  if (this.idFactory_ == null) {
    this.idFactory_ = new alk.format.HashedIdFactory();
  }
};
goog.inherits(alk.format.TrafficCamerasJSON, alk.format.JSONFeature);


/**
 * HashedIdFactory.
 * @type {alk.format.HashedIdFactory}
 * @private
 */
alk.format.TrafficCamerasJSON.prototype.idFactory_;

/**
 * @param {alkx.TrafficCameraSpec} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 * @this {alk.format.TrafficCamerasJSON}
 */
alk.format.TrafficCamerasJSON.prototype.readGeometry_ = function(object, opt_options) {
  if (!object) {
    return null;
  }
  // We only expect a Point Geometry, but may return null.
  var geometry = this.readPointGeometry_(object);
  if (geometry) {
    return /** @type {ol.geom.Geometry} */ (alk.format.Feature_transformWithOptions(geometry, false, opt_options));
  } else {
    return null;
  }
};

/**
 * This function reads the coordinates from the Traffic Camera and returns a Point geometry.
 * The Point should not be null. The Point is in Array.<number> format.
 * @param {alkx.TrafficCameraSpec} object Object.
 * @private
 * @return {ol.geom.Point} Point.
 */
alk.format.TrafficCamerasJSON.prototype.readPointGeometry_ = function(object) {
  if (object.Coordinates) {
    return new ol.geom.Point(object.Coordinates);
  }
  return null;
};

/**
 * This function generates a Feature Id for this particular object.
 * Its return is used as the id for the feature, i.e. {@link ol.Feature#getId}.
 * The id is meant to be a quick way to determine if the feature is a
 * duplicate of one already loaded by the a vector source {@link ol.source.Vector}.
 *
 * This implementation makes use of the HashedIdFactory set in the options, or
 * the default which is the @{link alk.format.HashedIdFactory} without collision
 * checking.
 *
 * @param {ol.geom.Geometry} geometry
 * @param {Object} object
 * @returns {number|string|undefined}
 * @protected
 * @this {alk.format.TrafficCamerasJSON}
 */
alk.format.TrafficCamerasJSON.prototype.getFeatureIdForObject = function (geometry, object) {
  return this.idFactory_.getIdForString(object.PublicId);
};

/**
 * @inheritDoc
 * @this {alk.format.TrafficCamerasJSON}
 */
alk.format.TrafficCamerasJSON.prototype.readFeatureFromObject = function(object, opt_options) {
  var geometry = this.readGeometryFromObject(object, opt_options);
  if (geometry) {
    var feature = new ol.Feature(geometry);
    feature.set('trafficCamera', object);
    var id = this.getFeatureIdForObject(geometry, object);
    feature.setId(id);
    return feature;
  }
  return null;
};


/**
 * @inheritDoc
 * @this {alk.format.TrafficCamerasJSON}
 */
alk.format.TrafficCamerasJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
  var features = [];
  var self = this;
  if (object instanceof Array) {
    var objs = /** @type {Array.<Object>} */(object);
    objs.forEach(function (obj) {
      var feature = self.readFeatureFromObject(obj, opt_options);
      if (feature) {
        features.push(feature);
      }
    });
  } else {
    var feature = this.readFeatureFromObject(object, opt_options);
    if (feature) {
      features.push(feature);
    }
  }
  return features;
};

/**
 * @inheritDoc
 * @this {alk.format.TrafficCamerasJSON}
 */
alk.format.TrafficCamerasJSON.prototype.readGeometryFromObject = function(object, opt_options) {
  return this.readGeometry_(
    /** @type {alkx.TrafficCameraSpec} */ (object), opt_options);
};

/**
 * @inheritDoc
 * @this {alk.format.TrafficCamerasJSON}
 */
alk.format.TrafficCamerasJSON.prototype.readProjectionFromObject = function(object) {
  var projection = this.defaultDataProjection;
  return /** @type {ol.proj.Projection} */ (projection);
};

/**
 * @param {ol.Feature} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.TrafficCamerasJSON.prototype.writeFeatureObject = function (object, opt_options) {
  return null;
};
/**
 * @param {Array.<ol.Feature>} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.TrafficCamerasJSON.prototype.writeFeaturesObject = function (object, opt_options) {
  return null;
};
/**
 * @param {ol.geom.Geometry} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.TrafficCamerasJSON.prototype.writeGeometryObject = function (object, opt_options) {
  return null;
};
goog.provide('alk.format.TrafficIncidentsJSON');

goog.require('alk.format');
goog.require('alk.format.JSONFeature');
goog.require('alk.val.SRS');

goog.require('alkx.TrafficIncidentSpec');
goog.require('alkx.format.TrafficIncidentsJSONOptions');

/**
 * @classdesc
 * An instance of this class provides a format for reading and writing Traffic Incidents JSON.
 * See {@link alkx.TrafficIncidentSpec}.
 * @description
 * This constructor creates a Format object with which to parse and deocde ALK
 * Traffic Incident data.
 *
 * Features with Point geometries are generated based on the data and are given
 * FeatureIds {@link ol.Feature#getId} based on the string id of each object.
 * With this id, the vector source will not add new features with the same id,
 * thereby eliminating duplicates.
 *
 * If the optional HashedIdFactory is not replaced, a FnVA32 hash algorithm creates the
 * feature Id based on the entire stringified version of the JSON object for each POI.
 * The chances for collision is 1:2^32.
 *
 * If a strict adherence to uniqueness is absolutely needed, the idFactory may be replaced
 * with the options.idFactory.
 *
 * @constructor
 * @extends {alk.format.JSONFeature}
 * @param {alkx.format.TrafficIncidentsJSONOptions=} opt_options Options.
 * @api
 */
alk.format.TrafficIncidentsJSON = function (opt_options) {

  var options = opt_options ? opt_options : {};

  alk.format.TrafficIncidentsJSON.base(this, 'constructor');

  /**
   * @inheritDoc
   */
  this.defaultDataProjection = ol.proj.get(
    options.defaultDataProjection ?
      options.defaultDataProjection : alk.val.SRS.EPSG4326);


  if (options.featureProjection) {
    this.defaultFeatureProjection = ol.proj.get(options.featureProjection);
  }

  if (options.idFactory !== undefined) {
    this.idFactory_ = options.idFactory;
  }
  if (this.idFactory_ == null) {
    this.idFactory_ = new alk.format.HashedIdFactory();
  }
};
goog.inherits(alk.format.TrafficIncidentsJSON, alk.format.JSONFeature);


/**
 * HashedIdFactory.
 * @type {alk.format.HashedIdFactory}
 * @private
 */
alk.format.TrafficIncidentsJSON.prototype.idFactory_;

/**
 * @param {alkx.TrafficIncidentSpec} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.readGeometry_ = function (object, opt_options) {
  if (!object) {
    return null;
  }
  // We only expect a Point Geometry, but may return null.
  var geometry = this.readPointGeometry_(object);
  if (geometry) {
    return /** @type {ol.geom.Geometry} */ (alk.format.Feature_transformWithOptions(geometry, false, opt_options));
  } else {
    return null;
  }
};

/**
 * This function reads the coordinates from the Traffic Incident and returns a Point geometry.
 * The Point should not be null. The Point is in Array.<number> format.
 * @param {alkx.TrafficIncidentSpec} object Object.
 * @private
 * @return {ol.geom.Point} Point.
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.readPointGeometry_ = function (object) {
  if (object.Locations && object.Locations.length > 0) {
    return new ol.geom.Point(object.Locations[0]);
  }
  return null;
};

/**
 * This function generates a Feature Id for this particular object.
 * Its return is used as the id for the feature, i.e. {@link ol.Feature#getId}.
 * The id is meant to be a quick way to determine if the feature is a
 * duplicate of one already loaded by the a vector source {@link ol.source.Vector}.
 *
 * This implementation makes use of the HashedIdFactory set in the options, or
 * the default which is the @{link alk.format.HashedIdFactory} without collision
 * checking.
 *
 * @param {ol.geom.Geometry} geometry
 * @param {Object} object
 * @returns {number|string|undefined}
 * @protected
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.getFeatureIdForObject = function (geometry, object) {
  /** @type {alkx.TrafficIncidentSpec} */
  var obj = /** @type {alkx.TrafficIncidentSpec} */(object);
  return this.idFactory_.getIdForString(obj.EventType + obj.EventCategory + obj.Locations);
};

/**
 * @inheritDoc
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.readFeatureFromObject = function (object, opt_options) {
  var geometry = this.readGeometryFromObject(object, opt_options);
  if (geometry) {
    var feature = new ol.Feature(geometry);
    feature.set('trafficIncident', object);
    var id = this.getFeatureIdForObject(geometry, object);
    feature.setId(id);
    return feature;
  }
  return null;
};

/**
 * @param {alkx.TrafficIncidentSpec} object
 * @returns {Array.<alkx.TrafficIncidentSpec>}
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.toArrayFromObject = function (object) {
  // Remove duplicate locations
  var locations = object.Locations;
  var locs = locations.reduce(function (a, loc) {
    return a.some(function (a) {
      return ol.coordinate.equals(a, loc);
    }) ? a : a.concat([loc]);
  }, []);
  if (locs.length === 1) {
    object.Locations = locs;
    return [object];
  }
  /** @type {Array.<alkx.TrafficIncidentSpec>} */
  var objects = [];
  locs.forEach(function (loc) {
    var nobj = {
      Locations: [loc],
      DescriptionLong: object.DescriptionLong,
      DescriptionShort: object.DescriptionShort,
      EventCategory: object.EventCategory,
      EventType: object.EventType
    };
    objects.push(nobj);
  });
  return objects;
};

/**
 * @inheritDoc
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
  var features = [];
  var self = this;
  /** @type {Array.<alkx.TrafficIncidentSpec>} */
  var objects = [];
  if (object instanceof Array) {
    /** @type {Array.<alkx.TrafficIncidentSpec>} */(object).forEach(function (obj) {
      objects = objects.concat(self.toArrayFromObject(obj));
    });
  } else {
    objects = object.concat(self.toArrayFromObject(/** @type {alkx.TrafficIncidentSpec} */(object)));
  }
  objects.forEach(function (obj) {
    var feature = self.readFeatureFromObject(obj, opt_options);
    if (feature) {
      features.push(feature);
    }
  });
  return features;
};

/**
 * @inheritDoc
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.readGeometryFromObject = function (object, opt_options) {
  return this.readGeometry_(
    /** @type {alkx.TrafficIncidentSpec} */ (object), opt_options);
};

/**
 * @inheritDoc
 * @this {alk.format.TrafficIncidentsJSON}
 */
alk.format.TrafficIncidentsJSON.prototype.readProjectionFromObject = function (object) {
  var projection = this.defaultDataProjection;
  return /** @type {ol.proj.Projection} */ (projection);
};

/**
 * @param {ol.Feature} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.TrafficIncidentsJSON.prototype.writeFeatureObject = function (object, opt_options) {
  return null;
};
/**
 * @param {Array.<ol.Feature>} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.TrafficIncidentsJSON.prototype.writeFeaturesObject = function (object, opt_options) {
  return null;
};
/**
 * @param {ol.geom.Geometry} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.TrafficIncidentsJSON.prototype.writeGeometryObject = function (object, opt_options) {
  return null;
};
goog.provide('alk.format.WeatherAlertsJSON');

goog.require('alk.format');
goog.require('alk.format.JSONFeature');
goog.require('alk.val.SRS');

goog.require('alkx.WeatherAlert');
goog.require('alkx.format.WeatherAlertsJSONOptions');

/**
 * @classdesc
 * An instance of this class provides a format for reading and writing Weather Alert JSON.
 * See {@link pcmws.api.WeatherAlert}.
 * @description
 * This constructor creates a Format object with which to parse and decode ALK Weather
 * Alert data.
 *
 * Features with Polygon geometries are generated based on the data and are given
 * FeatureIds {@link ol.Feature#getId} based on the string of each object.
 * With this id, the vector source will not add new features with the same id,
 * thereby eliminating duplicates.
 *
 * If the optional HashedIdFactory is not replaced, a FnVA32 hash algorithm creates the
 * feature Id based on the entire stringified version of the JSON object for each POI.
 * The chances for collision is 1:2^32.
 *
 * If a strict adherence to uniqueness is absolutely needed, the idFactory may be replaced
 * with the options.idFactory.
 *
 * @constructor
 * @extends {alk.format.JSONFeature}
 * @param {alkx.format.WeatherAlertsJSONOptions=} opt_options Options.
 * @api
 */
alk.format.WeatherAlertsJSON = function(opt_options) {

  var options = opt_options ? opt_options : {};

  alk.format.WeatherAlertsJSON.base(this, 'constructor');

  /**
   * @inheritDoc
   */
  this.defaultDataProjection = ol.proj.get(
    options.defaultDataProjection ?
      options.defaultDataProjection : alk.val.SRS.EPSG4326);


  if (options.featureProjection) {
    this.defaultFeatureProjection = ol.proj.get(options.featureProjection);
  }

  if (options.idFactory !== undefined) {
    this.idFactory_ = options.idFactory;
  }
  if (this.idFactory_ == null) {
    this.idFactory_ = new alk.format.HashedIdFactory();
  }
  if (options.polygonsCountyCache !== undefined) {
    this.polygonsCountyCache_ = options.polygonsCountyCache;
  }
};
goog.inherits(alk.format.WeatherAlertsJSON, alk.format.JSONFeature);


/**
 * HashedIdFactory.
 * @type {alk.format.HashedIdFactory}
 * @private
 */
alk.format.WeatherAlertsJSON.prototype.idFactory_;

/**
 * @type {alk.source.PolygonsCountyCache}
 * @private
 */
alk.format.WeatherAlertsJSON.prototype.polygonsCountyCache_;

/**
 * @param {pcmws.api.WeatherAlert} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 * @this {alk.format.WeatherAlertsJSON}
 */
alk.format.WeatherAlertsJSON.prototype.readGeometry_ = function(object, opt_options) {
  if (!object) {
    return null;
  }
  // We only expect a Polygon Geometry, but may return null.
  var geometry = this.readPolygonGeometry_(object);
  if (geometry) {
    return /** @type {ol.geom.Geometry} */ (alk.format.Feature_transformWithOptions(geometry, false, opt_options));
  } else {
    // we must retrieve a polygon for the county.
    return null;
  }
};

/**
 * This function reads the coordinates from the Weather Alert and returns a Polygon geometry.
 * The polygon may be null. The Polygon is in WKT format.
 * @param {pcmws.api.WeatherAlert} object Object.
 * @private
 * @return {ol.geom.Polygon} Polygon.
 */
alk.format.WeatherAlertsJSON.prototype.readPolygonGeometry_ = function(object) {
  if (object.Polygon) {
    var format = new ol.format.WKT({splitCollection: false});
    try {
      var polygon = format.readGeometry(object.Polygon);
      if (polygon.getType() === 'Polygon') {
        return /** @type {ol.geom.Polygon} */(polygon);
      }
    } catch (e) {
      console.log(e.toString());
    }
  }
  return null;
};

/**
 * This function generates a Feature Id for this particular object.
 * Its return is used as the id for the feature, i.e. {@link ol.Feature#getId}.
 * The id is meant to be a quick way to determine if the feature is a
 * duplicate of one already loaded by the a vector source {@link ol.source.Vector}.
 *
 * This implementation makes use of the HashedIdFactory set in the options, or
 * the default which is the @{link alk.format.HashedIdFactory} without collision
 * checking.
 *
 * @param {ol.geom.Geometry} geometry
 * @param {Object} object
 * @returns {number|string|undefined}
 * @this {alk.format.WeatherAlertsJSON}
 * @protected
 */
alk.format.WeatherAlertsJSON.prototype.getFeatureIdForObject = function (geometry, object) {
  return this.idFactory_.getIdForString(object.ID);
};

/**
 * @param {alkx.WeatherAlert} alert
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.GeometryCollection}
 * @this {alk.format.WeatherAlertsJSON}
 */
alk.format.WeatherAlertsJSON.prototype.useGeometryCollection = function (alert, opt_options) {
  var self = this;
  if (this.polygonsCountyCache_) {
    var format = new ol.format.WKT();
    if (alert.FipsCodes) {
      var geometryCollection = new ol.geom.GeometryCollection([]);
      geometryCollection.set('id', alert.ID);
      var codes = alert.FipsCodes.split(' ');
      geometryCollection.set('codes', codes.length);
      codes.forEach(function (code) {
        var pgc = self.polygonsCountyCache_.getPolygonForCountyCode(code);
        if (pgc == null) {
          self.polygonsCountyCache_.queueCountyCode(code, function (obj) {
            var geom = format.readGeometry(obj.Polygon);
            var tgeom = /** @type {ol.geom.Geometry} */ (alk.format.Feature_transformWithOptions(geom, false, opt_options));
            var geoms = geometryCollection.getGeometries();
            geoms.push(tgeom);
            geometryCollection.setGeometries(geoms);
          });
        } else {
          if (pgc.Polygon) {
            var geom = format.readGeometry(pgc.Polygon);
            var tgeom = /** @type {ol.geom.Geometry} */ (alk.format.Feature_transformWithOptions(geom, false, opt_options));
            var geoms = geometryCollection.getGeometries();
            geoms.push(tgeom);
            geometryCollection.setGeometries(geoms);
          }
        }
      });
      return geometryCollection;
    }
  }
  return null;
};

/**
 * @inheritDoc
 * @this {alk.format.WeatherAlertsJSON}
 */
alk.format.WeatherAlertsJSON.prototype.readFeatureFromObject = function(object, opt_options) {
  var geometry = this.readGeometryFromObject(object, opt_options);
  if (geometry == null) {
    geometry = this.useGeometryCollection(/** @type {alkx.WeatherAlert} */(object), opt_options);
  }
  if (geometry) {
    var feature = new ol.Feature(geometry);
    feature.set('weatherAlert', object);
    var id = this.getFeatureIdForObject(geometry, object);
    feature.setId(id);
    return feature;
  }
  return null;
};


/**
 * @inheritDoc
 * @this {alk.format.WeatherAlertsJSON}
 */
alk.format.WeatherAlertsJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
  var features = [];
  var self = this;
  if (object instanceof Array) {
    var objs = /** @type {Array.<Object>} */(object);
    objs.forEach(function (obj) {
      var feature = self.readFeatureFromObject(obj, opt_options);
      if (feature) {
        features.push(feature);
      }
    });
  } else {
    var feature = this.readFeatureFromObject(object, opt_options);
    if (feature) {
      features.push(feature);
    }
  }
  if (this.polygonsCountyCache_) {
    this.polygonsCountyCache_.processQueue(function () {
      console.log('Getting polygons');
    });
  }
  return features;
};

/**
 * @inheritDoc
 * @this {alk.format.WeatherAlertsJSON}
 */
alk.format.WeatherAlertsJSON.prototype.readGeometryFromObject = function(object, opt_options) {
  return this.readGeometry_(
    /** @type {pcmws.api.WeatherAlert} */ (object), opt_options);
};

/**
 * @inheritDoc
 * @this {alk.format.WeatherAlertsJSON}
 */
alk.format.WeatherAlertsJSON.prototype.readProjectionFromObject = function(object) {
  var projection = this.defaultDataProjection;
  return /** @type {ol.proj.Projection} */ (projection);
};

/**
 * @param {ol.Feature} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.WeatherAlertsJSON.prototype.writeFeatureObject = function (object, opt_options) {
  return null;
};
/**
 * @param {Array.<ol.Feature>} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.WeatherAlertsJSON.prototype.writeFeaturesObject = function (object, opt_options) {
  return null;
};
/**
 * @param {ol.geom.Geometry} object
 * @param {olx.format.WriteOptions=}opt_options
 * @returns {Object}
 * @override
 */
alk.format.WeatherAlertsJSON.prototype.writeGeometryObject = function (object, opt_options) {
  return null;
};
goog.provide('alk.geocode');

goog.require('alk');

alk.geocode = {};
goog.provide('alk.service');

goog.require('alk');
goog.require('pcmws');

alk.service = {};

/**
 * This method turns on a feature that will throw an
 * exception if any of values of the service parameters
 * do not match or are equivalent to their alk.val counter
 * parts.
 *
 * The service parameters are used in constructing URLs for
 * ALK services. We attempt to check the names and values of
 * the arguments you give to an alk.service as a malformed
 * value may not always lead to a noticeable error response.
 *
 * @example
 * alk.service.setArgCheck(true);
 * alk.service.MapTileService({
 *    style: "night"
 * );
 *
 * The above example will throw an error at URL generation time, because the
 * proper value to use is alk.val.Style.Night, which is equal to "Night".
 * Case matters.
 *
 * If the argument check is set to false, and the item will not be checked
 * for validity, and it will be silently ignored.
 *
 * Keep in mind that a parameter name may be mapped to something else and value may
 * not always be relevant to the particular service and therefor ignored.
 * For example, "apiKey" is mapped to "authToken" in most PCMiler Web Services.
 *
 * @example
 * alk.service.setArgCheck(false);
 * alk.service.MapTileService({
 *    apiKey: "1234",
 *    style: "night"
 * );
 *
 * would generate a URL similar to the following:
 *
 * http://pcmiler.alk.com/apis/rest/v1.0/service.svc/maptile?authToken=1234&x=0&y=0&z=0.
 *
 * and therefore you would get the "Default" style as a matter of the
 * Server's default.
 *
 * Please see {@link alk.service.setArgPermissive} to let unchecked
 * values through to the service parameters.
 *
 * @example
 * alk.service.setArgCheck(false);
 * alk.service.setArgPermissive(true);
 * alk.service.MapTileService({
 *    apiKey: "1234",
 *    style: "night"
 * );
 *
 * would generate the URL similar to the following:
 *
 * http://pcmiler.alk.com/apis/rest/v1.0/service.svc/maptile?style=night&authToken=1234&x=0&y=0&z=0.
 *
 * and therefore you may get the "Default" style as a matter of the
 * Server's default because the server does't know about "night",
 * you may get an HTTP 500 error, bad request depending on the service.
 *
 * @param {boolean} onoff A boolean of true is on.
 * @returns {boolean} The previous value;
 * @api
 */
alk.service.setArgCheck = function(onoff) {
  var prev = pcmws.ARG_CHECK;
  pcmws.ARG_CHECK = onoff;
  return prev;
};

/**
 * This method turns on a feature that will allow non-standard
 * values for certain parameters. This feature, if used with
 * alk.service.setArgCheck(false), will allow non standard values.
 * This approach may be good for development and experimentation
 * where checked values have not yet been assigned.
 *
 * @example
 * alk.service.setArgPermissive(true);
 * alk.service.MapTileService({
 *    style: "new-style-2"
 * );
 *
 * The above example would generate a PC Miler maptile URL of
 * http://pcmiler.alk.com/apis/rest/v1.0/service.svc/maptile?style=new-style-2&AuthToken=233423432&x=0&y=0&z=0.
 * Case matters.
 *
 * @param {boolean} onoff A boolean of true is on.
 * @returns {boolean} The previous value.
 * @api
 */
alk.service.setArgPermissive = function(onoff) {
  var prev = pcmws.ARG_PERMISSIVE;
  pcmws.ARG_PERMISSIVE = onoff;
  return prev;
};
goog.provide('pcmws.api.MultivalueParam');

goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * This class handles multivalued parameters, which are realized as
 * strings separated with the specified separator, which is comma (,) as default.
 * @param {string} name The name of the parameter, such as 'PT1' or 'PT2'.
 * @param {Array<*>|string|undefined} values The value
 * @param {string=} separator
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.MultivalueParam = function (name, values, separator) {
  pcmws.api.MultivalueParam.base(this, 'constructor', name, values);
  var sep = separator !== undefined ? separator : ',';
  this.separator = sep;
};
goog.inherits(pcmws.api.MultivalueParam, pcmws.api.Param);

/**
 * @type {string}
 */
pcmws.api.MultivalueParam.prototype.separator;

/**
 * @param {*} value
 * @returns {*}
 */
pcmws.api.MultivalueParam.prototype.checkEach = function (value) {
  return value;
};

/**
 * @param {*} value
 * @returns {*}
 * @override
 * @this {pcmws.api.MultivalueParam}
 */
pcmws.api.MultivalueParam.prototype.check = function (value) {
  var self = this;
  if (value instanceof Array) {
    // Ugg, type * doesn't include Array<*>. Cast it over
    return /** @type {*} */(value.map(function (v) { return self.checkEach(v); }));
  }
  return undefined;
};
/**
 * @returns {string|undefined}
 * @override
 * @this {pcmws.api.MultivalueParam}
 */
pcmws.api.MultivalueParam.prototype.getCheckedStringValue = function () {
  var value = this.getCheckedValue();
  if (value === undefined && this.value !== undefined) {
    if (typeof this.value === 'string') {
      return this.value;
    }
  }
  if (value instanceof Array) {
    return value.map(function (v) {return ''+v;}).join(this.separator);
  }
  return ''+value;
};

/**
 * @returns {string}
 * @override
 * @this {pcmws.api.MultivalueParam}
 */
pcmws.api.MultivalueParam.prototype.getCheckedDataValue = function () {
  var value = this.getCheckedValue();
  if (value === undefined && this.value !== undefined) {
    if (typeof this.value === 'string') {
      return this.value;
    }
  }
  if (value instanceof Array) {
    return JSON.stringify(value);
  }
  return ''+value;
};
goog.provide('pcmws.api.AfSetIds');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the AfSetIds parameter for a PCM service.
 * @param {Array<string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.AfSetIds = function (values) {
  pcmws.api.AfSetIds.base(this, 'constructor', 'afSetIds', values);
};
goog.inherits(pcmws.api.AfSetIds, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.BooleanParam');

goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @param {string} name The name of the parameter, such as 'PT1' or 'PT2'.
 * @param {boolean|string|number|undefined} value The value, which is true or false
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.BooleanParam = function (name, value) {
  pcmws.api.BooleanParam.base(this, 'constructor', name, value);
};
goog.inherits(pcmws.api.BooleanParam, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.BooleanParam}
 */
pcmws.api.BooleanParam.prototype.check = function (value) {
  return this.checkBooleanParam(value);
};

/**
 * @description
 * Checks the value for a BooleanParam parameter. If the value is a number, 0 is false, and
 * all else is true. If the value is a string it is assigned as is.
 * @param {*} value
 * @returns {boolean|undefined}
 * @this {pcmws.api.BooleanParam}
 */
pcmws.api.BooleanParam.prototype.checkBooleanParam = function (value) {
  if (typeof value === 'boolean') {
    return value;
  } else if (typeof value === 'number') {
    return value !== 0;
  } else {
    return undefined;
  }
};

goog.provide('pcmws.api.AvoidFavors');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the AvoidFavors parameter for a PCM service.
 * @param {boolean|string=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.AvoidFavors = function (value) {
  pcmws.api.AvoidFavors.base(this, 'constructor', 'AvoidFavors', value);
};
goog.inherits(pcmws.api.AvoidFavors, pcmws.api.BooleanParam);
goog.provide('pcmws.api.AvoidTolls');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the AvoidTolls parameter for a PCM service.
 * @param {boolean|string=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.AvoidTolls = function (value) {
  pcmws.api.AvoidTolls.base(this, 'constructor', 'avoidTolls', value);
};
goog.inherits(pcmws.api.AvoidTolls, pcmws.api.BooleanParam);
goog.provide('pcmws.api.NumberParam');

goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @param {string} name The name of the parameter, such as 'PT1' or 'PT2'.
 * @param {number|string|undefined} value The value, which is a number
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.NumberParam = function (name, value) {
  pcmws.api.NumberParam.base(this, 'constructor', name, '' + value);
};
goog.inherits(pcmws.api.NumberParam, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.NumberParam}
 */
pcmws.api.NumberParam.prototype.check = function (value) {
  return this.checkNumber(value);
};

/**
 * @description
 * Checks the value for a Number parameter. If a number is supplied, it is
 * converted to a string. If it is a string, it is assigned and left unchecked.
 * @param {*} value
 * @returns {*}
 * @this {pcmws.api.NumberParam}
 */
pcmws.api.NumberParam.prototype.checkNumber = function (value) {
  if (value === true) {
    return 1;
  } else if (value === false) {
    return 0;
  } else if (typeof value === 'number') {
    return value;
  } else if (typeof value === 'string') {
    var val = parseFloat(value);
    if (val === val) {
      return val;
    }
    // It's a Nan
  }
  return undefined;
};

goog.provide('pcmws.api.Axles');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Axles parameter for a PCM service.
 * This parameter specifies the number of axles on the vehicle. The valid values
 * are between 1 and 14 inclusive.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Axles = function (value) {
  pcmws.api.Axles.base(this, 'constructor', 'axles', value);
};
goog.inherits(pcmws.api.Axles, pcmws.api.NumberParam);
goog.provide('pcmws.api.BorderWait');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the BorderWait parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.BorderWait = function (value) {
  pcmws.api.BorderWait.base(this, 'constructor', 'borderWait', value);
};
goog.inherits(pcmws.api.BorderWait, pcmws.api.NumberParam);
goog.provide('pcmws.api.BoundingBox');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class represents the BoundingBox parameter for a PCM service.
 * Its value is also an OpenLayers Extent. Bottom,Left,Top,Right.
 *
 * @param {Array.<number>|string=} value The coordinate.
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.BoundingBox = function (value) {
  pcmws.api.BoundingBox.base(this, 'constructor', 'bbox', value);
};
goog.inherits(pcmws.api.BoundingBox, pcmws.api.Param);


/**
 *
 * @returns {string}
 * @override
 * @this {pcmws.api.BoundingBox}
 */
pcmws.api.BoundingBox.prototype.getCheckedStringValue = function () {
  var value = this.getCheckedValue();
  if (value === undefined && this.value !== undefined) {
    if (typeof this.value === 'string') {
      return this.value;
    }
  }
  if (value instanceof Array) {
    return value.join(',');
  }
  return ''+value;
};

goog.provide('pcmws.api.BreakInterval');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the BreakInterval parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.BreakInterval = function (value) {
  pcmws.api.BreakInterval.base(this, 'constructor', 'breakInterval', value);
};
goog.inherits(pcmws.api.BreakInterval, pcmws.api.NumberParam);
goog.provide('pcmws.api.BreakLength');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the BreakLength parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.BreakLength = function (value) {
  pcmws.api.BreakLength.base(this, 'constructor', 'breakLength', value);
};
goog.inherits(pcmws.api.BreakLength, pcmws.api.NumberParam);
goog.provide('pcmws.api.LonLat');

goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class specifies a named parameter of a LonLat coordinate, which
 * is an array of numbers.
 *
 * @param {string} name The name of the parameter, such as 'PT1' or 'PT2'.
 * @param {Array.<number>|string|undefined} value The value as either a string '-74.45,43.04' or array
 * of 2 numbers, such as [-74.45, 43.04] (only first two numbers in an array are used).
 * It could also be a string to be used as replacements such as '{lon},{lat}' or '{lonlat}'.
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.LonLat = function (name, value) {
  pcmws.api.LonLat.base(this, 'constructor', name, value);
};
goog.inherits(pcmws.api.LonLat, pcmws.api.Param);


/**
 *
 * @returns {string|undefined}
 * @override
 * @this {pcmws.api.LonLat}
 */
pcmws.api.LonLat.prototype.getCheckedStringValue = function () {
  var value = this.getCheckedValue();
  if (value === undefined && this.value !== undefined) {
    if (typeof this.value === 'string') {
      return this.value;
    }
  }
  if (value instanceof Array) {
    return value.join(',');
  }
  if (value !== undefined) {
    return ''+value;
  }
};
goog.provide('pcmws.api.Center');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.LonLat');

/**
 * @classdesc
 * An instance of this class represents the Center parameter for a PCM service.
 *
 * @param {Array.<number>|string=} value The coordinate.
 * @constructor
 * @extends {pcmws.api.LonLat}
 *
 */
pcmws.api.Center = function (value) {
  pcmws.api.Center.base(this, 'constructor', 'center', value);
};
goog.inherits(pcmws.api.Center, pcmws.api.LonLat);
goog.provide('pcmws.api.EnumParam');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class represents parameter in a PCM service
 * represented by values of an enum, where numeric values will be
 * in the order of the keys presented in the enum (one hopes).
 * TODO: Does Object.keys() present in the order defined?
 * @param {string} name
 * @param {Object!} theEnum
 * @param {number|string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.EnumParam = function (name, theEnum, value) {
  this.theEnum_ = theEnum;
  this.shouldEncodeValue = true;
  pcmws.api.EnumParam.base(this, 'constructor',  name, value);
};
goog.inherits(pcmws.api.EnumParam, pcmws.api.Param);

/**
 * @type {Object!}
 */
pcmws.api.EnumParam.prototype.theEnum_;

/**
 * @inheritDoc
 * @this {pcmws.api.EnumParam}
 */
pcmws.api.EnumParam.prototype.check = function (value) {
  return this.checkEnumValue(value);
};

/**
 * @description
 * This checks the validity of the value of this parameter against the values
 * for {@link pcmws.val.EnumParam}.
 * TODO: Check against number values.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.EnumParam}
 */
pcmws.api.EnumParam.prototype.checkEnumValue = function (value) {
  var keys = Object.keys(this.theEnum_);
  for(var i = 0; i < keys.length; i++) {
    if (this.checkValue(value, this.theEnum_[keys[i]], i)) {
      return this.theEnum_[keys[i]];
    }
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal " + this.name + " parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.val.Certainty');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the Certainty parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.Certainty = {
  /**  */
 All: 'All',
  /**  */
 Observed: 'Observed',
  /**  */
 Likely: 'Likely',
  /**  */
 Possible: 'Possible',
  /**  */
 Unlikely: 'Unlikely',
  /**  */
 Unknown: 'Unknown'
};
goog.provide('pcmws.api.Certainty');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.Certainty');

/**
 * @classdesc
 * An instance of this class represents the Certainty parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.Certainty = function (value) {
  pcmws.api.Certainty.base(this, 'constructor', 'certainty', pcmws.val.Certainty, value);
};
goog.inherits(pcmws.api.Certainty, pcmws.api.EnumParam);
goog.provide('pcmws.api.CiteInterval');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CiteInterval parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CiteInterval = function (value) {
  pcmws.api.CiteInterval.base(this, 'constructor', 'citeint', value);
};
goog.inherits(pcmws.api.CiteInterval, pcmws.api.NumberParam);
goog.provide('pcmws.api.City');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the City parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.City = function (value) {
  pcmws.api.City .base(this, 'constructor', 'city', value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.City, pcmws.api.Param);
goog.provide('pcmws.api.CitySearchFilter');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the CitySearchFilter parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.CitySearchFilter = function (value) {
  pcmws.api.CitySearchFilter .base(this, 'constructor', 'citySearchFilter', value);
};
goog.inherits(pcmws.api.CitySearchFilter, pcmws.api.Param);
goog.provide('pcmws.api.CondenseDirections');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the CondenseDirections parameter for a PCM service.
 *
 * This parameter specifies whether or not to condense the directions in the report.
 * @param {boolean|string=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.CondenseDirections = function (value) {
  pcmws.api.CondenseDirections.base(this, 'constructor', 'condenseDirs', value);
};
goog.inherits(pcmws.api.CondenseDirections, pcmws.api.BooleanParam);
goog.provide('pcmws.api.Coords');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.LonLat');

/**
 * @classdesc
 * An instance of this class represents the Coords parameter for a PCM service.
 *
 * @param {Array.<number>|string=} value The coordinate.
 * @constructor
 * @extends {pcmws.api.LonLat}
 *
 */
pcmws.api.Coords = function (value) {
  pcmws.api.Coords.base(this, 'constructor', 'coords', value);
};
goog.inherits(pcmws.api.Coords, pcmws.api.LonLat);
goog.provide('pcmws.api.CostGreenHouseGas');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CostGreenHouseGas parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CostGreenHouseGas = function (value) {
  pcmws.api.CostGreenHouseGas.base(this, 'constructor', 'costGHG', value);
};
goog.inherits(pcmws.api.CostGreenHouseGas, pcmws.api.NumberParam);
goog.provide('pcmws.api.CostMaintenanceEmpty');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CostMaintenanceEmpty parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CostMaintenanceEmpty = function (value) {
  pcmws.api.CostMaintenanceEmpty.base(this, 'constructor', 'costMaintEmpty', value);
};
goog.inherits(pcmws.api.CostMaintenanceEmpty, pcmws.api.NumberParam);
goog.provide('pcmws.api.CostMaintenanceLoad');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CostMaintenanceLoad parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CostMaintenanceLoad = function (value) {
  pcmws.api.CostMaintenanceLoad.base(this, 'constructor', 'costMaintLoad', value);
};
goog.inherits(pcmws.api.CostMaintenanceLoad, pcmws.api.NumberParam);
goog.provide('pcmws.api.CostPerFuelUnit');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CostPerFuelUnit parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CostPerFuelUnit = function (value) {
  pcmws.api.CostPerFuelUnit.base(this, 'constructor', 'costPerFuelUnit', value);
};
goog.inherits(pcmws.api.CostPerFuelUnit, pcmws.api.NumberParam);
goog.provide('pcmws.api.CostTimeEmpty');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CostTimeEmpty parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CostTimeEmpty = function (value) {
  pcmws.api.CostTimeEmpty.base(this, 'constructor', 'costTimeEmpty', value);
};
goog.inherits(pcmws.api.CostTimeEmpty, pcmws.api.NumberParam);
goog.provide('pcmws.api.CostTimeLoad');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CostTimeLoad parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CostTimeLoad = function (value) {
  pcmws.api.CostTimeLoad.base(this, 'constructor', 'costTimeLoad', value);
};
goog.inherits(pcmws.api.CostTimeLoad, pcmws.api.NumberParam);
goog.provide('pcmws.api.CountyCodes');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the CountyCodes parameter for a PCM service.
 *
 * This parameter gives the ordered list of stops with which to specify a route.
 *
 * @param {Array<string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.CountyCodes = function (values) {
  pcmws.api.CountyCodes.base(this, 'constructor', 'codes', values, ',');
};
goog.inherits(pcmws.api.CountyCodes, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.CurrentSpeed');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the CurrentSpeed parameter for a PCM service.
 *
 * This parameter specifies the CurrentSpeed measurement around the center in CurrentSpeedUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.CurrentSpeed = function (value) {
  pcmws.api.CurrentSpeed.base(this, 'constructor', 'currentSpeed', value);
};
goog.inherits(pcmws.api.CurrentSpeed, pcmws.api.NumberParam);
goog.provide('pcmws.api.CustomRoadSpeeds');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the CustomRoadSpeeds parameter for a PCM service.
 * @param {boolean|string=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.CustomRoadSpeeds = function (value) {
  pcmws.api.CustomRoadSpeeds.base(this, 'constructor', 'custRdSpeeds', value);
};
goog.inherits(pcmws.api.CustomRoadSpeeds, pcmws.api.BooleanParam);
goog.provide('pcmws.api.Countries');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the Countries parameter for a Single Search service.
 *
 * This parameter gives the ordered list of countries for the single search.
 *
 * @param {Array<string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.Countries = function (values) {
  pcmws.api.Countries.base(this, 'constructor', 'countries', values, ',');
};
goog.inherits(pcmws.api.Countries, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.CountryType');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the CountryType parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.CountryType = function (value) {
  pcmws.api.CountryType .base(this, 'constructor', 'countryType', value);
};
goog.inherits(pcmws.api.CountryType, pcmws.api.Param);
goog.provide('pcmws.val.Dataset');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive names for Dataset parameters.
 *
 * @enum {string}
 * 
 */
pcmws.val.Dataset = {
  /**  */
  Current: 'Current',
  /**  */
  PCM_EU: 'PCM_EU',
  /**  */
  PCM_OC: 'PCM_OC',
  /**  */
  PCM_SA: 'PCM_SA',
  /**  */
  PCM_GT: 'PCM_GT',
  /**  */
  PCM_AF: 'PCM_AF',
  /**  */
  PCM_AS: 'PCM_AS',
  /**  */
  PCM_ME: 'PCM_ME',
  /**  */
  PCM_SE: 'PCM_SE',
  /**  */
  PCM_NA: 'PCM_NA'
};
goog.provide('pcmws.api.Dataset');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.Dataset');

/**
 * @classdesc
 * An instance of this class contains the Dataset parameter.
 *
 * @param {pcmws.val.Dataset|string=} value Dataset Parameter Value
 * @extends {pcmws.api.Param}
 * @constructor
 *
 */
pcmws.api.Dataset = function (value) {
  pcmws.api.Dataset.base(this, 'constructor', 'dataset', value);
};
goog.inherits(pcmws.api.Dataset, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.Dataset}
 */
pcmws.api.Dataset.prototype.check = function (value) {
  return this.checkDataset(value);
};

/**
 * This method checks the value and returns the transformed and corrected
 * value of the parameter. The value could be '{dataset]' or some similar
 * replacement string.
 * TODO: Check against number values.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.Dataset}
 *
 */
pcmws.api.Dataset.prototype.checkDataset = function (value) {

  if (this.checkValue(value, pcmws.val.Dataset.Current, 0)) {
    return pcmws.val.Dataset.Current;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_EU, 1)) {
    return pcmws.val.Dataset.PCM_EU;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_OC, 2)) {
    return pcmws.val.Dataset.PCM_OC;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_SA, 3)) {
    return pcmws.val.Dataset.PCM_SA;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_GT, 4)) {
    return pcmws.val.Dataset.PCM_GT;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_AS, 5)) {
    return pcmws.val.Dataset.PCM_AS;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_ME, 6)) {
    return pcmws.val.Dataset.PCM_ME;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_SE, 7)) {
    return pcmws.val.Dataset.PCM_SE;
  }
  else if (this.checkValue(value, pcmws.val.Dataset.PCM_NA, 8)) {
    return pcmws.val.Dataset.PCM_NA;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal Dataset parameter value: " + value;
  }
  // If it's a number, make it a string.
  return '' + value;
};
goog.provide('pcmws.api.MultiValueEnumParam');

goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * This class handles multivalued parameters, which are realized as
 * strings separated with the specified separator, which is comma (,) as default.
 * @param {string} name The name of the parameter, such as 'PT1' or 'PT2'.
 * @param {Array<*>|string|undefined} values The value
 * @param {string} separator
 * @param {Object!} theEnum
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.MultiValueEnumParam = function (name, values, separator, theEnum) {
  pcmws.api.MultiValueEnumParam.base(this, 'constructor', name, values, separator);
  this.theEnum_ = theEnum;
};
goog.inherits(pcmws.api.MultiValueEnumParam, pcmws.api.MultivalueParam);

/**
 * @type {Object!}
 */
pcmws.api.MultiValueEnumParam.prototype.theEnum_;

/**
 * @inheritDoc
 * @this {pcmws.api.MultiValueEnumParam}
 */
pcmws.api.MultiValueEnumParam.prototype.checkEach = function (value) {
  return this.checkEnumValue(value);
};

/**
 * @description
 * This checks the validity of the value of this parameter against the values
 * for {@link pcmws.val.Param}.
 * TODO: Check against number values.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.MultiValueEnumParam}
 */
pcmws.api.MultiValueEnumParam.prototype.checkEnumValue = function (value) {
  var keys = Object.keys(this.theEnum_);
  for(var i = 0; i < keys.length; i++) {
    if (this.checkValue(value, this.theEnum_[keys[i]], i)) {
      return this.theEnum_[keys[i]];
    }
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal " + this.name + " parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.val.DrawerGroup');

goog.require('pcmws.val');
/**
 * @description
 * This object provides the definitive values for the DrawerGroup parameter.
 *
 * @enum {string}
 * 
 */
pcmws.val.DrawerGroup = {
  /**  */
  Cities: 'Cities',
  /**  */
  Labels: 'Labels',
  /**  */
  Roads: 'Roads',
  /**  */
  Commercial: 'Commercial',
  /**  */
  Borders: 'Borders',
  /**  */
  Areas: 'Areas'
};


goog.provide('pcmws.api.DrawerGroups');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultiValueEnumParam');
goog.require('pcmws.val.DrawerGroup');

/**
 * @classdesc
 * An instance of this class represents DrawerGroups parameter for a PCM service.
 * @param {Array.<pcmws.val.DrawerGroup>|string=} values
 * @constructor
 * @extends {pcmws.api.MultiValueEnumParam}
 *
 */
pcmws.api.DrawerGroups = function (values) {
  pcmws.api.DrawerGroups.base(this, 'constructor', 'drawerGroups', values, ',', pcmws.val.DrawerGroup);
};
goog.inherits(pcmws.api.DrawerGroups, pcmws.api.MultiValueEnumParam);
goog.provide('pcmws.api.ElevationLimit');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the ElevationLimit parameter for a PCM service.
 * Indicates the elevation limit when generating a route. Default value is null.
 * TODO: What does an ElevationLimit of null actually mean?
 * ElevationLimit is specified as rise above sea level, in feet or meters, in accordance with the DistanceUnits
 * parameter of Miles or Kilometers, respectively.
 *
 * Note: This parameter is only available in the {@link pcmws.val.Dataset.Current} or
 * {@link pcmws.val.Dataset.PCM_NA}. The ElevationLimit parameter will be ignored if
 * routing is deemed impractical with the limit, or a stop is located at an elevation
 * higher than the limit.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.ElevationLimit = function (value) {
  pcmws.api.ElevationLimit.base(this, 'constructor', 'elevLimit', value);
};
goog.inherits(pcmws.api.ElevationLimit, pcmws.api.NumberParam);
goog.provide('pcmws.api.EndTime');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class represents the EndTime parameter for a PCM service.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.EndTime = function (value) {
  pcmws.api.EndTime.base(this, 'constructor', 'endTime', value);
};
goog.inherits(pcmws.api.EndTime, pcmws.api.Param);
goog.provide('pcmws.api.EstimatedTimeOpts');

goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * This parameter holds the estimated time options for a PCM call. Its format is
 * (Depart|Arrive)'|'[DayOfWeek][SpecificDateTime][TimeOfDay][TimeZone].
 * Example:
 *    Depart|Monday|18:30
 * Example:
 *    Arrive|2014-03-04Y08:15:30
 * TODO: EstimatedTimeOpts, better parameters, and checking.
 * @param {string|undefined} value The value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.EstimatedTimeOpts = function (value) {
    pcmws.api.EstimatedTimeOpts.base(this, 'constructor', 'estimatedTimeOpts', value);
};
goog.inherits(pcmws.api.EstimatedTimeOpts, pcmws.api.Param);
goog.provide('pcmws.api.EventNames');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the EventNames parameter for a PCM service.
 *
 * This parameter specifies the values of class overrides.
 *
 * @param {Array.<string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.EventNames = function (values) {
  pcmws.api.EventNames.base(this, 'constructor', 'eventNames', values, ',');
};
goog.inherits(pcmws.api.EventNames, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.ExchangeRate');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the ExchangeRate parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.ExchangeRate = function (value) {
  pcmws.api.ExchangeRate.base(this, 'constructor', 'costTimeLoad', value);
};
goog.inherits(pcmws.api.ExchangeRate, pcmws.api.NumberParam);
goog.provide('pcmws.api.ExcludeSearchTypes');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the ExcludeSearchTypes parameter for a Single Search service.
 *
 * This parameter gives the ordered list of excludeSearchTypes for the single search.
 *
 * @param {Array<string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.ExcludeSearchTypes = function (values) {
  pcmws.api.ExcludeSearchTypes.base(this, 'constructor', 'excludeSearchTypes', values, ',');
};
goog.inherits(pcmws.api.ExcludeSearchTypes, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.FerryDiscourage');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the FerryDiscourage parameter for a PCM service.
 * This parameter indicates whether or not to discourage the use of ferries
 * when creating the route. The Default is false.
 * @param {boolean|string=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.FerryDiscourage = function (value) {
  pcmws.api.FerryDiscourage.base(this, 'constructor', 'ferryDiscourage', value);
};
goog.inherits(pcmws.api.FerryDiscourage, pcmws.api.BooleanParam);
goog.provide('pcmws.val.Format');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the Format parameter.
 *
 * @enum {string}
 * 
 */
pcmws.val.Format = {
  /**  */
  ImagePNG: 'image.png'
};
goog.provide('pcmws.api.Format');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.Format');

/**
 * @classdesc
 * An instance of this class represents the Format parameter in a PCM service.
 *
 * @param {pcmws.val.Format|string=} value
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.Format = function (value) {
  pcmws.api.Format.base(this, 'constructor', 'format', pcmws.val.Format, value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.Format, pcmws.api.EnumParam);
goog.provide('pcmws.api.FuelEconomyEmpty');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the FuelEconomyEmpty parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.FuelEconomyEmpty = function (value) {
  pcmws.api.FuelEconomyEmpty.base(this, 'constructor', 'fuelEconEmpty', value);
};
goog.inherits(pcmws.api.FuelEconomyEmpty, pcmws.api.NumberParam);
goog.provide('pcmws.api.FuelEconomyLoad');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the FuelEconomyLoad parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.FuelEconomyLoad = function (value) {
  pcmws.api.FuelEconomyLoad.base(this, 'constructor', 'fuelEconLoad', value);
};
goog.inherits(pcmws.api.FuelEconomyLoad, pcmws.api.NumberParam);
goog.provide('pcmws.val.FuelUnits');

goog.require('pcmws.val');

/**
 * @enum {string}
 * 
 */
pcmws.val.FuelUnits = {
  /**  */
  Gallons: "Gallons",
  /**  */
  Liters: "Liters"
};
goog.provide('pcmws.api.FuelUnits');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.FuelUnits');

/**
 * @classdesc
 * An instance of this class represents the FuelUnits parameter in a PCM service.
 *
 * @param {pcmws.val.FuelUnits|string=} value
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.FuelUnits = function (value) {
  pcmws.api.FuelUnits.base(this, 'constructor', 'fuelUnits', pcmws.val.FuelUnits, value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.FuelUnits, pcmws.api.EnumParam);
goog.provide('pcmws.api.GovernorSpeedLimit');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the GovernorSpeedLimit parameter for a PCM service.
 * This parameter specifies the maximum average road speed to use in the route
 * calculations that overrides all other road speeds when they are above this value.
 * The valid values are between 1-100 inclusive, and units are miles per hour. The default, i.e.
 * not specifying this parameter, means that the limit is disabled.
 * TODO: GovernorSpeedLimit Are values mph? or are they in accordance with DistanceUnits?
 * TODO: if in accordance with Kilometers is the upper limit 160?
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.GovernorSpeedLimit = function (value) {
  pcmws.api.GovernorSpeedLimit.base(this, 'constructor', 'governorSpeedLimit', value);
};
goog.inherits(pcmws.api.GovernorSpeedLimit, pcmws.api.NumberParam);
goog.provide('pcmws.val.HazMat');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the HazMat parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.HazMat = {
  /**  */
  None: 'None',
  /**  */
  General: 'General',
  /**  */
  Caustic: 'Caustic',
  /**  */
  Explosives: 'Explosives',
  /**  */
  Flammable: 'Flammable',
  /**  */
  Inhalants: 'Inhalants',
  /**  */
  Radioactive: 'Radioactive'
};
goog.provide('pcmws.api.HazMat');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.HazMat');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'HazMat' parameter in a PCM service.
 *
 * @param {pcmws.val.HazMat|number|string=} value The HazMat value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.HazMat = function (value) {
  pcmws.api.HazMat.base(this, 'constructor', 'hazMat', pcmws.val.HazMat, value);
};
goog.inherits(pcmws.api.HazMat, pcmws.api.EnumParam);
goog.provide('pcmws.api.Heading');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Heading parameter for a PCM service.
 *
 * This parameter specifies the Heading measurement around the center in HeadingUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Heading = function (value) {
  pcmws.api.Heading.base(this, 'constructor', 'heading', value);
};
goog.inherits(pcmws.api.Heading, pcmws.api.NumberParam);
goog.provide('pcmws.api.Height');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Height parameter for a PCM service.
 *
 * This parameter specifies the Height measurement around the center in HeightUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Height = function (value) {
  pcmws.api.Height.base(this, 'constructor', 'height', value);
};
goog.inherits(pcmws.api.Height, pcmws.api.NumberParam);
goog.provide('pcmws.api.HighwayOnly');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the HighwayOnly parameter for a PCM service.
 * @param {boolean|string=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.HighwayOnly = function (value) {
  pcmws.api.HighwayOnly.base(this, 'constructor', 'hwyOnly', value);
};
goog.inherits(pcmws.api.HighwayOnly, pcmws.api.BooleanParam);
goog.provide('pcmws.val.HistDay');

/**
 * @enum {string}
 */
pcmws.val.HistDay = {
  Monday: "Monday",
  Tuesday: "Tuesday",
  Wednesday: "Wednesday",
  Thursday: "Thursday",
  Friday: "Friday",
  Saturday: "Saturday",
  Sunday: "Sunday"
};
goog.provide('pcmws.api.HistDay');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.HistDay');

/**
 * @classdesc
 * An instance of this class represents the HistDay parameter for a PCM service.
 * Its value is a string naming the day of the week, which is in English.
 *
 * TODO: Check Number correspondence.
 * @param {pcmws.val.HistDay|string|number=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.HistDay = function (value) {
  pcmws.api.HistDay.base(this, 'constructor', 'histDay', value);
};
goog.inherits(pcmws.api.HistDay, pcmws.api.Param);

/**
 * @description
 * This function is used internally to check the validity of the value. Returns the value or undefined, or
 * possibly throws an exception based on the subtype.
 *
 * @param {*} value The value to check. Default is to pass through.
 * @returns {*}
 * @override
 * @this {pcmws.api.HistDay}
 */
pcmws.api.HistDay.prototype.check = function (value) {
  return this.checkHistDay(value);
};

/**
 * @description
 * This function checks the validity of the value for this parameter against
 * the values for {@link pcmws.val.HistDay}.
 * TODO: Check against number values.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.HistDay}
 */
pcmws.api.HistDay.prototype.checkHistDay = function (value) {

  if (this.checkValue(value, pcmws.val.HistDay.Monday, 1)) {
    return pcmws.val.HistDay.Monday;
  }
  else if (this.checkValue(value, pcmws.val.HistDay.Tuesday, 2)) {
    return pcmws.val.HistDay.Tuesday;
  }
  else if (this.checkValue(value, pcmws.val.HistDay.Wednesday, 3)) {
    return pcmws.val.HistDay.Wednesday;
  }
  else if (this.checkValue(value, pcmws.val.HistDay.Thursday, 4)) {
    return pcmws.val.HistDay.Thursday;
  }
  else if (this.checkValue(value, pcmws.val.HistDay.Friday, 5)) {
    return pcmws.val.HistDay.Friday;
  }
  else if (this.checkValue(value, pcmws.val.HistDay.Saturday, 6)) {
    return pcmws.val.HistDay.Saturday;
  }
  else if (this.checkValue(value, pcmws.val.HistDay.Sunday, 7)) {
    return pcmws.val.HistDay.Sunday;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal HistDay parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.api.HistTimeBin');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class represents the HistTimeBin parameter for a PCM service.
 * Its value represents on of the 15 minute blocks of time during the day.
 * There are 96 total 15 minute time bins for the day, beginning with midnight as 0.
 * Valid values are integers from 0.95. Some common time bin values are:
 *
 * * 0 - 12am
 * * 32 - 8am
 * * 48 - 12pm
 * * 68 - 5pm
 *
 * @param {string|number=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.HistTimeBin = function (value) {
  pcmws.api.HistTimeBin.base(this, 'constructor', 'HistTimeBin', value);
};
goog.inherits(pcmws.api.HistTimeBin, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.HistTimeBin}
 */
pcmws.api.HistTimeBin.prototype.check = function (value) {
  return this.checkHistTimeBin(value);
};

/**
 * @description
 * This function checks the validity of the value for this parameter.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.HistTimeBin}
 */
pcmws.api.HistTimeBin.prototype.checkHistTimeBin = function (value) {

  if (typeof value === 'number') {
    if (0 <= value && value <= 95) {
      return '' + value;
    }
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal HistTimeBin parameter value: " + value;
  }
  // If it's a number, make it a string.
  return '' + value;
};
goog.provide('pcmws.api.HistTimeZone');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class represents the HistTimeZone parameter for a PCM service.
 * Its value is a string representing the ISO 8601 time zone offset. The colon between
 * the hours and minutes is required. Some common time zone offsets are:
 *
 * * -04:00 - Eastern Daylight Time
 * * -07:00 - Pacific Daylight Time
 * * -08:00 - Pacific Standard Time
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.HistTimeZone = function (value) {
  pcmws.api.HistTimeZone.base(this, 'constructor', 'HistTimeZone', value);
};
goog.inherits(pcmws.api.HistTimeZone, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.HistTimeZone}
 */
pcmws.api.HistTimeZone.prototype.check = function (value) {
  return this.checkHistTimeZone(value);
};

/**
 * @description
 * This function checks the validity of the value for this parameter.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.HistTimeZone}
 */
pcmws.api.HistTimeZone.prototype.checkHistTimeZone = function (value) {

  if (new RegExp('-?[01]?[0-9]:[0-9][0-9]').test(value)) {
    return /** @type {string} */ (value);
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal HistTimeZone parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.api.HosEnabled');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the HosEnabled parameter for a PCM service.
 * This parameter enables the the insertion of Hours of Service Stops.
 * @param {boolean|string=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.HosEnabled = function (value) {
  pcmws.api.HosEnabled.base(this, 'constructor', 'hosEnabled', value);
};
goog.inherits(pcmws.api.HosEnabled, pcmws.api.BooleanParam);
goog.provide('pcmws.api.HosRemCycleDutyTime');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the HosRemCycleDutyTime parameter for a PCM service.
 * This parameter specifies the available cycle time duty hours at the origin until the
 * cycle resets.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.HosRemCycleDutyTime = function (value) {
  pcmws.api.HosRemCycleDutyTime.base(this, 'constructor', 'hosRemCycleDutyTime', value);
};
goog.inherits(pcmws.api.HosRemCycleDutyTime, pcmws.api.NumberParam);
goog.provide('pcmws.api.HosRemDriveTime');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the HosRemDriveTime parameter for a PCM service.
 * This parameter specifies the available driving hours at the origin before the end
 * of the work day.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.HosRemDriveTime = function (value) {
  pcmws.api.HosRemDriveTime.base(this, 'constructor', 'hosRemDriveTime', value);
};
goog.inherits(pcmws.api.HosRemDriveTime, pcmws.api.NumberParam);
goog.provide('pcmws.api.HosRemDriveTimeUntilBreak');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the HosRemDriveTimeUntilBreak parameter for a PCM service.
 * This parameter specifies the available driving hours at the origin before the driver
 * needs to take a rest break.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.HosRemDriveTimeUntilBreak = function (value) {
  pcmws.api.HosRemDriveTimeUntilBreak.base(this, 'constructor', 'hosRemDriveTimeUntilBreak', value);
};
goog.inherits(pcmws.api.HosRemDriveTimeUntilBreak, pcmws.api.NumberParam);
goog.provide('pcmws.api.HosRemOnDutyTime');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the HosRemOnDutyTime parameter for a PCM service.
 * This parameter specifies the available on-duty hours at the origin until the end
 * of the work day.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.HosRemOnDutyTime = function (value) {
  pcmws.api.HosRemOnDutyTime.base(this, 'constructor', 'hosRemDriveTimeUntilBreak', value);
};
goog.inherits(pcmws.api.HosRemOnDutyTime, pcmws.api.NumberParam);
goog.provide('pcmws.api.HourOffset');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the HourOffset parameter for a PCM service.
 *
 * This parameter specifies the HourOffset measurement around the center in HourOffsetUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.HourOffset = function (value) {
  pcmws.api.HourOffset.base(this, 'constructor', 'hourOffset', value);
};
goog.inherits(pcmws.api.HourOffset, pcmws.api.NumberParam);
goog.provide('pcmws.api.HubRouting');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the HubRouting parameter for a PCM service.
 *
 * This parameter indicates whether or not to enable hub routing when creating a route.
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.HubRouting = function (value) {
  pcmws.api.HubRouting.base(this, 'constructor', 'hubRouting', value);
};
goog.inherits(pcmws.api.HubRouting, pcmws.api.BooleanParam);
goog.provide('pcmws.api.Identifier');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the Identifier parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Identifier = function (value) {
  pcmws.api.Identifier .base(this, 'constructor', 'id', value);
};
goog.inherits(pcmws.api.Identifier, pcmws.api.Param);
goog.provide('pcmws.val.ImgOption');

goog.require('pcmws.val');
/**
 * @description
 * This object provides the definitive values for the ImgOption parameter.
 *
 * @enum {string}
 * 
 */
pcmws.val.ImgOption = {
  /**  */
  Background: 'Background',
  /**  */
  Foreground: 'Foreground',
  /**  */
  Both: 'Both'
};
goog.provide('pcmws.api.ImgOption');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.ImgOption');

/**
 * @classdesc
 * An instance of this class represents the ImgOption parameter for a PCM service.
 *
 * @param {pcmws.val.ImgOption|string|number=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.ImgOption = function (value) {
  pcmws.api.ImgOption.base(this, 'constructor', 'imgOption', value);
};
goog.inherits(pcmws.api.ImgOption, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.ImgOption}
 */
pcmws.api.ImgOption.prototype.check = function (value) {
  return this.checkImgOption(value);
};

/**
 * @description
 * This function checks the validity of the value for this parameter against
 * the values for {@link pcmws.val.ImgOption}.
 * TODO: Check against number values.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.ImgOption}
 */
pcmws.api.ImgOption.prototype.checkImgOption = function (value) {

  if (this.checkValue(value, pcmws.val.ImgOption.Background, 0)) {
    return pcmws.val.ImgOption.Background;
  }
  else if (this.checkValue(value, pcmws.val.ImgOption.Foreground, 1)) {
    return pcmws.val.ImgOption.Foreground;
  }
  else if (this.checkValue(value, pcmws.val.ImgOption.Both, 2)) {
    return pcmws.val.ImgOption.Both;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal ImgOption parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.val.ImgSrc');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the ImgSrc parameter.
 *
 * @enum {string}
 * 
 */
pcmws.val.ImgSrc = {
  /**  */
  Default: 'Default',
  /**  */
  ALKCurated: 'ALKCurated',
  /**  */
  Sat1: 'Sat1',
  /**  */
  Sat2: 'Sat2',
  /**  */
  Sat3: 'Sat3',
  /**  */
  Sat4: 'Sat4',
  /**  */
  Sat5: 'Sat5',
  /**  */
  Sat6: 'Sat6'
};
goog.provide('pcmws.api.ImgSrc');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.ImgSrc');

/**
 * @classdesc
 * An instance of this class represents the ImgSrc parameter for a PCM service.
 * @param {pcmws.val.ImgSrc|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.ImgSrc = function (value) {
  pcmws.api.ImgSrc.base(this, 'constructor', 'imgSrc', value);
};
goog.inherits(pcmws.api.ImgSrc, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.ImgSrc}
 */
pcmws.api.ImgSrc.prototype.check = function (value) {
  return this.checkImgSrc(value);
};

/**
 * @description
 * Checks the validity of a value for @link pcmws.val.ImgSrc values.
 * TODO: Check against number values.
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.ImgSrc}
 */
pcmws.api.ImgSrc.prototype.checkImgSrc = function (value) {
  if (this.checkValue(value, pcmws.val.ImgSrc.Default, 0)) {
    return pcmws.val.ImgSrc.Default;
  }
  else if (this.checkValue(value, pcmws.val.ImgSrc.ALKCurated, 1)) {
    return pcmws.val.ImgSrc.ALKCurated;
  }
  else if (this.checkValue(value, pcmws.val.ImgSrc.Sat1, 2)) {
    return pcmws.val.ImgSrc.Sat1;
  }
  else if (this.checkValue(value, pcmws.val.ImgSrc.Sat2, 3)) {
    return pcmws.val.ImgSrc.Sat2;
  }
  else if (this.checkValue(value, pcmws.val.ImgSrc.Sat3, 4)) {
    return pcmws.val.ImgSrc.Sat3;
  }
  else if (this.checkValue(value, pcmws.val.ImgSrc.Sat4, 5)) {
    return pcmws.val.ImgSrc.Sat4;
  }
  else if (this.checkValue(value, pcmws.val.ImgSrc.Sat5, 6)) {
    return pcmws.val.ImgSrc.Sat5;
  }
  else if (this.checkValue(value, pcmws.val.ImgSrc.Sat6, 7)) {
    return pcmws.val.ImgSrc.Sat6;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal ImgSrc parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.api.IncludeFerryDistance');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the IncludeFerryDistance parameter for a PCM service.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.IncludeFerryDistance = function (value) {
  pcmws.api.IncludeFerryDistance.base(this, 'constructor', 'inclTollData', value);
};
goog.inherits(pcmws.api.IncludeFerryDistance, pcmws.api.BooleanParam);
goog.provide('pcmws.api.IncludeLinkInfo');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the IncludeLinkInfo parameter for a PCM service.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.IncludeLinkInfo = function (value) {
  pcmws.api.IncludeLinkInfo.base(this, 'constructor', 'includeLinkInfo', value);
};
goog.inherits(pcmws.api.IncludeLinkInfo, pcmws.api.BooleanParam);
goog.provide('pcmws.api.IncludePostedSpeedLimit');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the IncludePostedSpeedLimit parameter for a PCM service.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.IncludePostedSpeedLimit = function (value) {
  pcmws.api.IncludePostedSpeedLimit.base(this, 'constructor', 'includePostedSpeedLimit', value);
};
goog.inherits(pcmws.api.IncludePostedSpeedLimit, pcmws.api.BooleanParam);
goog.provide('pcmws.api.IncludeTollData');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the IncludeTollData parameter for a PCM service.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.IncludeTollData = function (value) {
  pcmws.api.IncludeTollData.base(this, 'constructor', 'inclTollData', value);
};
goog.inherits(pcmws.api.IncludeTollData, pcmws.api.BooleanParam);
goog.provide("pcmws.val.Language");

goog.require('pcmws.val');

/**
 * @enum {string}
 * 
 */
pcmws.val.Language = {
  /**  */
  ENUS: "ENUS",
  /**  */
  ENGB: "ENGB",
  /**  */
  DE: "DE",
  /**  */
  FR: "FR",
  /**  */
  ES: "ES",
  /**  */
  IT: "IT"
};
goog.provide('pcmws.api.Language');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.Language');

/**
 * @classdesc
 * An instance of this class represents the Language parameter in a PCM service.
 *
 * @param {pcmws.val.Language|string=} value
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.Language = function (value) {
  pcmws.api.Language.base(this, 'constructor', 'lang', pcmws.val.Language, value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.Language, pcmws.api.EnumParam);
goog.provide('pcmws.api.LCV');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'LCV' parameter in a PCM service.
 *
 * This parameter specifies whether or not the vehicle is a multi-trailer or
 * longer combination vehicle.
 *
 * @param {boolean|number|string=} value The LCV value for this parameter.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.LCV = function (value) {
  pcmws.api.LCV.base(this, 'constructor', 'lcv', value);
};
goog.inherits(pcmws.api.LCV, pcmws.api.BooleanParam);
goog.provide('pcmws.api.List');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the List parameter for a PCM service.
 *
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.List = function (value) {
  pcmws.api.List.base(this, 'constructor', 'list', value);
};
goog.inherits(pcmws.api.List, pcmws.api.NumberParam);
goog.provide('pcmws.api.MatchNamedRoadsOnly');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the MatchNamedRoadsOnly parameter for a PCM service.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.MatchNamedRoadsOnly = function (value) {
  pcmws.api.MatchNamedRoadsOnly.base(this, 'constructor', 'matchNamedRoadsOnly', value);
};
goog.inherits(pcmws.api.MatchNamedRoadsOnly, pcmws.api.BooleanParam);
goog.provide('pcmws.api.MaxCleanupMiles');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the MaxCleanupMiles parameter for a PCM service.
 *
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.MaxCleanupMiles = function (value) {
  pcmws.api.MaxCleanupMiles.base(this, 'constructor', 'maxCleanupMiles', value);
};
goog.inherits(pcmws.api.MaxCleanupMiles, pcmws.api.NumberParam);
goog.provide('pcmws.api.MaxResults');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the MaxResults parameter for a Single Search service.
 *
 * This parameter specifies the maximum results to return.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.MaxResults = function (value) {
  pcmws.api.MaxResults.base(this, 'constructor', 'maxResults', value);
};
goog.inherits(pcmws.api.MaxResults, pcmws.api.NumberParam);
goog.provide('pcmws.api.Minutes');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Minutes parameter for a PCM service.
 *
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Minutes = function (value) {
  pcmws.api.Minutes.base(this, 'constructor', 'minutes', value);
};
goog.inherits(pcmws.api.Minutes, pcmws.api.NumberParam);
goog.provide('pcmws.api.NameFilter');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the NameFilter parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.NameFilter = function (value) {
  pcmws.api.NameFilter .base(this, 'constructor', 'nameFilter', value);
};
goog.inherits(pcmws.api.NameFilter, pcmws.api.Param);
goog.provide('pcmws.api.OpenBorders');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the OpenBorders parameter for a PCM service.
 *
 * This parameter specifies whether or not borders are open for travel.
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.OpenBorders = function (value) {
  pcmws.api.OpenBorders.base(this, 'constructor', 'openBorders', value);
};
goog.inherits(pcmws.api.OpenBorders, pcmws.api.BooleanParam);
goog.provide('pcmws.val.OverrideClass');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the OverrideClass parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.OverrideClass = {
  /**  */
  NationalNetwork: 'NationalNetwork',
  /**  */
  FiftyThreeFoot: 'FiftyThreeFoot'
};
goog.provide('pcmws.api.OverrideClass');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');
goog.require('pcmws.val.OverrideClass');

/**
 * @classdesc
 * An instance of this class represents the OverrideClass parameter for a PCM service.
 *
 * This parameter specifies the values of class overrides.
 *
 * @param {Array<pcmws.val.OverrideClass|string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.OverrideClass = function (values) {
  pcmws.api.OverrideClass.base(this, 'constructor', 'overrideClass', values, ',');
};
goog.inherits(pcmws.api.OverrideClass, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.OverrideRestrict');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the OverrideRestrict parameter for a PCM service.
 *
 * This parameter indicates whether or not to override truck restrictions.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.OverrideRestrict = function (value) {
  pcmws.api.OverrideRestrict.base(this, 'constructor', 'overrideRestrict', value);
};
goog.inherits(pcmws.api.OverrideRestrict, pcmws.api.BooleanParam);
goog.provide('pcmws.api.PenWidth');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the PenWidth parameter for a PCM service.
 *
 * This parameter specifies the PenWidth measurement in pixels.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.PenWidth = function (value) {
  pcmws.api.PenWidth.base(this, 'constructor', 'penWidth', value);
};
goog.inherits(pcmws.api.PenWidth, pcmws.api.NumberParam);
goog.provide('pcmws.val.POICategory');

/**
 * @enum {string}
 */
pcmws.val.POICategory = {
  /**  */
  All: 'All',
  /**  */
  City: 'City',
  /**  */
  Zip: 'Zip',
  /**  */
  Place: 'Place',
  /**  */
  Airport: 'Airport',
  /**  */
  Automotive: 'Automotive',
  /**  */
  WeighStation: 'WeighStation',
  /**  */
  Dining: 'Dining',
  /**  */
  Education: 'Education',
  /**  */
  Emergency: 'Emergency',
  /**  */
  Government: 'Government',
  /**  */
  Gas: 'Gas',
  /**  */
  Lodging: 'Lodging',
  /**  */
  Parks: 'Parks',
  /**  */
  Retail: 'Retail',
  /**  */
  RVServices: 'RVServices',
  /**  */
  SportsRec: 'SportsRec',
  /**  */
  Travel: 'Travel',
  /**  */
  TruckServices: 'TruckServices',
  /**  */
  Attractions: 'Attractions'
};
goog.provide('pcmws.api.POICategories');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultiValueEnumParam');
goog.require('pcmws.val.POICategory');

/**
 * @classdesc
 * An instance of this class represents POICategories parameter for a the PCM POI service.
 *
 * @param {Array.<pcmws.val.POICategory|string>|string=} values
 * @constructor
 * @extends {pcmws.api.MultiValueEnumParam}
 *
 */
pcmws.api.POICategories = function (values) {
  pcmws.api.POICategories.base(this, 'constructor', 'poiCategories', values, ',', pcmws.val.POICategory);
};
goog.inherits(pcmws.api.POICategories, pcmws.api.MultiValueEnumParam);
goog.provide('pcmws.api.Point');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.LonLat');

/**
 * @classdesc
 * An instance of this class represents the Point parameter for a PCM service.
 *
 * @param {Array.<number>|string=} value The coordinate.
 * @constructor
 * @extends {pcmws.api.LonLat}
 *
 */
pcmws.api.Point = function (value) {
  pcmws.api.Point.base(this, 'constructor', 'point', value);
};
goog.inherits(pcmws.api.Point, pcmws.api.LonLat);
goog.provide('pcmws.api.PostCode');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the PostCode parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.PostCode = function (value) {
  pcmws.api.PostCode .base(this, 'constructor', 'postCode', value);
};
goog.inherits(pcmws.api.PostCode, pcmws.api.Param);
goog.provide('pcmws.api.PostCodeFilter');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the PostCodeFilter parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.PostCodeFilter = function (value) {
  pcmws.api.PostCodeFilter .base(this, 'constructor', 'postCodeFilter', value);
};
goog.inherits(pcmws.api.PostCodeFilter, pcmws.api.Param);
goog.provide('pcmws.val.Provider');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the Provider parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.Provider = {
  /**  */
 Default: 'Default',
  /**  */
 RC1: 'RC1'
};
goog.provide('pcmws.api.Provider');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.Provider');

/**
 * @classdesc
 * An instance of this class represents the Provider parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.Provider = function (value) {
  pcmws.api.Provider.base(this, 'constructor', 'provider', pcmws.val.Provider, value);
};
goog.inherits(pcmws.api.Provider, pcmws.api.EnumParam);
goog.provide('pcmws.api.PT1');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.LonLat');

/**
 * @classdesc
 * An instance of this class represents the PT1 parameter for a PCM service.
 *
 * @param {Array.<number>|string=} value The coordinate.
 * @constructor
 * @extends {pcmws.api.LonLat}
 *
 */
pcmws.api.PT1 = function (value) {
  pcmws.api.PT1.base(this, 'constructor', 'PT1', value);
};
goog.inherits(pcmws.api.PT1, pcmws.api.LonLat);
goog.provide('pcmws.api.PT2');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.LonLat');

/**
 * @classdesc
 * An instance of this class represents the PT2 parameter for a PCM service.
 *
 * @param {Array.<number>|string=} value The coordinate.
 * @constructor
 * @extends {pcmws.api.LonLat}
 *
 */
pcmws.api.PT2 = function (value) {
  pcmws.api.PT2.base(this, 'constructor', 'PT2', value);
};
goog.inherits(pcmws.api.PT2, pcmws.api.LonLat);
goog.provide('pcmws.api.Query');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the Query parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Query = function (value) {
  pcmws.api.Query .base(this, 'constructor', 'query', value);
};
goog.inherits(pcmws.api.Query, pcmws.api.Param);
goog.provide('pcmws.api.Radius');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Radius parameter for a PCM service.
 *
 * This parameter specifies the radius measurement around the center in radiusUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Radius = function (value) {
  pcmws.api.Radius.base(this, 'constructor', 'radius', value);
};
goog.inherits(pcmws.api.Radius, pcmws.api.NumberParam);
goog.provide('pcmws.api.RadiusUnits');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.DistanceUnits');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'radiusUnits' parameter in a PCM service.
 *
 * This parameter specifies whether the units that measure distance are in miles or kilometers.
 * @param {pcmws.val.DistanceUnits|number|string=} value The RadiusUnits value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.RadiusUnits = function (value) {
  pcmws.api.RadiusUnits.base(this, 'constructor', 'radiusUnits', pcmws.val.DistanceUnits, value);
};
goog.inherits(pcmws.api.RadiusUnits, pcmws.api.EnumParam);
goog.provide('pcmws.api.RemainingHoursOfService');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the RemainingHoursOfService parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.RemainingHoursOfService = function (value) {
  pcmws.api.RemainingHoursOfService.base(this, 'constructor', 'remHrsOfSvc', value);
};
goog.inherits(pcmws.api.RemainingHoursOfService, pcmws.api.NumberParam);
goog.provide('pcmws.val.ReportFormat');

goog.require('pcmws.val');

/**
 * @enum {string}
 * 
 */
pcmws.val.ReportFormat = {
  /**  */
  JSON: "JSON"
};
goog.provide('pcmws.api.ReportFormat');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.ReportFormat');

/**
 * @classdesc
 * An instance of this class represents the ReportFormat parameter in a PCM service.
 *
 * @param {pcmws.val.ReportFormat|string=} value
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.ReportFormat = function (value) {
  pcmws.api.ReportFormat.base(this, 'constructor', 'reportFmt', pcmws.val.ReportFormat, value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.ReportFormat, pcmws.api.EnumParam);
goog.provide('pcmws.val.Report');

goog.require('pcmws.val');
/**
 * @enum {string}
 * 
 */
pcmws.val.Report = {
  /**  */
  CalcMiles: "CalcMiles",
  /**  */
  Mileage: "Mileage",
  /**  */
  Directions: "Directions",
  /**  */
  State: "State",
  /**  */
  Detail: "Detail",
  /**  */
  Road: "Road",
  /**  */
  GeoTunnel: "GeoTunnel"
};
goog.provide('pcmws.api.Reports');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultiValueEnumParam');
goog.require('pcmws.val.Report');

/**
 * @classdesc
 * An instance of this class represents Reports parameter for a PCM service.
 * @param {Array.<pcmws.val.Report>|string=} values
 * @constructor
 * @extends {pcmws.api.MultiValueEnumParam}
 *
 */
pcmws.api.Reports = function (values) {
  pcmws.api.Reports.base(this, 'constructor', 'reports', values, ',', pcmws.val.Report);
};
goog.inherits(pcmws.api.Reports, pcmws.api.MultiValueEnumParam);
goog.provide('pcmws.api.Resolution');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Resolution parameter for a PCM service.
 *
 * This parameter specifies the Resolution measurement around the center in ResolutionUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Resolution = function (value) {
  pcmws.api.Resolution.base(this, 'constructor', 'resolution', value);
};
goog.inherits(pcmws.api.Resolution, pcmws.api.NumberParam);
goog.provide('pcmws.api.RouteId');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the RouteId parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.RouteId = function (value) {
  pcmws.api.RouteId .base(this, 'constructor', 'routeId', value);
};
goog.inherits(pcmws.api.RouteId, pcmws.api.Param);
goog.provide('pcmws.api.RouteDuration');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the RouteDuration parameter for a PCM service.
 *
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.RouteDuration = function (value) {
  pcmws.api.RouteDuration.base(this, 'constructor', 'routeDuration', value);
};
goog.inherits(pcmws.api.RouteDuration, pcmws.api.NumberParam);
goog.provide('pcmws.val.RouteOptimization');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the RouteOptimization parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.RouteOptimization = {
  /**  */
  None: 'None',
  /**  */
  ThruAll: 'ThruAll',
  /**  */
  DestinationFixed: 'DestinationFixed'
};
goog.provide('pcmws.api.RouteOptimization');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.RouteOptimization');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'RouteOptimization' parameter in a PCM service.
 *
 * This parameter specifies the method by which to optimize the route stops.
 *
 * @param {pcmws.val.RouteOptimization|number|string=} value The RouteOptimization value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.RouteOptimization = function (value) {
  pcmws.api.RouteOptimization.base(this, 'constructor', 'routeOpt', pcmws.val.RouteOptimization, value);
};
goog.inherits(pcmws.api.RouteOptimization, pcmws.api.EnumParam);
goog.provide('pcmws.api.RoutePath');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the RoutePath parameter for a PCM service.
 *
 * This parameter gives the ordered list of RoutePath with which to specify a route.
 *
 * @param {Array.<Array.<number>>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.RoutePath = function (values) {
  pcmws.api.RoutePath.base(this, 'constructor', 'routePath', values);
};
goog.inherits(pcmws.api.RoutePath, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.RoutePathRequest');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

goog.require('pcmws.route.RoutePathRequest');

/**
 * @classdesc
 * An instance of this class represents the RoutePathRequest parameter for a PCM service.
 *
 * @param {pcmws.route.RoutePathRequest|string=} value The coordinate.
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.RoutePathRequest = function (value) {
  pcmws.api.RoutePathRequest.base(this, 'constructor', 'routePathRequest', value);
};
goog.inherits(pcmws.api.RoutePathRequest, pcmws.api.Param);
goog.provide('pcmws.val.RouteType');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the RouteType parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.RouteType = {
  /**  */
  Practical: 'Practical',
  /**  */
  Shortest: 'Shortest'
};
goog.provide('pcmws.api.RouteType');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.RouteType');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'RouteType' parameter in a PCM service.
 *
 * This parameter specifies the algorithm to use to generate the route.
 *
 * @param {pcmws.val.RouteType|number|string=} value The RouteType value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.RouteType = function (value) {
  pcmws.api.RouteType.base(this, 'constructor', 'routeType', pcmws.val.RouteType, value);
};
goog.inherits(pcmws.api.RouteType, pcmws.api.EnumParam);
goog.provide('pcmws.api.SetId');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the SetId parameter for a PCM service.
 *
 * This parameter specifies the SetId.
 * @param {number|string=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.SetId = function (value) {
  pcmws.api.SetId.base(this, 'constructor', 'setId', value);
};
goog.inherits(pcmws.api.SetId, pcmws.api.NumberParam);
goog.provide('pcmws.val.Severity');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the Severity parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.Severity = {
  /**  */
 All: 'All',
  /**  */
 Extreme: 'Extreme',
  /**  */
 Severe: 'Severe',
  /**  */
 Moderate: 'Moderate',
  /**  */
 Minor: 'Minor',
  /**  */
 Unknown: 'Unknown'
};
goog.provide('pcmws.api.Severity');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.Severity');

/**
 * @classdesc
 * An instance of this class represents the Severity parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.Severity = function (value) {
  pcmws.api.Severity.base(this, 'constructor', 'severity', pcmws.val.Severity, value);
};
goog.inherits(pcmws.api.Severity, pcmws.api.EnumParam);
goog.provide('pcmws.api.SideOfStreetAdherence');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the SideOfStreetAdherence parameter for a PCM service.
 *
 * This parameter specifies how strict to be in order to avoid the destination being on the
 * opposite side of the street.
 * TODO: SideOfStreetAdherence values? document.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.SideOfStreetAdherence = function (value) {
  pcmws.api.SideOfStreetAdherence.base(this, 'constructor', 'sideOfStreetAdherence', value);
};
goog.inherits(pcmws.api.SideOfStreetAdherence, pcmws.api.NumberParam);
goog.provide('pcmws.api.Splc');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the Splc parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Splc = function (value) {
  pcmws.api.Splc .base(this, 'constructor', 'splc', value);
};
goog.inherits(pcmws.api.Splc, pcmws.api.Param);
goog.provide('pcmws.api.SRS');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.SRS');

/**
 * @classdesc
 * An instance of this class contains the value for the SRS (projection) parameter for a PCM service.
 *
 * This parameter specifies the projection.
 *
 * @param {pcmws.val.SRS|string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.SRS = function (value) {
  pcmws.api.SRS.base(this, 'constructor', 'SRS', value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.SRS, pcmws.api.Param);

/**
 * @inheritDoc
 * @this {pcmws.api.SRS}
 */
pcmws.api.SRS.prototype.check = function (value) {
  return this.checkSRS(value);
};

/**
 * @description
 * Checks the validity of the value to this parameter.
 *
 * @param {*}  value The value to be checked against
 * @returns {string|undefined}
 * @this {pcmws.api.SRS}
 * TODO: Check against number values.
 */
pcmws.api.SRS.prototype.checkSRS = function (value) {

  if (this.checkValue(value, pcmws.val.SRS.EPSG900913, 0)) {
    return pcmws.val.SRS.EPSG900913;
  }
  else if (this.checkValue(value, pcmws.val.SRS.EPSG4326, 1)) {
    return pcmws.val.SRS.EPSG4326;
  }
  else if (this.checkValue(value, pcmws.val.SRS.EPSG3857, 2)) {
    return pcmws.val.SRS.EPSG3857;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal SRS parameter value: " + value;
  }
  // If it's a number, make it a string.
  return '' + value;
};
goog.provide('pcmws.api.StartTime');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class represents the StartTime parameter for a PCM service.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.StartTime = function (value) {
  pcmws.api.StartTime.base(this, 'constructor', 'startTime', value);
};
goog.inherits(pcmws.api.StartTime, pcmws.api.Param);
goog.provide('pcmws.api.State');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the State parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.State = function (value) {
  pcmws.api.State .base(this, 'constructor', 'state', value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.State, pcmws.api.Param);
goog.provide('pcmws.api.States');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the States parameter for a Single Search service.
 *
 * This parameter gives the ordered list of states for the single search.
 *
 * @param {Array<string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.States = function (values) {
  pcmws.api.States.base(this, 'constructor', 'states', values, ',');
};
goog.inherits(pcmws.api.States, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.StopCosts');


goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the StopCosts parameter for a PCM service.
 *
 * This parameter specifies the values of class overrides.
 *
 * @param {Array.<pcmws.api.StopCost|string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.StopCosts = function (values) {
  pcmws.api.StopCosts.base(this, 'constructor', 'StopCosts', values, '|');
};
goog.inherits(pcmws.api.StopCosts, pcmws.api.MultivalueParam);

/**
 * @returns {string|undefined}
 * @this {pcmws.api.StopCosts}
 * @override
 */
pcmws.api.StopCosts.prototype.getCheckedStringValue = function () {
  var values = this.getCheckedValue();
  var nvalues;
  if (values) {
    if (values instanceof Array) {
      var res = [];
      for(var i = 0; i < values.length; i++) {
        var stopCost = values[i];
        if (typeof stopCost === 'string') {
          // We are fine.
          res.push(stopCost);
        } else {
          var sc = "";
          sc += parseFloat(JSON.stringify(stopCost.cost));
          sc += ',' + parseFloat(JSON.stringify(stopCost.hours));
          sc += ',' + !!stopCost.loaded;
          sc += ',' + !!stopCost.onDuty;
          sc += ',' + !!stopCost.useOrigin;
          res.push(sc);
        }
      }
      nvalues = res.join(this.separator);
    }
  }
  return nvalues;
};

/**
 * @inheritDoc
 */
pcmws.api.StopCosts.prototype.check = function (values) {
  var res = [];
  if (values) {
    for(var i = 0; i < values.length; i++) {
      var stopCost = values[i].split(',');
      res.push({
        cost: stopCost[0],
        hours: stopCost[1],
        loaded: stopCost[2],
        onDuty: stopCost[3],
        useOrigin: stopCost[4]
      });
    }
  }
  return res;
};
goog.provide('pcmws.api.Stops');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the Stops parameter for a PCM service.
 *
 * This parameter gives the ordered list of stops with which to specify a route.
 *
 * @param {Array<Array<number>|string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.Stops = function (values) {
  pcmws.api.Stops.base(this, 'constructor', 'stops', values, ';');
};
goog.inherits(pcmws.api.Stops, pcmws.api.MultivalueParam);


/**
 * @param {*} value
 * @returns {*}
 * @override
 */
pcmws.api.Stops.prototype.checkEach = function (value) {
  if (typeof value === 'string') {
    var lonlat = value.split(',');
    return [parseFloat(lonlat[0]), parseFloat(lonlat[1])];
  } else if (value instanceof Array) {
    return value;
  }
  return undefined;
};

/**
 * @inheritDoc
 * @this {pcmws.api.Stops}
 */
pcmws.api.Stops.prototype.getCheckedStringValue = function () {
  var values = this.getCheckedValue();
  var nvalues;
  if (values) {
    if (values instanceof Array) {
      var res = [];
      for(var i = 0; i < values.length; i++) {
        var lonlat = values[i];
        if (typeof lonlat === 'string') {
          // We are fine.
          res.push(lonlat);
        } else if (lonlat instanceof Array) {
          var sc = "";
          sc += typeof lonlat[0] === 'number' ? lonlat[0] : parseFloat(lonlat[0]);
          sc += ',';
          sc += typeof lonlat[1] === 'number' ? lonlat[1] : parseFloat(lonlat[1]);
          res.push(sc);
        }
      }
      nvalues = res.join(this.separator);
    }
    return nvalues;
  }
};
goog.provide('pcmws.api.StopsAsViaPoints');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the StopsAsViaPoints parameter for a PCM service.
 *
 * This parameter forces all stops between the first and last to be treated as via points.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.StopsAsViaPoints = function (value) {
  pcmws.api.StopsAsViaPoints.base(this, 'constructor', 'stopsAsViaPoints', value);
};
goog.inherits(pcmws.api.StopsAsViaPoints, pcmws.api.BooleanParam);
goog.provide('pcmws.api.StrokeWidth');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the StrokeWidth parameter for a PCM service.
 *
 * This parameter specifies the StrokeWidth measurement around the center in StrokeWidthUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.StrokeWidth = function (value) {
  pcmws.api.StrokeWidth.base(this, 'constructor', 'strokeWidth', value);
};
goog.inherits(pcmws.api.StrokeWidth, pcmws.api.NumberParam);
goog.provide('pcmws.val.Style');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the Style parameter;
 *
 * @enum {string}
 *
 */
pcmws.val.Style = {
  /**  */
  Transportation: 'transportation',
  /**  */
  DataDark: 'datadark',
  /**  */
  DataLight: 'datalight',
  /**  */
  Basic: 'basic',
  /**  */
  Default: 'Default',
  /**  */
  Classic: 'Classic',
  /**  */
  Monochrome: 'Monochrome',
  /**  */
  RoadAtlas: 'RoadAtlas',
  /**  */
  Night: 'Night',
  /**  */
  Satellite: 'Satellite',
  /**  */
  Lightness: 'Lightness',
  /**  */
  Smooth: 'Smooth',
  /**  */
  Terrain: 'Terrain',
  /**  */
  Modern: 'Modern'
};
goog.provide('pcmws.api.Style');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.Style');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the Style parameter in a PCM service.
 *
 * @param {pcmws.val.Style|number|string=} value The Style value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.Style = function (value) {
  pcmws.api.Style.base(this, 'constructor', 'style', pcmws.val.Style, value);
};
goog.inherits(pcmws.api.Style, pcmws.api.EnumParam);
goog.provide('pcmws.api.THoursWithSeconds');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the THoursWithSeconds parameter for a PCM service.
 *
 * This parameter specifies whether or not to use traffic as a condition of generating a route.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.THoursWithSeconds = function (value) {
  pcmws.api.THoursWithSeconds.base(this, 'constructor', 'tHoursWithSeconds  ', value);
};
goog.inherits(pcmws.api.THoursWithSeconds, pcmws.api.BooleanParam);
goog.provide('pcmws.val.TollCurrency');

goog.require('pcmws.val');

/**
 * @enum {string}
 * 
 */
pcmws.val.TollCurrency = {
  /**  */
  US: "US",
  /**  */
  CDN: "CDN"
};
goog.provide('pcmws.api.TollCurrency');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.TollCurrency');

/**
 * @classdesc
 * An instance of this class represents the TollCurrency parameter in a PCM service.
 *
 * @param {pcmws.val.TollCurrency|string=} value
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.TollCurrency = function (value) {
  pcmws.api.TollCurrency.base(this, 'constructor', 'tollCurrency', pcmws.val.TollCurrency, value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.TollCurrency, pcmws.api.EnumParam);
goog.provide('pcmws.val.TollPlan');

goog.require('pcmws.val');

/**
 * @enum {string}
 * 
 */
pcmws.val.TollPlan = {
  /**  */
  All: "All",
  /**  */
  C407ETRTransponder: "407ETR Transponder",
  /**  */
  A25Transponder: "A25 Transponder",
  /**  */
  BreezeBy: "BreezeBy",
  /**  */
  CPass: "C-Pass",
  /**  */
  CruiseCard: "Cruise Card",
  /**  */
  EPass: "E-Pass",
  /**  */
  EPassCanada: "E-Pass Canada",
  /**  */
  EXpressToll: "EXpress Toll",
  /**  */
  EZTag: "EZ Tag",
  /**  */
  EZPass: "EZPass",
  /**  */
  EZPassNJ: "EZPass-NJ",
  /**  */
  EZPassWV: "EZPassWV",
  /**  */
  FastLane: "FAST LANE",
  /**  */
  FasTrak: "FasTrak",
  /**  */
  GeauxPass: "GeauxPass",
  /**  */
  GoodToGo: "Good To Go",
  /**  */
  GOPass: "GO-PASS",
  /**  */
  IPass: "I-Pass",
  /**  */
  IZoom: "I-Zoom",
  /**  */
  KTag: "K-TAG",
  /**  */
  LaredoTradeTag: "Laredo Trade Tag",
  /**  */
  LeeWay : "LeeWay",
  /**  */
  MacPass: "MACPASS",
  /**  */
  NCQuickPass: "NC Quick Pass",
  /**  */
  NEXPress: "NEXPress",
  /**  */
  PalmettoPass: "Palmetto Pass",
  /**  */
  PeachPass: "Peach Pass",
  /**  */
  PikePass: "PikePass",
  /**  */
  QuickPass: "QuickPass",
  /**  */
  SmartTag: "SmartTag",
  /**  */
  StraitPass: "StraitPASS",
  /**  */
  SunPass: "SunPass",
  /**  */
  TollTag: "TollTag",
  /**  */
  TxTag: "TxTag",
  /**  */
  WalbashPass: "Walbash Pass"
};
goog.provide('pcmws.api.TollPlan');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultiValueEnumParam');
goog.require('pcmws.val.TollPlan');

/**
 * @classdesc
 * An instance of this class represents the TollPlan parameter in a PCM service.
 *
 * @param {Array.<pcmws.val.TollPlan|string>|string=} value
 * @constructor
 * @extends {pcmws.api.MultiValueEnumParam}
 *
 */
pcmws.api.TollPlan = function (value) {
  pcmws.api.TollPlan.base(this, 'constructor', 'tollPlan', value, ',', pcmws.val.TollPlan);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.TollPlan, pcmws.api.MultiValueEnumParam);
goog.provide('pcmws.val.TruckConfig');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the TruckConfig parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.TruckConfig = {
  /**  */
  TwentyEightDoubleTrailer: 'TwentyEightDoubleTrailer',
  /**  */
  FortyStraightTruck: 'FortyStraightTruck',
  /**  */
  FortyEightSemiTrailer: 'FortyEightSemiTrailer',
  /**  */
  FiftyThreeSemiTrailer: 'FiftyThreeSemiTrailer',
  /**  */
  FullSizeVan: 'FullSizeVan',
  /**  */
  TwentySixStraightTruck: 'TwentySixStraightTruck'
};
goog.provide('pcmws.api.TruckConfig');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.TruckConfig');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the TruckConfig parameter in a PCM service.
 *
 * This parameter specifies the particular configuration of the vehicle.
 *
 * @param {pcmws.val.TruckConfig|number|string=} value The TruckConfig value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.TruckConfig = function (value) {
  pcmws.api.TruckConfig.base(this, 'constructor', 'truckConfig', pcmws.val.TruckConfig, value);
};
goog.inherits(pcmws.api.TruckConfig, pcmws.api.EnumParam);
goog.provide('pcmws.api.Urban');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the Urban parameter for a PCM service.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.Urban = function (value) {
  pcmws.api.Urban.base(this, 'constructor', 'urban', value);
};
goog.inherits(pcmws.api.Urban, pcmws.api.BooleanParam);
goog.provide('pcmws.val.Urgency');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the Urgency parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.Urgency = {
  /**  */
 All: 'All',
  /**  */
 Immediate: 'Immediate',
  /**  */
 Expected: 'Expected',
  /**  */
 Future: 'Future',
  /**  */
 Past: 'Past',
  /**  */
 Unknown: 'Unknown'
};
goog.provide('pcmws.api.Urgency');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.Urgency');

/**
 * @classdesc
 * An instance of this class represents the Urgency parameter for a PCM service.
 *
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.Urgency = function (value) {
  pcmws.api.Urgency.base(this, 'constructor', 'urgency', pcmws.val.Urgency, value);
};
goog.inherits(pcmws.api.Urgency, pcmws.api.EnumParam);
goog.provide('pcmws.api.UseTraffic');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the UseTraffic parameter for a PCM service.
 *
 * This parameter specifies whether or not to use traffic as a condition of generating a route.
 *
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.UseTraffic = function (value) {
  pcmws.api.UseTraffic.base(this, 'constructor', 'useTraffic', value);
};
goog.inherits(pcmws.api.UseTraffic, pcmws.api.BooleanParam);
goog.provide('pcmws.val.VehicleDimensionUnits');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the VehicleDimensionUnits parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.VehicleDimensionUnits = {
  /**  */
  English: 'English',
  /**  */
  Metric: 'Metric'
};
goog.provide('pcmws.api.VehicleDimensionUnits');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.VehicleDimensionUnits');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the VehicleDimensionUnits parameter in a PCM service.
 *
 * This parameter specifies whether other parameters concerning the measurement of the vehicle is in
 * feet or meters.
 *
 * @param {pcmws.val.VehicleDimensionUnits|number|string=} value The VehicleDimensionUnits value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.VehicleDimensionUnits = function (value) {
  pcmws.api.VehicleDimensionUnits.base(this, 'constructor', 'vehDimUnits', pcmws.val.VehicleDimensionUnits, value);
};
goog.inherits(pcmws.api.VehicleDimensionUnits, pcmws.api.EnumParam);
goog.provide('pcmws.api.VehicleHeight');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the VehicleHeight parameter for a PCM service.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.VehicleHeight = function (value) {
  pcmws.api.VehicleHeight.base(this, 'constructor', 'vehHeight', value);
};
goog.inherits(pcmws.api.VehicleHeight, pcmws.api.NumberParam);
goog.provide('pcmws.api.VehicleLength');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the VehicleLength parameter for a PCM service.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.VehicleLength = function (value) {
  pcmws.api.VehicleLength.base(this, 'constructor', 'vehLength', value);
};
goog.inherits(pcmws.api.VehicleLength, pcmws.api.NumberParam);
goog.provide('pcmws.val.VehicleType');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the VehicleType parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.VehicleType = {
  /**  */
  Truck: 'Truck',
  /**  */
  LightTruck: 'LightTruck',
  /**  */
  Auto: 'Auto'
};
goog.provide('pcmws.api.VehicleType');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.VehicleType');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'VehType' parameter in a PCM service.
 *
 * @param {pcmws.val.VehicleType|number|string=} value The VehicleType value for this parameter.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.VehicleType = function (value) {
  pcmws.api.VehicleType.base(this, 'constructor', 'vehType', pcmws.val.VehicleType, value);
};
goog.inherits(pcmws.api.VehicleType, pcmws.api.EnumParam);
goog.provide('pcmws.api.VehicleWeight');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the VehicleWeight parameter for a PCM service.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.VehicleWeight = function (value) {
  pcmws.api.VehicleWeight.base(this, 'constructor', 'vehWeight', value);
};
goog.inherits(pcmws.api.VehicleWeight, pcmws.api.NumberParam);
goog.provide('pcmws.api.VehicleWidth');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the VehicleWidth parameter for a PCM service.
 * @param {string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.VehicleWidth = function (value) {
  pcmws.api.VehicleWidth.base(this, 'constructor', 'vehWidth', value);
};
goog.inherits(pcmws.api.VehicleWidth, pcmws.api.NumberParam);
goog.provide('pcmws.val.WeatherDisplay');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive names for WeatherDisplay parameters.
 *
 * @enum {string}
 * 
 */
pcmws.val.WeatherDisplay = {
  /**  */
  Radar: 'Radar',
  /**  */
  Satellite: 'Satellite'
};
goog.provide('pcmws.api.WeatherDisplay');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.EnumParam');
goog.require('pcmws.val.WeatherDisplay');

/**
 * @classdesc
 * An instance of this class generates the WeatherDisplay parameter for a PCM Service.
 *
 * @param {number|string=} value The value from @link pcmws.val.Region.
 * @constructor
 * @extends {pcmws.api.EnumParam}
 *
 */
pcmws.api.WeatherDisplay = function (value) {
  pcmws.api.WeatherDisplay .base(this, 'constructor', 'weatherDisplay', pcmws.val.WeatherDisplay, value);
};
goog.inherits(pcmws.api.WeatherDisplay, pcmws.api.EnumParam);
goog.provide('pcmws.api.Width');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Width parameter for a PCM service.
 *
 * This parameter specifies the Width measurement around the center in WidthUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Width = function (value) {
  pcmws.api.Width.base(this, 'constructor', 'width', value);
};
goog.inherits(pcmws.api.Width, pcmws.api.NumberParam);
goog.provide('pcmws.api.X');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the X parameter for a PCM service.
 *
 * This parameter specifies the X measurement around the center in XUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.X = function (value) {
  pcmws.api.X.base(this, 'constructor', 'x', value);
};
goog.inherits(pcmws.api.X, pcmws.api.NumberParam);
goog.provide('pcmws.api.Y');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Y parameter for a PCM service.
 *
 * This parameter specifies the Y measurement around the center in YUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Y = function (value) {
  pcmws.api.Y.base(this, 'constructor', 'y', value);
};
goog.inherits(pcmws.api.Y, pcmws.api.NumberParam);
goog.provide('pcmws.api.Z');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.NumberParam');

/**
 * @classdesc
 * An instance of this class represents the Z parameter for a PCM service.
 *
 * This parameter specifies the Z measurement around the center in ZUnits.
 * @param {number|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.NumberParam}
 *
 */
pcmws.api.Z = function (value) {
  pcmws.api.Z.base(this, 'constructor', 'z', value);
};
goog.inherits(pcmws.api.Z, pcmws.api.NumberParam);
goog.provide('alk.service.ServiceBase');

goog.require('pcmws.api.AfSetIds');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.AvoidFavors');
goog.require('pcmws.api.AvoidTolls');
goog.require('pcmws.api.Axles');
goog.require('pcmws.api.BorderWait');
goog.require('pcmws.api.BoundingBox');
goog.require('pcmws.api.BreakInterval');
goog.require('pcmws.api.BreakLength');
goog.require('pcmws.api.Center');
goog.require('pcmws.api.Certainty');
goog.require('pcmws.api.CiteInterval');
goog.require('pcmws.api.City');
goog.require('pcmws.api.CitySearchFilter');
goog.require('pcmws.api.CondenseDirections');
goog.require('pcmws.api.Coords');
goog.require('pcmws.api.CostGreenHouseGas');
goog.require('pcmws.api.CostMaintenanceEmpty');
goog.require('pcmws.api.CostMaintenanceLoad');
goog.require('pcmws.api.CostPerFuelUnit');
goog.require('pcmws.api.CostTimeEmpty');
goog.require('pcmws.api.CostTimeLoad');
goog.require('pcmws.api.CountyCodes');
goog.require('pcmws.api.CurrentSpeed');
goog.require('pcmws.api.CustomRoadSpeeds');
goog.require('pcmws.api.Countries');
goog.require('pcmws.api.CountryType');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DistanceUnits');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.ElevationLimit');
goog.require('pcmws.api.EndTime');
goog.require('pcmws.api.EstimatedTimeOpts');
goog.require('pcmws.api.EventNames');
goog.require('pcmws.api.ExchangeRate');
goog.require('pcmws.api.ExcludeSearchTypes');
goog.require('pcmws.api.FerryDiscourage');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.FuelEconomyEmpty');
goog.require('pcmws.api.FuelEconomyLoad');
goog.require('pcmws.api.FuelUnits');
goog.require('pcmws.api.GovernorSpeedLimit');
goog.require('pcmws.api.HazMat');
goog.require('pcmws.api.Heading');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.HighwayOnly');
goog.require('pcmws.api.HistDay');
goog.require('pcmws.api.HistTimeBin');
goog.require('pcmws.api.HistTimeZone');
goog.require('pcmws.api.HosEnabled');
goog.require('pcmws.api.HosRemCycleDutyTime');
goog.require('pcmws.api.HosRemDriveTime');
goog.require('pcmws.api.HosRemDriveTimeUntilBreak');
goog.require('pcmws.api.HosRemOnDutyTime');
goog.require('pcmws.api.HourOffset');
goog.require('pcmws.api.HubRouting');
goog.require('pcmws.api.Identifier');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.IncludeFerryDistance');
goog.require('pcmws.api.IncludeLinkInfo');
goog.require('pcmws.api.IncludePostedSpeedLimit');
goog.require('pcmws.api.IncludeTollData');
goog.require('pcmws.api.Language');
goog.require('pcmws.api.LCV');
goog.require('pcmws.api.List');
goog.require('pcmws.api.MatchNamedRoadsOnly');
goog.require('pcmws.api.MaxCleanupMiles');
goog.require('pcmws.api.MaxResults');
goog.require('pcmws.api.Minutes');
goog.require('pcmws.api.NameFilter');
goog.require('pcmws.api.OpenBorders');
goog.require('pcmws.api.OverrideClass');
goog.require('pcmws.api.OverrideRestrict');
goog.require('pcmws.api.PenWidth');
goog.require('pcmws.api.POICategories');
goog.require('pcmws.api.Point');
goog.require('pcmws.api.PostCode');
goog.require('pcmws.api.PostCodeFilter');
goog.require('pcmws.api.Provider');
goog.require('pcmws.api.PT1');
goog.require('pcmws.api.PT2');
goog.require('pcmws.api.Query');
goog.require('pcmws.api.Radius');
goog.require('pcmws.api.RadiusUnits');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.RemainingHoursOfService');
goog.require('pcmws.api.ReportFormat');
goog.require('pcmws.api.Reports');
goog.require('pcmws.api.Resolution');
goog.require('pcmws.api.RouteId');
goog.require('pcmws.api.RouteDuration');
goog.require('pcmws.api.RouteOptimization');
goog.require('pcmws.api.RoutePath');
goog.require('pcmws.api.RoutePathRequest');
goog.require('pcmws.api.RouteType');
goog.require('pcmws.api.SetId');
goog.require('pcmws.api.Severity');
goog.require('pcmws.api.SideOfStreetAdherence');
goog.require('pcmws.api.Splc');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StartTime');
goog.require('pcmws.api.State');
goog.require('pcmws.api.States');
goog.require('pcmws.api.StopCosts');
goog.require('pcmws.api.Stops');
goog.require('pcmws.api.StopsAsViaPoints');
goog.require('pcmws.api.StrokeWidth');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.THoursWithSeconds');
goog.require('pcmws.api.TollCurrency');
goog.require('pcmws.api.TollPlan');
goog.require('pcmws.api.TruckConfig');
goog.require('pcmws.api.Urban');
goog.require('pcmws.api.Urgency');
goog.require('pcmws.api.UseTraffic');
goog.require('pcmws.api.VehicleDimensionUnits');
goog.require('pcmws.api.VehicleHeight');
goog.require('pcmws.api.VehicleLength');
goog.require('pcmws.api.VehicleType');
goog.require('pcmws.api.VehicleWeight');
goog.require('pcmws.api.VehicleWidth');
goog.require('pcmws.api.WeatherDisplay');
goog.require('pcmws.api.Width');
goog.require('pcmws.api.X');
goog.require('pcmws.api.Y');
goog.require('pcmws.api.Z');

goog.require('alk.service');

goog.require('alkx.ServiceOptions');
/**
 * @classdesc
 * This class is the base class of all alk.service.Service subclasses and processes the options
 * that were set on this object by a {@link alkx.ServiceOptions} object.
 * @description
 * This constructor is the base constructor for various Service objects that access ALK data.
 * @param {alkx.ServiceOptions=} opt_options Options
 * @constructor
 * @api
 */
alk.service.ServiceBase = function (opt_options) {
  this.baseServiceOptions_ = this.filterOptions(opt_options || {});
};

/**
 * @param {!Object} o1
 * @param {!Object} o2
 * @returns {Object}
 */
alk.service.ServiceBase.prototype.extendWith = function(o1, o2) {
  Object.keys(o2).forEach(function (key) {
    if (o2.hasOwnProperty(key)) {
      var val = o2[key];
      if (val !== undefined) {
        o1[key] = val;
      }
    }
  });
  return o1;
};

/**
 * @type {!Object}
 */
alk.service.ServiceBase.prototype.baseServiceOptions_;

/**
 * @param {!Object} options
 * @this {alk.service.ServiceBase}
 * @returns {!Object}
 */
alk.service.ServiceBase.prototype.filterOptions = function(options) {
  var opts2 = {};
  var self = this;
  Object.keys(options).forEach(function (optionKey) {
    var val = options[optionKey];
    if (val !== undefined) {
      var spec = self.optionSpecs[optionKey];
      if (spec !== undefined) {
        opts2[optionKey] = val;
      } else if (['stopTypes','hostURL','path'].indexOf(optionKey) > -1) {
        opts2[optionKey] = val;
      }
    }
  });
  return opts2;
};

/**
 *
 * @param {!Object} options
 * @this {alk.service.ServiceBase}
 * @returns {!Object}
 */
alk.service.ServiceBase.prototype.toPCMServiceOptions = function (options) {
  var pcm = {};
  var self = this;
  Object.keys(options).forEach(function (optionKey) {
    var val = options[optionKey];
    if (val !== undefined) {
      var spec = self.optionSpecs[optionKey];
      if (spec !== undefined) {
        var pcmOptionKey = spec[0];
        var checkFn = spec[1];
        if (typeof checkFn === 'function') {
          pcm[pcmOptionKey] = checkFn(val);
        } else {
          pcm[pcmOptionKey] = val;
        }
      } else if (['hostURL', 'path'].indexOf(optionKey) > -1) {
        pcm[optionKey] = val;
      }
    }
  });
  return pcm;
};

/**
 * @param {Object=} options
 * @this {alk.service.ServiceBase}
 * @return {!Object}
 */
alk.service.ServiceBase.prototype.getPCMServiceOptions = function (options) {
  return this.toPCMServiceOptions(options || {});
};

/**
 * This method returns the base options that was used to create this
 * Service object and override them with the given options;
 * @param {Object=} options
 * @return {!Object} The combined options.
 * @this {alk.service.ServiceBase}
 * @api
 */
alk.service.ServiceBase.prototype.getServiceOptions = function (options) {

  var opts = options !== undefined ? /** @type {!Object} */(options) : {};
  var so = {};
  this.extendWith(so, this.baseServiceOptions_);
  this.extendWith(so, this.filterOptions(opts));
  return so;
};


/**
 * This property holds a hash object of the option key
 * for a {@link alk.service.Service} object that is
 * associated with a two item array.
 *
 * The first item is the corresponding key for a
 * {@link pcmws.api.StaticService}. Note, most associations use
 * the same key. However, some do not. For example 'apiKey'
 * corresponds to 'authToken' on the pcmws.api.StaticService.
 *
 * The second item of the array is a function that
 * converts the option value to the pcmws option value.
 * Note, this function converts the option value to
 * the pcmws option value that is given to a subclass
 * of pcmws.api.Param, not the pcmws.api.Param itself.
 * Mostly, what is used for the conversion is the
 * corresponding pcmws.api.Param itself, and returning
 * {@link pcmws.api.Param#getCheckedValue()}. The function
 * will perform conversions to normalized values. The
 * conversion may incur ARG_CHECK exceptions should
 * pcmws.ARG_CHECK be set to a truthy value;
 *
 * The ALK PCM Web services use the same parameter across all
 * {@link pcmws.api.StaticService} objects for a particular option.
 * So far, there are no name to {@link pcmws.api.Param} conflicts.
 *
 * Note, the actual parameter name that is given in the
 * URL or POST Data is contained in the corresponding
 * {@link pcmws.api.Param} object.
 *
 * Developer Note: If adding a spec, please add in
 * alphabetical order.
 *
 * @const {Object.<string,Array.<string|function(*):*>>}
 * @private
 */
  // The closure compiler gives this error if it is directly assigned:
  //   ERROR Prototype property optionSpecs should be a primitive, not an Array or Object.
alk.service.ServiceBase.prototype.optionSpecs = function () {
  return {
    afSetIds: ['afSetIds', function (v) {
      return new pcmws.api.AfSetIds(v).getCheckedValue();
    }],
    apiKey: ['authToken', function (v) {
      return new pcmws.api.AuthToken(v).getCheckedValue();
    }],
    avoidFavors: ['avoidFavors', function (v) {
      return new pcmws.api.AvoidFavors(v).getCheckedValue();
    }],
    avoidTolls: ['avoidTolls', function (v) {
      return new pcmws.api.AvoidTolls(v).getCheckedValue();
    }],
    axles: ['axles', function (v) {
      return new pcmws.api.Axles(v).getCheckedValue();
    }],
    borderWait: ['borderWait', function (v) {
      return new pcmws.api.BorderWait(v).getCheckedValue();
    }],
    boundingBox: ['boundingBox', function (v) {
      return new pcmws.api.BoundingBox(v).getCheckedValue();
    }],
    breakInterval: ['breakInterval', function (v) {
      return new pcmws.api.BreakInterval(v).getCheckedValue();
    }],
    breakLength: ['breakLength', function (v) {
      return new pcmws.api.BreakLength(v).getCheckedValue();
    }],
    center: ['center', function (v) {
      return new pcmws.api.Center(v).getCheckedValue();
    }],
    certainty: ['certainty', function (v) {
      return new pcmws.api.Certainty(v).getCheckedValue();
    }],
    citeInterval: ['citeInterval', function (v) {
      return new pcmws.api.CiteInterval(v).getCheckedValue();
    }],
    city: ['city', function (v) {
      return new pcmws.api.City(v).getCheckedValue();
    }],
    citySearchFilter: ['citySearchFilter', function (v) {
      return new pcmws.api.CitySearchFilter(v).getCheckedValue();
    }],
    codes: ['codes', function (v) {
      return new pcmws.api.CountyCodes(v).getCheckedValue();
    }],
    condenseDirections: ['condenseDirections', function (v) {
      return new pcmws.api.CondenseDirections(v).getCheckedValue();
    }],
    coords: ['coords', function (v) {
      return new pcmws.api.Coords(v).getCheckedValue();
    }],
    costGreenHouseGas: ['costGreenHouseGas', function (v) {
      return new pcmws.api.CostGreenHouseGas(v).getCheckedValue();
    }],
    costMaintenanceEmpty: ['costMaintenanceEmpty', function (v) {
      return new pcmws.api.CostMaintenanceEmpty(v).getCheckedValue();
    }],
    costMaintenanceLoad: ['costMaintenanceLoad', function (v) {
      return new pcmws.api.CostMaintenanceLoad(v).getCheckedValue();
    }],
    costPerFuelUnit: ['costPerFuelUnit', function (v) {
      return new pcmws.api.CostPerFuelUnit(v).getCheckedValue();
    }],
    costTimeEmpty: ['costTimeEmpty', function (v) {
      return new pcmws.api.CostTimeEmpty(v).getCheckedValue();
    }],
    costTimeLoad: ['costTimeLoad', function (v) {
      return new pcmws.api.CostTimeLoad(v).getCheckedValue();
    }],
    currentSpeed: ['currentSpeed', function (v) {
      return new pcmws.api.CurrentSpeed(v).getCheckedValue();
    }],
    countries: ['countries', function (v) {
      return new pcmws.api.Countries(v).getCheckedValue();
    }],
    countryType: ['countryType', function (v) {
      return new pcmws.api.CountryType(v).getCheckedValue();
    }],
    customRoadSpeeds: ['customRoadSpeeds', function (v) {
      return new pcmws.api.CustomRoadSpeeds(v).getCheckedValue();
    }],
    dataset: ['dataset', function (v) {
      return new pcmws.api.Dataset(v).getCheckedValue();
    }],
    display: ['weatherDisplay', function (v) {
      return new pcmws.api.WeatherDisplay(v).getCheckedValue();
    }],
    distanceUnits: ['distanceUnits', function (v) {
      return new pcmws.api.DistanceUnits(v).getCheckedValue();
    }],
    drawerGroups: ['drawerGroups', function (v) {
      return new pcmws.api.DrawerGroups(v).getCheckedValue();
    }],
    elevationLimit: ['elevationLimit', function (v) {
      return new pcmws.api.ElevationLimit(v).getCheckedValue();
    }],
    endTime: ['endTime', function (v) {
      return new pcmws.api.EndTime(v).getCheckedValue();
    }],
    estimatedTimeOpts: ['estimatedTimeOpts', function (v) {
      return new pcmws.api.EstimatedTimeOpts(v).getCheckedValue();
    }],
    eventNames: ['eventNames', function (v) {
      return new pcmws.api.EventNames(v).getCheckedValue();
    }],
    exchangeRate: ['exchangeRate', function (v) {
      return new pcmws.api.ExchangeRate(v).getCheckedValue();
    }],
    excludeSearchTypes: ['excludeSearchTypes', function (v) {
      return new pcmws.api.ExcludeSearchTypes(v).getCheckedValue();
    }],
    ferryDiscourage: ['ferryDiscourage', function (v) {
      return new pcmws.api.FerryDiscourage(v).getCheckedValue();
    }],
    format: ['format', function (v) {
      return new pcmws.api.Format(v).getCheckedValue();
    }],
    fuelEconomyEmpty: ['fuelEconomyEmpty', function (v) {
      return new pcmws.api.FuelEconomyEmpty(v).getCheckedValue();
    }],
    fuelEconomyLoad: ['fuelEconomyLoad', function (v) {
      return new pcmws.api.FuelEconomyLoad(v).getCheckedValue();
    }],
    fuelUnits: ['fuelUnits', function (v) {
      return new pcmws.api.FuelUnits(v).getCheckedValue();
    }],
    governorSpeedLimit: ['governorSpeedLimit', function (v) {
      return new pcmws.api.GovernorSpeedLimit(v).getCheckedValue();
    }],
    hazMat: ['hazMat', function (v) {
      return new pcmws.api.HazMat(v).getCheckedValue();
    }],
    heading: ['heading', function (v) {
      return new pcmws.api.Heading(v).getCheckedValue();
    }],
    height: ['height', function (v) {
      return new pcmws.api.Height(v).getCheckedValue();
    }],
    highwayOnly: ['highwayOnly', function (v) {
      return new pcmws.api.HighwayOnly(v).getCheckedValue();
    }],
    histDay: ['histDay', function (v) {
      return new pcmws.api.HistDay(v).getCheckedValue();
    }],
    histTimeBin: ['histTimeBin', function (v) {
      return new pcmws.api.HistTimeBin(v).getCheckedValue();
    }],
    histTimeZone: ['histTimeZone', function (v) {
      return new pcmws.api.HistTimeZone(v).getCheckedValue();
    }],
    hosEnabled: ['hosEnabled', function (v) {
      return new pcmws.api.HosEnabled(v).getCheckedValue();
    }],
    hosRemCycleDutyTime: ['hosRemCycleDutyTime', function (v) {
      return new pcmws.api.HosRemCycleDutyTime(v).getCheckedValue();
    }],
    hosRemDriveTime: ['hosRemDriveTime', function (v) {
      return new pcmws.api.HosRemDriveTime(v).getCheckedValue();
    }],
    hosRemDriveTimeUntilBreak: ['hosRemDriveTimeUntilBreak', function (v) {
      return new pcmws.api.HosRemDriveTimeUntilBreak(v).getCheckedValue();
    }],
    hosRemOnDutyTime: ['hosRemOnDutyTime', function (v) {
      return new pcmws.api.HosRemOnDutyTime(v).getCheckedValue();
    }],
    hourOffset: ['hourOffset', function (v) {
      return new pcmws.api.HourOffset(v).getCheckedValue();
    }],
    hubRouting: ['hubRouting', function (v) {
      return new pcmws.api.HubRouting(v).getCheckedValue();
    }],
    identifier: ['identifier', function (v) {
      return new pcmws.api.Identifier(v).getCheckedValue();
    }],
    imgOption: ['imgOption', function (v) {
      return new pcmws.api.ImgOption(v).getCheckedValue();
    }],
    imgSrc: ['imgSrc', function (v) {
      return new pcmws.api.ImgSrc(v).getCheckedValue();
    }],
    includeFerryDistance: ['includeFerryDistance', function (v) {
      return new pcmws.api.IncludeFerryDistance(v).getCheckedValue();
    }],
    includeLinkInfo: ['includeLinkInfo', function (v) {
      return new pcmws.api.IncludeLinkInfo(v).getCheckedValue();
    }],
    includePostedSpeedLimit: ['includePostedSpeedLimit', function (v) {
      return new pcmws.api.IncludePostedSpeedLimit(v).getCheckedValue();
    }],
    includeTollData: ['includeTollData', function (v) {
      return new pcmws.api.IncludeTollData(v).getCheckedValue();
    }],
    language: ['language', function (v) {
      return new pcmws.api.Language(v).getCheckedValue();
    }],
    lcv: ['lcv', function (v) {
      return new pcmws.api.LCV(v).getCheckedValue();
    }],
    list: ['list', function (v) {
      return new pcmws.api.List(v).getCheckedValue();
    }],
    matchNamedRoadsOnly: ['matchNamedRoadsOnly', function (v) {
      return new pcmws.api.MatchNamedRoadsOnly(v).getCheckedValue();
    }],
    maxCleanupMiles: ['maxCleanupMiles', function (v) {
      return new pcmws.api.MaxCleanupMiles(v).getCheckedValue();
    }],
    maxResults: ['maxResults', function (v) {
      return new pcmws.api.MaxResults(v).getCheckedValue();
    }],
    minutes: ['minutes', function (v) {
      return new pcmws.api.Minutes(v).getCheckedValue();
    }],
    nameFilter: ['nameFilter', function (v) {
      return new pcmws.api.NameFilter(v).getCheckedValue();
    }],
    openBorders: ['openBorders', function (v) {
      return new pcmws.api.OpenBorders(v).getCheckedValue();
    }],
    overrideClass: ['overrideClass', function (v) {
      return new pcmws.api.OverrideClass(v).getCheckedValue();
    }],
    overrideRestrict: ['overrideRestrict', function (v) {
      return new pcmws.api.OverrideRestrict(v).getCheckedValue();
    }],
    penWidth: ['penWidth', function (v) {
      return new pcmws.api.PenWidth(v).getCheckedValue();
    }],
    poiCategories: ['poiCategories', function (v) {
      return new pcmws.api.POICategories(v).getCheckedValue();
    }],
    point: ['point', function (v) {
      return new pcmws.api.Point(v).getCheckedValue();
    }],
    postCode: ['postCode', function (v) {
      return new pcmws.api.PostCode(v).getCheckedValue();
    }],
    postCodeFilter: ['postCodeFilter', function (v) {
      return new pcmws.api.PostCodeFilter(v).getCheckedValue();
    }],
    provider: ['provider', function (v) {
      return new pcmws.api.Provider(v).getCheckedValue();
    }],
    pt1: ['pt1', function (v) {
      return new pcmws.api.PT1(v).getCheckedValue();
    }],
    pt2: ['pt2', function (v) {
      return new pcmws.api.PT2(v).getCheckedValue();
    }],
    query: ['query', function (v) {
      return new pcmws.api.Query(v).getCheckedValue();
    }],
    radius: ['radius', function (v) {
      return new pcmws.api.Radius(v).getCheckedValue();
    }],
    radiusUnits: ['radiusUnits', function (v) {
      return new pcmws.api.RadiusUnits(v).getCheckedValue();
    }],
    region: ['region', function (v) {
      return new pcmws.api.Region(v).getCheckedValue();
    }],
    resolution: ['resolution', function (v) {
      return new pcmws.api.Resolution(v).getCheckedValue();
    }],
    remainingHoursOfService: ['remainingHoursOfService', function (v) {
      return new pcmws.api.RemainingHoursOfService(v).getCheckedValue();
    }],
    reportFormat: ['reportFormat', function (v) {
      return new pcmws.api.ReportFormat(v).getCheckedValue();
    }],
    reports: ['reports', function (v) {
      return new pcmws.api.Reports(v).getCheckedValue();
    }],
    routeId: ['routeId', function (v) {
      return new pcmws.api.RouteId(v).getCheckedValue();
    }],
    routeDuration: ['routeDuration', function (v) {
      return new pcmws.api.RouteDuration(v).getCheckedValue();
    }],
    routeOptimization: ['routeOptimization', function (v) {
      return new pcmws.api.RouteOptimization(v).getCheckedValue();
    }],
    routePath: ['routePath', function (v) {
      return new pcmws.api.RoutePath(v).getCheckedValue();
    }],
    routePathRequest: ['routePathRequest', function (v) {
      return new pcmws.api.RoutePathRequest(v).getCheckedValue();
    }],
    routeType: ['routeType', function (v) {
      return new pcmws.api.RouteType(v).getCheckedValue();
    }],
    setId: ['setId', function (v) {
      return new pcmws.api.SetId(v).getCheckedValue();
    }],
    severity: ['severity', function (v) {
      return new pcmws.api.Severity(v).getCheckedValue();
    }],
    sideOfStreetAdherence: ['sideOfStreetAdherence', function (v) {
      return new pcmws.api.SideOfStreetAdherence(v).getCheckedValue();
    }],
    splc: ['splc', function (v) {
      return new pcmws.api.Splc(v).getCheckedValue();
    }],
    srs: ['srs', function (v) {
      return new pcmws.api.SRS(v).getCheckedValue();
    }],
    startTime: ['startTime', function (v) {
      return new pcmws.api.StartTime(v).getCheckedValue();
    }],
    state: ['state', function (v) {
      return new pcmws.api.State(v).getCheckedValue();
    }],
    states: ['states', function (v) {
      return new pcmws.api.States(v).getCheckedValue();
    }],
    stopCosts: ['stopCosts', function (v) {
      return new pcmws.api.StopCosts(v).getCheckedValue();
    }],
    stops: ['stops', function (v) {
      return new pcmws.api.Stops(v).getCheckedValue();
    }],
    stopsAsViaPoints: ['stopsAsViaPoints', function (v) {
      return new pcmws.api.StopsAsViaPoints(v).getCheckedValue();
    }],
    strokeWidth: ['strokeWidth', function (v) {
      return new pcmws.api.StrokeWidth(v).getCheckedValue();
    }],
    style: ['style', function (v) {
      return new pcmws.api.Style(v).getCheckedValue();
    }],
    tHoursWithSeconds: ['tHoursWithSeconds', function (v) {
      return new pcmws.api.THoursWithSeconds(v).getCheckedValue();
    }],
    tollCurrency: ['tollCurrency', function (v) {
      return new pcmws.api.TollCurrency(v).getCheckedValue();
    }],
    tollPlan: ['tollPlan', function (v) {
      return new pcmws.api.TollPlan(v).getCheckedValue();
    }],
    truckConfig: ['truckConfig', function (v) {
      return new pcmws.api.TruckConfig(v).getCheckedValue();
    }],
    urban: ['urban', function (v) {
      return new pcmws.api.Urban(v).getCheckedValue();
    }],
    urgency: ['urgency', function (v) {
      return new pcmws.api.Urgency(v).getCheckedValue();
    }],
    useTraffic: ['useTraffic', function (v) {
      return new pcmws.api.UseTraffic(v).getCheckedValue();
    }],
    vehicleDimensionUnits: ['vehicleDimensionUnits', function (v) {
      return new pcmws.api.VehicleDimensionUnits(v).getCheckedValue();
    }],
    vehicleHeight: ['vehicleHeight', function (v) {
      return new pcmws.api.VehicleHeight(v).getCheckedValue();
    }],
    vehicleLength: ['vehicleLength', function (v) {
      return new pcmws.api.VehicleLength(v).getCheckedValue();
    }],
    vehicleType: ['vehicleType', function (v) {
      return new pcmws.api.VehicleType(v).getCheckedValue();
    }],
    vehicleWeight: ['vehicleWeight', function (v) {
      return new pcmws.api.VehicleWeight(v).getCheckedValue();
    }],
    vehicleWidth: ['vehicleWidth', function (v) {
      return new pcmws.api.VehicleWidth(v).getCheckedValue();
    }],
    width: ['width', function (v) {
      return new pcmws.api.Width(v).getCheckedValue();
    }],
    x: ['x', function (v) {
      return new pcmws.api.X(v).getCheckedValue();
    }],
    y: ['y', function (v) {
      return new pcmws.api.Y(v).getCheckedValue();
    }],
    z: ['z', function (v) {
      return new pcmws.api.Z(v).getCheckedValue();
    }]
  };
}();
goog.provide('alk.service.Service');

goog.require('alk.service');
goog.require('alk.service.ServiceBase');

goog.require('alkx.ServiceOptions');
/**
 * @classdesc
 * An instance of this object creates the URL needed based on options and defaults to access ALK services.
 * @description
 * This constructor is one above the base constructor, which is meant to be subclassed. Its
 * base functionality is to process options from the ALK API down to the lower level
 * PCMWS level API, which is not seen by the general developer.
 *
 * @param {alkx.ServiceOptions=} opt_options Options
 * @extends {alk.service.ServiceBase}
 * @constructor
 * @api
 */
alk.service.Service = function (opt_options) {
  alk.service.Service.base(this, 'constructor', opt_options);
};
goog.inherits(alk.service.Service, alk.service.ServiceBase);

/**
 * This attribute contains the default {@link pcmws.api.StaticService}
 * object used to create the URL from the options, or make
 * requests with that URL.
 * @type {pcmws.api.StaticService}
 */
alk.service.Service.prototype.pcmws;

/**
 * @description
 * Returns the URL for the service based on the given options, options set on the constructor, and defaults.
 * @param {Object=} opt_options
 *     These options override any relevant options that are set on the object at
 *     its construction.
 * @returns {string}
 * @this {alk.service.Service}
 * @api
 */
alk.service.Service.prototype.getURL = function (opt_options) {
  if (opt_options === undefined) {
    return this.pcmws.getURL();
  } else {
    var service = this.pcmws.clone();
    var opts = this.getPCMServiceOptions(opt_options);
    return service.getURL(opts);
  }
};

/**
 * @description
 * This method performs a request to this configured service
 * using the supplied options, options set on the constructor, and
 * defaults. The response is handled asynchronously by a callback.
 *
 * This method calls on possibly sub-classed methods:
 * - getServiceOptions to combine and extend call options with the base options
 * - processResponse to process the response before handing it off to the responseCallback.
 *
 * ## NOTE ##
 *
 * The primary function of a service is to generate a URL. Although this call exists on
 * this object, this ``get`` call may not be used by certain components, such as
 * {@link alk.source.XYZSource}.
 * That is because the tile source will just use ``getURL`` call to get the URL, which
 * may be a template with {x}, {y}, {z}, and make the get XHR requests on its own. Therefore,
 * the intercept points, such as ``processResponse`` will not be engaged for those calls.
 *
 * @param {(Object|function(Object))=} opts_or_callback
 *     This parameter contains any options that override options that are set
 *     on this object for this particular request.
 * @param {function(Object)=} responseCallback
 *     This parameter is the function that handles the response.
 * @return {*|undefined}
 * @this {alk.service.Service}
 * @api
 *
 */
alk.service.Service.prototype.get = function(opts_or_callback, responseCallback) {
  /** @type {!Object} */
  var options = {};
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {!Object} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  if (typeof callback !== 'function') {
    throw "alk.service.Service#get: no or illegal response callback specified.";
  }
  var opts = this.getPCMServiceOptions(options);
  var self = this;
  var serviceOptions = this.getServiceOptions(options);
  return this.pcmws.get(opts, function (obj) {
    return callback.call(self, self.processResponse(serviceOptions, obj));
  });
};

/**
 * This method processes the response from the server before it gives it to
 * the callback. The default is to pass through.
 *
 * ## NOTE ##
 *
 * This intercept point will only be called if the request was initiated with
 * the ``get`` call.
 *
 * @param {Object} options The call options combined with the base options used for the call.
 * @param {Object} obj The object received from the server.
 * @return {Object}
 * @api
 */
alk.service.Service.prototype.processResponse = function(options, obj) {
  return obj;
};

/**
 * @description
 * This method performs a request to this configured service
 * using the supplied options, options set on the constructor, and
 * defaults to get the service's attribution, should it have one.
 * This call results in Object, which may be a parsed JSON response.
 *
 * @param {(Object|function(Object))=} opts_or_callback
 *     This parameter contains any options that override options that are set
 *     on this object for this particular request.
 * @param {function(Object)=} responseCallback
 *     This parameter is the function that handles the response.
 * @return {*|undefined}
 * @this {alk.service.Service}
 * @api
 */
alk.service.Service.prototype.getAttribution = function(opts_or_callback, responseCallback) {
  var options = {};
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = opts_or_callback;
    }
    callback = responseCallback;
  }
  var opts = this.getPCMServiceOptions(options);
  var self = this;
  return this.pcmws.getAttribution(opts, function (obj) {
    return callback.call(self, obj);
  });
};
goog.provide('pcmws.api.Street');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the Street parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Street = function (value) {
  pcmws.api.Street .base(this, 'constructor', 'street', value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.Street, pcmws.api.Param);
goog.provide('pcmws.api.LocationsService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.City');
goog.require('pcmws.api.CitySearchFilter');
goog.require('pcmws.api.Coords');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.List');
goog.require('pcmws.api.LocationsServiceOptions');
goog.require('pcmws.api.MatchNamedRoadsOnly');
goog.require('pcmws.api.MaxCleanupMiles');
goog.require('pcmws.api.PostCode');
goog.require('pcmws.api.PostCodeFilter');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.Splc');
goog.require('pcmws.api.State');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Street');


/**
 * The Locations service, which is reverse geocoding.
 * @param {pcmws.api.LocationsServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.LocationsService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['city', pcmws.api.City],
    ['citySearchFilter', pcmws.api.CitySearchFilter],
    ['coords', pcmws.api.Coords],
    ['dataset', pcmws.api.Dataset],
    ['list', pcmws.api.List],
    ['matchNamedRoadsOnly', pcmws.api.MatchNamedRoadsOnly],
    ['maxCleanupMiles', pcmws.api.MaxCleanupMiles],
    ['postCode', pcmws.api.PostCode],
    ['postCodeFilter', pcmws.api.PostCodeFilter],
    ['region', pcmws.api.Region],
    ['splc', pcmws.api.Splc],
    ['state', pcmws.api.State],
    ['street', pcmws.api.Street]
  ];
  pcmws.api.LocationsService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.LocationsServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.LocationsURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.LocationsService, pcmws.api.StaticService);

/**
 * @override
 * @returns {pcmws.api.LocationsService}
 * @this {pcmws.api.LocationsService}
 */
pcmws.api.LocationsService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.LocationsServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.LocationsService(opts);
};
goog.provide('alk.service.LocationsService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.LocationsService');

goog.require('alkx.LocationsServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the PCM LocationsService.
 * @description
 * This constructor creates a Service object to access the ALK PC Miler
 * Locations Service.
 *
 * @param {alkx.LocationsServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.LocationsService = function (opt_options) {
  alk.service.LocationsService.base(this, 'constructor', opt_options);
  this.pcmServiceOptions = this.getPCMServiceOptions(opt_options);
  this.locationsService = this.pcmws = new pcmws.api.LocationsService(this.pcmServiceOptions);
};
goog.inherits(alk.service.LocationsService, alk.service.Service);

/**
 * @description
 * The ALK Locations Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.LocationsService} object.
 *
 * @type {pcmws.api.LocationsService}
 */
alk.service.LocationsService.prototype.locationsService;

/**
 * @description
 * This function performs a request for a {@link alkx.LocationsServiceResponse} from
 * the options and defaults set on this {@link alk.service.LocationsService} object.
 *
 * The response is handled by a asynchronous callback.
 *
 * @param {(alkx.LocationsServiceOptions|null|
 *     function(alkx.LocationsServiceResponse))=} opts_or_callback
 *     Options override, if not the callback.
 * @param {function(alkx.LocationsServiceResponse)=} responseCallback
 *     The callback that handles the response.
 * @override
 * @this {alk.service.LocationsService}
 * @api
 */
alk.service.LocationsService.prototype.get = function(opts_or_callback, responseCallback) {
  /** @type {alkx.LocationsServiceOptions} */
  var options = {};
  /** function(alkx.LocationsServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.LocationsServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.LocationsService.base(this, 'get', downcastOptions, downcastCallback);
};

goog.provide('alk.geocode.Geocoder');

goog.require('alk.geocode');
goog.require('alk.service.LocationsService');

goog.require('alkx.GeocoderOptions');
goog.require('alkx.GeocoderGeocodeOptions');
goog.require('alkx.GeocoderGeocodeResponse');
goog.require('alkx.LocationsServiceOptions');

/**
 * @classdesc
 * An instance of this class has the functionality to access the
 * ALK Geocoding/Locations service.
 * @description
 * This constructor creates an API object that gives its user the
 * ability to access the ALK Geocoding/Locations service.
 *
 * @param {alkx.GeocoderOptions=} opt_options
 * @constructor
 * @api
 */
alk.geocode.Geocoder = function (opt_options) {
  /** @type {alkx.GeocoderOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var locationsServiceOptions = options.locationsServiceOptions;

  this.locationsService_ = new alk.service.LocationsService(locationsServiceOptions);

};

/**
 * @type {alk.service.LocationsService}
 */
alk.geocode.Geocoder.prototype.locationsService_;

/**
 * This method calls out to the ALK Locations Service to retrieve results
 * from the search parameters and the defaults set at the creation of the
 * Geocoder object.
 *
 * @param {alkx.GeocoderGeocodeOptions=} opt_options
 * @this {alk.geocode.Geocoder}
 * @api
 */
alk.geocode.Geocoder.prototype.geocode = function (opt_options) {
  /** @type {alkx.GeocoderGeocodeOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.LocationsServiceOptions} */
  var opts = {};

  if (options.address !== undefined) {
    var address = options.address;
    opts.street = address.addr || address.StreetAddress;
    opts.city = address.city || address.City;
    opts.state = address.state || address.State;
    opts.postCode = address.zip || address.Zip;
    opts.region = address.region;
  }
  opts.list = options.listSize;
  var success = options.success;
  var failure = options.failure;
  var self = this;
  this.locationsService_.get(opts, function (response) {
    if (response == null) {
      failure(self.processGeocodeResponse(options, response));
    } else {
      success(self.processGeocodeResponse(options, response));
    }
  });

};

/**
 * @param {Object} options
 * @param {Object=} response
 * @returns {alkx.GeocoderGeocodeResponse|undefined}
 */
alk.geocode.Geocoder.prototype.processGeocodeResponse = function (options, response) {
  return /** @type {alkx.GeocoderGeocodeResponse|undefined} */ (response);
};
goog.provide('pcmws.api.LocationsReverseService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Coords');
goog.require('pcmws.api.CurrentSpeed');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.Heading');
goog.require('pcmws.api.IncludeLinkInfo');
goog.require('pcmws.api.IncludePostedSpeedLimit');
goog.require('pcmws.api.LocationsReverseServiceOptions');
goog.require('pcmws.api.MatchNamedRoadsOnly');
goog.require('pcmws.api.MaxCleanupMiles');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Urban');
goog.require('pcmws.api.VehicleType');

/**
 * The Locations service, which is reverse geocoding.
 * @param {pcmws.api.LocationsReverseServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.LocationsReverseService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['coords', pcmws.api.Coords],
    ['currentSpeed', pcmws.api.CurrentSpeed],
    ['dataset', pcmws.api.Dataset],
    ['heading', pcmws.api.Heading],
    ['includePostedSpeedLimit', pcmws.api.IncludePostedSpeedLimit],
    ['includeLinkInfo', pcmws.api.IncludeLinkInfo],
    ['matchNamedRoadsOnly', pcmws.api.MatchNamedRoadsOnly],
    ['maxCleanupMiles', pcmws.api.MaxCleanupMiles],
    ['region', pcmws.api.Region],
    ['urban', pcmws.api.Urban],
    ['vehicleType', pcmws.api.VehicleType]
  ];
  pcmws.api.LocationsReverseService.base(this, 'constructor', specs, opt_options);
  /** @type {pcmws.api.LocationsReverseServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.LocationsReverseURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.LocationsReverseService, pcmws.api.StaticService);

/**
 * @override
 * @returns {pcmws.api.LocationsReverseService}
 * @this {pcmws.api.LocationsReverseService}
 */
pcmws.api.LocationsReverseService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.LocationsReverseServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.LocationsReverseService(opts);
};

/**
 * @param {Object} obj
 * @returns {Object}
 * @override
 */
pcmws.api.LocationsReverseService.prototype.processResponse = function (obj) {
  // The service may return one single object. if it does we make it an array.
  if (obj && !(obj instanceof Array)) {
    obj = [obj];
  }
  return obj;
};
goog.provide('alk.service.LocationsReverseService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.LocationsReverseService');

goog.require('alkx.LocationsReverseServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the PCM LocationsReverseService.
 * @description
 * This constructor creates a Service object that accesses the ALK PC Miler
 * Locations/Reverse Service.
 * @param {alkx.LocationsReverseServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.LocationsReverseService = function (opt_options) {
  alk.service.LocationsReverseService.base(this, 'constructor', opt_options);
  this.pcmServiceOptions = this.getPCMServiceOptions(opt_options);
  this.locationsReverseService = this.pcmws = new pcmws.api.LocationsReverseService(this.pcmServiceOptions);
};
goog.inherits(alk.service.LocationsReverseService, alk.service.Service);

/**
 * @description
 * The ALK Locations Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.LocationsReverseService} object.
 *
 * @type {pcmws.api.LocationsReverseService}
 */
alk.service.LocationsReverseService.prototype.locationsReverseService;

/**
 * @description
 * This function performs a request for a {@link alkx.LocationsReverseServiceResponse} from
 * the options and defaults set on this {@link alk.service.LocationsReverseService} object.
 *
 * The response is handled by a asynchronous callback.
 *
 * @param {(alkx.LocationsReverseServiceOptions|null|
 *     function(alkx.LocationsReverseServiceResponse))=} opts_or_callback
 *     Options override, if not the callback.
 * @param {function(alkx.LocationsReverseServiceResponse)=} responseCallback
 *     The callback that handles the response.
 * @override
 * @this {alk.service.LocationsReverseService}
 * @api
 */
alk.service.LocationsReverseService.prototype.get = function(opts_or_callback, responseCallback) {
  /** @type {alkx.LocationsReverseServiceOptions} */
  var options = {};
  /** function(alkx.LocationsReverseServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.LocationsReverseServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.LocationsReverseService.base(this, 'get', downcastOptions, downcastCallback);
};

goog.provide('alk.geocode.ReverseGeocoder');

goog.require('alk.geocode');
goog.require('alk.service.LocationsReverseService');


goog.require('alkx.ReverseGeocoderOptions');
goog.require('alkx.ReverseGeocoderReverseGeocodeOptions');
goog.require('alkx.ReverseGeocoderReverseGeocodeResponse');
goog.require('alkx.LocationsReverseServiceOptions');
/**
 * @classdesc
 * An instance of this class provides access to the ALK Reverse Geocoding/Locations
 * Service
 * @description
 * This constructor creates an API object for accesing the
 * ALK Reverse Geocoding/Locations service.
 *
 * @param {alkx.ReverseGeocoderOptions=} opt_options
 * @constructor
 * @api
 */
alk.geocode.ReverseGeocoder = function (opt_options) {
  /** @type {alkx.ReverseGeocoderOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var locationsReverseServiceOptions = options.locationsReverseServiceOptions;

  this.locationsReverseService_ = new alk.service.LocationsReverseService(locationsReverseServiceOptions);

};

/**
 * @type {alk.service.LocationsReverseService}
 */
alk.geocode.ReverseGeocoder.prototype.locationsReverseService_;

/**
 * This method calls out to the ALK Locations Service to retrieve results
 * from the search parameters and the defaults set at the creation of the
 * ReverseGeocoder object.
 *
 * @param {alkx.ReverseGeocoderReverseGeocodeOptions=} opt_options
 * @this {alk.geocode.ReverseGeocoder}
 * @api
 */
alk.geocode.ReverseGeocoder.prototype.reverseGeocode = function (opt_options) {
  /** @type {alkx.ReverseGeocoderReverseGeocodeOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.LocationsReverseServiceOptions} */
  var opts = {
    coords: options.lonLat,
    region: options.region,
    dataset: options.dataset
  };

  var success = options.success;
  var failure = options.failure;
  var self = this;
  this.locationsReverseService_.get(opts, function (response) {
    if (response == null) {
      if (typeof failure === 'function') {
        failure(self.processReverseGeocodeResponse(options, response));
      }
    } else {
      if (typeof success === 'function') {
        success(self.processReverseGeocodeResponse(options, response));
      }
    }
  });

};

/**
 * @param {Object} options
 * @param {Object=} response
 * @returns {alkx.ReverseGeocoderReverseGeocodeResponse|undefined}
 */
alk.geocode.ReverseGeocoder.prototype.processReverseGeocodeResponse = function (options, response) {
  return /** @type {alkx.ReverseGeocoderReverseGeocodeResponse|undefined} */ (response);
};
goog.provide('alk.interaction');

goog.require('alk');
alk.interaction = {};
goog.provide('alk.interaction.EditTrailRoutingLayerKeyShortCuts');

goog.require('alk');
goog.require('alk.interaction');

goog.require('alkx.EditTrailRoutingLayerKeyShortCutsOptions');

/**
 * @classdesc
 * An object of this class gives an interaction that assigns key codes
 * and modifiers to the prevRoute, and nextRoute operations of a
 * {@link alk.layer.EditTrailRoutingLayer}.
 *
 * The defaults are:
 *
 * * CTRL-Z or META-Z  calls prevRoute.
 * * CTRL-SHIFT-Z or META-SHIFT-Z calls nextRoute.
 * * CTRL-Y or META-Y calls nextRoute.
 *
 * @description
 * This constructor creates an Interaction object that responds to
 * certain keys that are used in manipulating the Edit Trail Routing Layer.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {alkx.EditTrailRoutingLayerKeyShortCutsOptions} options Options.
 * @api
 */
alk.interaction.EditTrailRoutingLayerKeyShortCuts = function(options) {

  var KEYCODE_PULL_DEFAULT = 90; // This code is 'z'.
  var KEYCODE_FORW_DEFAULT = 89; // This code is 'y'.
  var self = this;
  /** @type {olx.interaction.InteractionOptions} */
  var opts = {
    handleEvent:
         /**
          * @param {ol.MapBrowserEvent} evt
          * @returns {boolean}
          */
         function (evt) {
            return self.handleMapBrowserEvent(evt);
         }
  };

  alk.interaction.EditTrailRoutingLayerKeyShortCuts.base(this, 'constructor', opts);

  this.prevRouteCondition_ = options.prevRouteCondition ||
    function (mapBrowserEvent) {
      var keyEvent = mapBrowserEvent.originalEvent;
      var keyCode = keyEvent.keyCode;
      if (keyEvent.metaKey || keyEvent.ctrlKey) {
        if (keyEvent.shiftKey) {
          return false;
        } else {
          return keyCode === KEYCODE_PULL_DEFAULT;
        }
      } else {
        return false;
      }
    };

  this.nextRouteCondition_ = options.nextRouteCondition ||
    function (mapBrowserEvent) {
      var keyEvent = mapBrowserEvent.originalEvent;
      var keyCode = keyEvent.keyCode;
      if (keyEvent.metaKey || keyEvent.ctrlKey) {
        if (keyEvent.shiftKey) {
          return keyCode === KEYCODE_PULL_DEFAULT;
        } else {
          return keyCode === KEYCODE_FORW_DEFAULT;
        }
      } else {
        return false;
      }
    };

  this.routingLayer = options.routingLayer;
};
goog.inherits(alk.interaction.EditTrailRoutingLayerKeyShortCuts, ol.interaction.Interaction);

/**
 * @type {ol.EventsConditionType}
 * @private
 */
alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.prevRouteCondition_;

/**
 * @type {ol.EventsConditionType}
 * @private
 */
alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.nextRouteCondition_;

/**
 * @type {alk.layer.EditTrailRoutingLayer}
 */
alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.routingLayer;

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides to call 'prevRoute' or 'nextRoute' on the
 * associated {@link alk.layer.EditTrailRoutingLayer}.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {alk.interaction.EditTrailRoutingLayerKeyShortCuts}
 * @api
 */
alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type === "keydown" /* ol.events.EventType.KEYDOWN */) {
    if (this.prevRouteCondition_(mapBrowserEvent)) {
      this.routingLayer.prevRoute();
      stopEvent = true;
    } else if (this.nextRouteCondition_(mapBrowserEvent)) {
      this.routingLayer.nextRoute();
      stopEvent = true;
    }
  }
  if (stopEvent) {
    mapBrowserEvent.preventDefault();
  }
  return !stopEvent;
};
goog.provide('alk.interaction.Snap');

goog.require('alk.interaction');


/**
 * @classdesc
 *
 * NOTE: This class extends ol.interaction.Snap to fix an anomaly with
 * ol.interaction.Snap in OpenLayers 4.x. This class may only be used
 * with ol-debug.js (not ol.js) as the method this class needs to override is
 * inaccessible in ol.js.
 *
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link ol.source.Vector} or {@link ol.Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Note: This class extends ol.interaction.Snap in order to fix a problem
 * that breaks the conditions coordinate == map.getCoordinateFromPixel(pixel) &&
 * map.getPixelFromCoordinate(coordinate) == pixel for the selected snapped
 * to vertex.
 *
 * This class may only work with ol-debug.
 *
 * Example:
 *
 *     var snap = new alk.interaction.Snap({
 *       source: source
 *     });
 *
 * @constructor
 * @extends {ol.interaction.Snap}
 * @param {olx.interaction.SnapOptions=} opt_options Options.
 */
alk.interaction.Snap = function (opt_options) {
  alk.interaction.Snap.base(this, 'constructor', opt_options);
};
goog.inherits(alk.interaction.Snap, ol.interaction.Snap);

/**
 * This can only work with ol-debug.
 *
 * @param {ol.Pixel} pixel Pixel
 * @param {ol.Coordinate} pixelCoordinate Coordinate
 * @param {ol.PluggableMap} map Map.
 * @return {ol.SnapResultType} Snap result
 */
alk.interaction.Snap.prototype.snapTo = function(pixel, pixelCoordinate, map) {
  var result = alk.interaction.Snap.base(this, 'snapTo', pixel, pixelCoordinate, map);
  // The resultant pixel, if snapped, is rounded to integer elements.
  var vertexPixel = null;
  if (result.vertex != null) {
    // Force the vertexPixel back according to its full map resolution.
    vertexPixel = map.getPixelFromCoordinate(result.vertex);
  }
  return {
    snapped: result.snapped,
    vertex: result.vertex,
    vertexPixel: vertexPixel
  };
};
goog.provide('alk.style');

goog.require('alk');

alk.style = {};
goog.provide('alk.style.Shadow');

/**
 * @classdesc
 * This style provides a shadow.
 * NOTE: This class takes advantage of ol.style.Image, which is a
 * non public base class. It may only be used if using ol-debug.js
 *
 * @description
 * This constructor creates a Style Function that will shadow
 * a particular style that has a shape.
 *
 * @param {{
 *    fill: (ol.style.Fill|undefined),
 *    radius: (number|undefined),
 *    size: (Array.<number>|undefined),
 *    blur: (number|undefined),
 *    opacity: (number|undefined),
 *    rotateWidthView: (boolean|undefined),
 *    scale: (number|undefined),
 *    snapToPixel: (boolean|undefined),
 *    rotation: (number|undefined)
 * }} opt_options
 * @constructor
 * @extends {ol.style.Image}
 * @api
 */
alk.style.Shadow = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  if (options.fill !== undefined) {
    this.fill_ = options.fill;
  } else {
    this.fill_ = new ol.style.Fill({ color: 'rgba(10,10,10,0.25)'});
  }
  this.size_ = [options.size[0], options.size[1]];

  var opts = {
    opacity: options.opacity || 1.0,
    rotateWithView: options.rotateWithView || false,
    rotation: options.rotation !== undefined ? options.rotation : 0,
    scale: options.scale || 1.0,
    snapToPixel: options.snapToPixel || false
  };
  alk.style.Shadow.base(this, 'constructor', opts);

  this.radius_ = options.radius ||  Math.min(this.size_[0], this.size_[1])/2;
  this.blur_ = options.blur === 0 ? 0 : (options.blur || this.radius_ / 3);
  var offsetX = options.offset ? (options.offset[0] || 3) : 3;
  var offsetY = options.offset ? (options.offset[1] || 1) : 1;
  this.anchor_ = [this.size_[0]/2 - offsetX, this.size_[1]/2 - offsetY];
  this.origin_ = [0,0];

  this.render_(null);
};
goog.inherits(alk.style.Shadow, ol.style.Image);


/**
 * @inheritDoc
 * @this {alk.style.Shadow}
 * @api
 */
alk.style.Shadow.prototype.getOrigin = function() {
  return this.origin_;
};

/**
 * @this {alk.style.Shadow}
 * @api
 */
alk.style.Shadow.prototype.getRadius = function() {
  return this.radius_;
};

/**
 * @inheritDoc
 * @this {alk.style.Shadow}
 * @api
 */
alk.style.Shadow.prototype.getHitDetectionImageSize = function() {
  return this.imageSize_;
};


/**
 * @inheritDoc
 * @this {alk.style.Shadow}
 * @api
 */
alk.style.Shadow.prototype.getAnchor = function() {
  return this.anchor_;
};

/**
 * @inheritDoc
 * @this {alk.style.Shadow}
 * @api
 */
alk.style.Shadow.prototype.getSize = function() {
  return this.size_;
};

/**
 * Get the fill style for the shape.
 * @return {ol.style.Fill} Fill style.
 * @this {alk.style.Shadow}
 * @api
 */
alk.style.Shadow.prototype.getFill = function() {
  return this.fill_;
};

/**
 * @override
 * @param {number} pixelRatio
 * @returns {HTMLCanvasElement|HTMLVideoElement|Image}
 * @this {alk.style.Shadow}
 */
alk.style.Shadow.prototype.getImage = function (pixelRatio) {
  return this.canvas_;
};


/**
 * @inheritDoc
 * @this {alk.style.Shadow}
 */
ol.style.RegularShape.prototype.getImageSize = function() {
  return this.imageSize_;
};


/**
 * @inheritDoc
 * @this {alk.style.Shadow}
 */
alk.style.Shadow.prototype.getHitDetectionImage = function() {
  return this.canvas_;
};


/**
 * @inheritDoc
 * @this {alk.style.Shadow}
 */
alk.style.Shadow.prototype.getImageState = function() {
  return 2;// not in the API. ol.ImageState.LOADED;
};

/**
 * @param {ol.style.AtlasManager} atlasManager
 * @this {alk.style.Shadow}
 * @protected
 */
alk.style.Shadow.prototype.render_ = function (atlasManager) {
  var size = this.getSize();
  var canvas = document.createElement('CANVAS');
  canvas.width = size[0];
  canvas.height = size[1];
  var context = canvas.getContext('2d');
  this.canvas_ = context.canvas;

  // canvas.width and height are rounded to the closest integer
  this.size_ = [this.canvas_.width, this.canvas_.height];

  this.draw_(context);

  this.imageSize_ = this.size_;
};

/**
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @this {alk.style.Shadow}
 * @private
 */
alk.style.Shadow.prototype.draw_ = function(context) {
  context.beginPath();
  context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  context.fillStyle = this.fill_.getColor().toString();
  var centerX = this.size_[0]/2;
  var centerY = this.size_[1]/2;
  context.arc(centerX, centerY, this.radius_, 2 * Math.PI, 0);
  context.fill();
  context.closePath();
};
goog.provide('alk.style.StrokeQueue');

goog.require('alk.style');
/**
 * @classdesc
 * An instance of this class holds a rotating queue of strokes.
 * @description
 * This constructor creates a Queue of styles of differing colors
 * and a set width. If the width is set by means of {@link alk.style.StrokeQueue#setWidth}
 * all strokes contained within will have their width property updated to the specified value.
 * If strokes is defined, the colors option is ignored. If the colors option is set, it generates
 * a list of strokes with those colors. If width is set, it sets the width of all strokes.
 * The default width is 9 (pixels).
 * @constructor
 * @param {{colors: (Array.<string>|undefined),
 *          strokes: (Array.<ol.style.Stroke>|undefined),
 *          width: (number|undefined)}=} opt_options
 * @extends {ol.Object}
 * @api
 */
alk.style.StrokeQueue = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  var width = options.width || 9;

  this.currentIndex = 0;
  alk.style.StrokeQueue.base(this, 'constructor');

  if (options.strokes !== undefined) {
    this.strokes = options.strokes;
  } else {
    if (options.colors !== undefined) {
      var strokes = [];
      if (options.colors instanceof Array) {
        options.colors.forEach(function (color) {
          strokes.push(new ol.style.Stroke({color: color}));
        });
        this.strokes = strokes;
      } else {
        strokes.push(new ol.style.Stroke({color: options.colors}));
      }
      this.strokes = strokes;
    }
  }
  this.on('change:width', this.updateWidth_);
  this.set('width', width);
};
goog.inherits(alk.style.StrokeQueue, ol.Object);

/**
 * @returns {number}
 * @this {alk.style.StrokeQueue}
 * @api
 */
alk.style.StrokeQueue.prototype.getWidth = function () {
  return /** @type {number} */ (this.get('width'));
};

/**
 * @param {number} width
 * @this {alk.style.StrokeQueue}
 * @api
 */
alk.style.StrokeQueue.prototype.setWidth = function (width) {
  this.set('width', width);
};

/**
 * @private
 * @this {alk.style.StrokeQueue}
 */
alk.style.StrokeQueue.prototype.updateWidth_ = function () {
  var width = /** @type{number} */(this.get('width'));
  this.strokes.forEach(function (stroke) {
    stroke.setWidth(width);
  });
};

/**
 * The stroke the predetermined strokes.
 * @type {Array.<ol.style.Stroke>}
 * @api
 */
// This assignment is a pass through function application because the closure
// compiler gives the following error on a direct assignment:
//   ERROR - Prototype property strokes should be a primitive, not an Array or Object.
alk.style.StrokeQueue.prototype.strokes = function () {
  return [
    new ol.style.Stroke({color: 'rgba(018,062,196,0.5)'}), // #123ec4
    new ol.style.Stroke({color: 'rgba(184,074,000,0.5)'}), // #b84a00
    new ol.style.Stroke({color: 'rgba(115,024,161,0.5)'}), // #7318a1
    new ol.style.Stroke({color: 'rgba(031,109,168,0.5)'}), // #1e6ca8
    new ol.style.Stroke({color: 'rgba(181,015,089,0.5)'}), // #b50e59
    new ol.style.Stroke({color: 'rgba(069,013,189,0.5)'}), // #450dbd
    new ol.style.Stroke({color: 'rgba(000,157,196,0.5)'}), // #009dc4
    new ol.style.Stroke({color: 'rgba(230,061,000,0.5)'})  // #e63d00
  ];
}();

/**
 * @returns {ol.style.Stroke}
 * @this {alk.style.StrokeQueue}
 * @api
 */
alk.style.StrokeQueue.prototype.next = function() {
  return this.strokes[this.currentIndex++ % this.strokes.length];
};
goog.provide('alk.style.RoutingLayerStyle');

goog.require('alk.style');

/**
 * @classdesc
 * This is the base class that provides a styling function for the RouteLayer.
 * @description
 * This constructor is the base constructor for styling the Routing Layers.
 * @constructor
 * @extends {ol.Object}
 * @abstract
 * @api
 */
alk.style.RoutingLayerStyle = function () {
  alk.style.RoutingLayerStyle.base(this, 'constructor');
};
goog.inherits(alk.style.RoutingLayerStyle, ol.Object);

/**
 * @type {ol.layer.Vector}
 * @api
 */
alk.style.RoutingLayerStyle.prototype.layer;

/**
 * This method is called by the RoutingLayer when installed. This
 * method also registers for the 'updating' property change on the
 * layer and calls 'beginUpdate' and 'endUpdate' for the values of
 * true and false respectively.
 *
 * @param {ol.layer.Vector} layer
 * @this {alk.style.RoutingLayerStyle}
 */
alk.style.RoutingLayerStyle.prototype.setLayer = function (layer) {
  var self = this;
  this.set('layer', this.layer = layer);
  var source;
  if (this.layer && (source = this.layer.getSource())) {
    source.on('change:updating', function (event) {
      var source = /** @type {ol.source.Vector} */(event.target);
      var updating = /** @type {boolean} */ (source.get('updating'));
      self.setUpdating(updating);
    });
    // In case the source is changed.
    this.layer.on('change:source', function (event) {
      var source = /** @type {ol.layer.Vector} */(event.target).getSource();
      source.on('change:updating', function (event) {
        var updating = /** @type {boolean} */ (source.get('updating'));
        self.setUpdating(updating);
      });
    });
  }
};

/**
 * This method is called when the 'updating' property of {@link alk.layer.RoutingLayer} is
 * changed. This call gives the style the ability to style things differently when being updated.
 * @param {boolean} value
 * @api
 */
alk.style.RoutingLayerStyle.prototype.setUpdating = function (value) {
};

/**
 * This function provides the styleFunction for the Routing Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @abstract
 * @api
 */
alk.style.RoutingLayerStyle.prototype.styleFunction = function(feature, resolution) {};
goog.provide('alk.style.LineRouteStyle');

goog.require('alk.style.RoutingLayerStyle');

/**
 * @classdesc
 * An instance of this class provides a {@link ol.style.StyleFunction} for
 * the {@link alk.layer.MultiRoutingLayer} that only draws route lines of a
 * designated stroke style.
 * @description
 * This constructor creates a Style Function for styling the
 * {@link alk.layer.MultiRoutingLayer}.
 *
 * This style ignores styling for any Stops and they will not be rendered.
 *
 * All Features pertaining the RoutingLayer will have the 'routeId' property set.
 * Paths:
 *   These are features with LineString and MultiLineString geometries.
 * Stops:
 *   These features will have the following properties set:
 *     'stop' : (Array.<number>) contains the original coordinates of the stop.
 *     'stopIndex' : (number) contains a [0,n) index in the presented stops.
 *     'stopType' : (alk.val.StopType|undefined).
 *
 * Features tagged with 'stop' may also be tagged with 'stopType' of {@link ol.val.StopType}
 * according to the policy set forth in the RoutingLayer. For instance, a Route with 'hubRouting'
 * set will not have a 'stop' feature with a 'stopType' of 'Destination'.
 *
 * @param {{
 *  strokeStyle: (ol.style.Stroke|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.RoutingLayerStyle}
 * @api
 */
alk.style.LineRouteStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  if (options.strokeStyle !== undefined) {
    this.strokeStyle_ = options.strokeStyle;
  }
  if (this.strokeStyle_ === undefined) {
    this.strokeStyle_ =
      new ol.style.Stroke({
        color: 'rgba(255,243,123,0.5)',
        width: 9
      });
  }
  if (this.defaultIcon_ === undefined) {
    this.defaultIcon_ =  new ol.style.Stroke({
      color: 'red',
      width: 9
    });
  }
  alk.style.LineRouteStyle.base(this, 'constructor');
};
goog.inherits(alk.style.LineRouteStyle, alk.style.RoutingLayerStyle);

/**
 * @type {ol.style.Stroke}
 * @private
 */
alk.style.LineRouteStyle.prototype.strokeStyle_;

/**
 * This function sets the stroke style for this LineRouteStyle.
 * @param {ol.style.Stroke} strokeStyle
 * @this {alk.style.LineRouteStyle}
 * @api
 */
alk.style.LineRouteStyle.prototype.setStrokeStyle = function (strokeStyle) {
  this.strokeStyle_ = strokeStyle;
};


/**
 * @type {boolean}
 */
alk.style.LineRouteStyle.prototype.updateInProgress_;

/**
 * This function returns whether the style is in between 'beginUpdate' and
 * 'endUpdate' calls from the {@link alk.layer.RoutingLayer}.
 *
 * @returns {boolean}
 * @this {alk.style.LineRouteStyle}
 */
alk.style.LineRouteStyle.prototype.isUpdateInProgress = function () {
  return this.updateInProgress_;
};

/**
 * This method is called when the 'updating' property of the
 * associated {@link alk.layer.RoutingLayer} is changed.
 *
 * @param {!boolean} value
 * @this {alk.style.LineRouteStyle}
 * @override
 */
alk.style.LineRouteStyle.prototype.setUpdating = function (value) {
  this.updateInProgress_ = value;
  if (value) {
    if (this.layer) {
      var features = this.layer.getSource().getFeatures();
      features.forEach(function(s) {s.changed();});
    }
  }
};

/**
 * @type {ol.style.Stroke}
 * @private
 */
alk.style.LineRouteStyle.prototype.defaultIcon_;

/**
 * This function sets the update stroke style.
 * @param {ol.style.Stroke} stroke
 * @this {alk.style.LineRouteStyle}
 * @api
 */
alk.style.LineRouteStyle.prototype.setUpdateStrokeStyle = function (stroke) {
  this.defaultIcon_ = stroke;
};

/**
 * This function returns the Update Stroke Style, which is the same for all features and
 * resolutions.
 * @param {ol.Feature} feature This argument is ignored.
 * @param {number} resolution This argument is ignored.
 * @returns {ol.style.Stroke}
 * @this {alk.style.LineRouteStyle}
 * @api
 */
alk.style.LineRouteStyle.prototype.getUpdateStrokeStyle = function (feature, resolution) {
  if (this.defaultIcon_ == null) {
    var color = this.strokeStyle_.getColor();
    // need to clone the color array or otherwise it messes up the string->color array cache.
    var colora = ol.color.asArray(/** @type {ol.Color|string} */(color));
    var nc = colora.map(function(m) {return m;});
    nc[3] = nc[3] ? nc[3] * 0.4 : 0.4;
    this.defaultIcon_ = new ol.style.Stroke({
      color: nc,
      width: this.strokeStyle_.getWidth()
    });
  }
  return this.defaultIcon_;
};

/**
 * This function returns the stroke style for the route.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {ol.style.Stroke}
 * @this {alk.style.LineRouteStyle}
 * @api
 */
alk.style.LineRouteStyle.prototype.getStrokeStyle = function (feature, resolution) {
  if (this.isUpdateInProgress()) {
    return this.getUpdateStrokeStyle(feature, resolution);
  }
  return this.strokeStyle_;
};

/**
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @override
 * @this {alk.style.LineRouteStyle}
 * @api
 */
alk.style.LineRouteStyle.prototype.styleFunction = function(feature, resolution) {
  var styles = [];
  var strokeStyle = this.getStrokeStyle(feature, resolution);
  if (feature.getGeometry().getType() === 'Point') {
    // We are not providing styles for stops.
  } else if (feature.getGeometry().getType() === 'LineString') {
    styles.push(new ol.style.Style({
      stroke: strokeStyle
    }));
  } else if (feature.getGeometry().getType() === 'MultiLineString') {
    styles.push(new ol.style.Style({
      stroke: strokeStyle
    }));
  } else {
    console.warn("LineRouteStyle: Unsupported Style " + feature.getGeometry().getType());
  }
  return styles;
};
goog.provide('alk.style.QueuedLineRouteStyle');

goog.require('alk.style');
goog.require('alk.style.StrokeQueue');
goog.require('alk.style.LineRouteStyle');

/**
 * @classdesc
 * An instance of this class provides a {@link ol.style.StyleFunction} for
 * the {@link alk.layer.MultiRoutingLayer} that only draws route lines of a
 * designated stroke style.
 *
 * @description
 * This constructor creates a Style Function for displaying lines in the
 * Routing Layer layers.
 *
 * It extends the functionality of the LineRouteStyle by installing a
 * StrokeQueue that will round robin a collection of strokes depending on
 * a Feature's 'routeId' attribute.
 *
 * @param {{
 *  strokeQueue: (alk.style.StrokeQueue|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.LineRouteStyle}
 * @api
 */
alk.style.QueuedLineRouteStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  if (options.strokeQueue !== undefined) {
    this.strokeQueue_ = options.strokeQueue;
  }
  alk.style.QueuedLineRouteStyle.base(this, 'constructor');
  if (this.strokeQueue_ === undefined) {
    this.strokeQueue_ = new alk.style.StrokeQueue({width: 9});
  }
  this.routeStrokeMap_ = {};
};
goog.inherits(alk.style.QueuedLineRouteStyle, alk.style.LineRouteStyle);

/**
 * @type {alk.style.StrokeQueue}
 * @private
 */
alk.style.QueuedLineRouteStyle.prototype.strokeQueue_;

/**
 * This function sets the stroke style for this QueuedLineRouteStyle.
 * @param {alk.style.StrokeQueue} strokeQueue
 * @this {alk.style.QueuedLineRouteStyle}
 * @api
 */
alk.style.QueuedLineRouteStyle.prototype.setStrokeQueue = function (strokeQueue) {
  this.strokeQueue_ = strokeQueue;
};

/**
 * This function returns the stroke Queue.
 * @returns {alk.style.StrokeQueue|undefined}
 * @this {alk.style.QueuedLineRouteStyle}
 * @api
 */
alk.style.QueuedLineRouteStyle.prototype.getStrokeQueue = function () {
  return this.strokeQueue_;
};

/**
 * @type {Object.<string, ol.style.Stroke>}
 * @private
 */
alk.style.QueuedLineRouteStyle.prototype.routeStrokeMap_;

/**
 * This function returns the color in the routeStrokeMap for the given routeId.
 * If there is no color in the map, the next one is gotten from the StrokeQueue
 * and assigned.
 * @param {string} routeId The Route Id
 * @param {number} resolution
 * @return {ol.style.Stroke}
 * @this {alk.style.QueuedLineRouteStyle}
 */
alk.style.QueuedLineRouteStyle.prototype.getStrokeStyleForRouteId = function (routeId, resolution) {
  var stroke = this.routeStrokeMap_[routeId];
  if (stroke === undefined) {
    stroke = this.routeStrokeMap_[routeId] = this.strokeQueue_.next();
  }
  return new ol.style.Stroke({
    color: stroke.getColor(),
    width: this.getWidthForResolution(resolution)
  });
};

/**
 * This function clears the assigned, if any, stroke style for the given routeId identifier.
 *
 * @param {string} routeId
 * @this {alk.style.QueuedLineRouteStyle}
 * @api
 */
alk.style.QueuedLineRouteStyle.prototype.clearStrokeForRouteId = function (routeId) {
  delete this.routeStrokeMap_[routeId];
};

/**
 * This function returns the 'update' stroke style for the feature's routeId property
 * according to the default or supplied {@link alk.style.StrokeQueue}. This stroke
 * will have the color at 0.4 of its original opacity.
 *
 * @override
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @return {ol.style.Stroke}
 * @this {alk.style.QueuedLineRouteStyle}
 */
alk.style.QueuedLineRouteStyle.prototype.getUpdateStrokeStyle = function (feature, resolution) {
  var routeId = /** @type {string} */ (feature.get('routeId'));
  var stroke = this.getStrokeStyleForRouteId(routeId, resolution);
  var color = stroke.getColor();
  // Clone the color array. Otherwise, it messes up the internal OL string->color array cache.
  var colora = ol.color.asArray(/** @type {ol.Color|string} */(color));
  var nc = colora.map(function(m) {return m;});
  // Opacity is set to 40% of it, or just 40%
  nc[3] = nc[3] ? nc[3] * 0.4 : 0.4;
  return new ol.style.Stroke({
    color: nc,
    width: stroke.getWidth()
  });
};

/**
 * This method gets the stroke style using the feature's 'routeId' property according
 * to default or supplied {@link alk.style.StrokeQueue}. If a stroke has not been
 * assigned to the value of the feature's 'routeId' property, the next available from
 * the StrokeQueue is taken, and that stroke is then mapped to the 'routeId'.
 *
 * @override
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @return {ol.style.Stroke}
 * @this {alk.style.QueuedLineRouteStyle}
 */
alk.style.QueuedLineRouteStyle.prototype.getStrokeStyle = function (feature, resolution) {
  if (this.isUpdateInProgress()) {
    return this.getUpdateStrokeStyle(feature, resolution);
  } else {
    var routeId = /** @type {string} */ (feature.get('routeId'));
    return this.getStrokeStyleForRouteId(routeId, resolution);
  }
};

/**
 * This function returns the stroke with to be used at the resolution.
 * It is married to the Road Surface Style, in that the road surface
 * lines will be wider than the lines used here.
 * @param {number} resolution
 * @returns {number}
 * @this {alk.style.QueuedLineRouteStyle}
 */
alk.style.QueuedLineRouteStyle.prototype.getWidthForResolution = function (resolution) {
  if (resolution < 1000) {
    return Math.log(resolution);
  } else {
    return 1.5 * Math.log(resolution);
  }
};
goog.provide('alk.style.StopsRouteStyle');

goog.require('alk.color');
goog.require('alk.style');
goog.require('alk.style.Shadow');
goog.require('alk.style.QueuedLineRouteStyle');

/**
 * @classdesc
 * An instance of this class provides a {@link ol.style.StyleFunction} for
 * the {@link alk.layer.MultiRoutingLayer} that draws route lines of a
 * designated stroke style and stops along the route using a start circle,
 * indexed circle for interim stops, and a destination circle if applicable.
 * @description
 * This constructor creates a Style Function that styles the MutiRoutingLayer.
 *
 * All Features pertaining the RoutingLayer will have the 'routeId' property set.
 * Paths:
 *   These are features with 'LineString' and 'MultiLineString' geometries.
 * Stops:
 *   These features will have the following properties set:
 *     'stop' : (Array.<number>) contains the original coordinates of the stop.
 *     'stopIndex' : (number) contains a [0,n) index in the presented stops.
 *     'logicalStopIndex: (number) contains a[0,n] index in the presented stops that do not include
 *                                 a stopType of {@link alk.val.StopType.ViaPoint}.
 *     'stopType' : (alk.val.StopType|undefined).
 *     'hubRouting' : (boolean|undefined);
 *
 * Features tagged with 'stop' may also be tagged with 'stopType' of {@link ol.val.StopType}
 * according to the policy set forth in the RoutingLayer. For instance, a Route with 'hubRouting'
 * set will not have a 'stop' feature with a 'stopType' of {@link alk.val.StopType.Destination}.
 *
 * The default behavior is to style the route Origin with a green circle, and the route Destination
 * with a red circle. All interim stops will be styled with the stroke style for the
 * its route, and they will contain letters, or ordinal numbers depending on whether hubRouting
 * is true, or not, respectively.
 *
 * @param {{
 *  strokeQueue: (alk.style.StrokeQueue|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.QueuedLineRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  var opts = {
    strokeQueue: options.strokeQueue
  };
  alk.style.StopsRouteStyle.base(this, 'constructor', opts);
};
goog.inherits(alk.style.StopsRouteStyle, alk.style.QueuedLineRouteStyle);

/**
 * This function returns the default image for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.Origin}.
 *
 * For this implementation, the defaultOriginImage is used for all stopTypes of
 * {@link alk.val.StopType.Origin} regardless of the route's stroke color.
 *
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.defaultOriginImage = function() {
  return new ol.style.Circle({
    radius: 6.6,
    fill: new ol.style.Fill({
      color: 'white',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(039,159,000,1.0)',
      width: 5.5
    })
  });
};

/**
 * This function returns the default style for a stop feature with the feature's
 * 'stopType' property of {@link alk.val.StopType.Destination}.
 *
 * For this implementation, the defaultOriginImage is used for all stopTypes of
 * {@link alk.val.StopType.Destination} regardless of the route's stroke color.
 *
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.defaultDestinationImage = function() {
  return new ol.style.Circle({
    radius: 6.6,
    fill: new ol.style.Fill({
      color: 'white',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(191,037,037,1.0)',
      width: 5.5
    })
  });
};

/**
 * This function returns the default image for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.ViaPoint}.
 *
 * For this implementation, the defaultOriginImage is used for all stopTypes of
 * {@link alk.val.StopType.Origin} regardless of the route's stroke color.
 *
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.defaultViaPointImage = function() {
  return new ol.style.Circle({
    radius: 5,
    fill: new ol.style.Fill({
      color: 'blue',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(191,037,037,1.0)',
      width: 1
    })
  });
};

/**
 * This function returns the default image for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.WayPoint}.
 *
 * For this implementation, the defaultOriginImage is NOT used.
 * The {@link alk.style.StopsRouteStyle#getWayPointImage}
 * returns a different image according to the route's stroke color.
 *
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.defaultWayPointImage = function() {
  var width = 3;
  var radius = 9;
  var color = 'blue';
    return new ol.style.Circle({
    radius: radius,
    fill: new ol.style.Fill({
      color: 'white',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: color,
      width: width
    })
  });
};

/**
 * This function returns the image to use in styling a stop feature with
 * the feature's 'stopType' property of {@link alk.val.StopType.Origin}.
 *
 * This implementation ignores the stroke style and returns the
 * default origin image.
 *
 * @param {ol.style.Stroke} stroke The route's stroke style.
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getOriginImage = function (stroke) {
  return this.defaultOriginImage();
};

/**
 * This function returns the {@link ol.style.Style} stop feature with the
 * feature's 'stopType' property set to {@link alk.val.StopType.Origin}.
 *
 * @param {ol.Feature} feature The stop feature
 * @param {number} resolution
 * @returns {ol.style.Style|null}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getOriginStyleFunction = function (feature, resolution) {
  var strokeStyle = this.getStrokeStyle(feature, resolution);
  return new ol.style.Style({image: this.getOriginImage(strokeStyle)});
};

/**
 * This function returns the image to use in styling a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.WayPoint}.
 *
 * This implementation returns a {@link ol.style.Circle} styled with a white fill, and a color
 * border of the route's stroke color. The width of the stroke is 3 pixels, and the radius of the
 * circle is 9 pixels. The stroke color is 1.0 opacity equivalent to the route's stroke color,
 * which should be at 0.5 opacity.
 *
 * @param {ol.style.Stroke} stroke The route's stroke style.
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getWayPointImage = function (stroke) {
  var width = 3;
  var radius = 9;
  var color = stroke.getColor();
  var ncolor = alk.color.shadeColor(color, 0); // gets rid of alpha component
  return new ol.style.Circle({
    radius: radius,
    fill: new ol.style.Fill({
      color: 'white',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: ncolor,
      width: width
    })
  });
};

/**
 * This function returns the text for the WayPoint according to the given
 * stroke style.
 *
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @this {alk.style.StopsRouteStyle}
 * @returns {ol.style.Text}
 */
alk.style.StopsRouteStyle.prototype.getWayPointText = function (feature, resolution) {
  var strokeStyle = this.getStrokeStyle(feature, resolution);
  var color = strokeStyle ? strokeStyle.getColor() : 'blue';
  var text;
  var index = /**@type{number}*/(feature.get('logicalStopIndex'));
  // We should never get zero here.
  if (feature.get('hubRouting') === true) {
    text = this.getTextForIndex(index-1);
  } else {
    text = '' + index;
  }
  var font = '11px Calibri,sans-serif';
  if (index > 99) {
    font = '8px Calibri,sans-serif';
  }
  color = alk.color.shadeColor(color, 0); // gets rid of alpha component.
  return new ol.style.Text ({
    font: font,
    text: text,
    textBaseline: 'center',
    textAlign: 'center',
    fill: new ol.style.Fill({
      color: color
    })
  });
};

/**
 * This style function returns a style for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.WayPoint}.
 *
 * This implementation returns the image returned by {@link alk.style.StopsRouteStyle#getWayPointImage},
 * superimposed with a index corresponding to the feature's 'logicalStopIndex' property. The index is
 * a letter or number based on whether the feature's 'hubRouting' property is set to true,
 * or not, respectively.
 *
 * @param {ol.Feature} feature The stop feature
 * @param {number} resolution
 * @returns {ol.style.Style|null}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getWayPointStyleFunction = function (feature, resolution) {
  var strokeStyle = this.getStrokeStyle(feature, resolution);
  var textStyle = this.getWayPointText(feature, resolution);
  var image = this.getWayPointImage(strokeStyle);
  return new ol.style.Style({
    image: image,
    text: textStyle
  });
};


/**
 * This function returns the image to use in styling a stop feature with
 * the feature's 'stopType' property of {@link alk.val.StopType.ViaPoint}.
 *
 * This implementation ignores the stroke style and returns the value
 * from {@link alk.style.StopsRouteStyle#defaultViaPointImage}.
 *
 * @param {ol.style.Stroke} stroke The route's stroke style.
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getViaPointImage = function (stroke) {
  var width = 2;
  var radius = 5;
  var color = stroke.getColor();
  var ncolor = alk.color.shadeColor(color, 0); // gets rid of alpha component
  return new ol.style.Circle({
    radius: radius,
    fill: new ol.style.Fill({
      color: 'white',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: ncolor,
      width: width
    })
  });
};

/**
 * This style function returns a style for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.ViaPoint}.
 *
 * This implementation returns a style containing the image
 * returned by {@link alk.style.StopsRouteStyle#getViaPointImage}.
 *
 * @param {ol.Feature} feature The stop feature
 * @param {number} resolution
 * @returns {ol.style.Style|null}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getViaPointStyleFunction = function (feature, resolution) {
  var strokeStyle = this.getStrokeStyle(feature, resolution);
  return new ol.style.Style({ image: this.getViaPointImage(strokeStyle) });
};


/**
 * This function returns the image to use in styling a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.Destination}.
 *
 * This implementation ignores the stroke style and returns the
 * {@link alk.style.StopsRouteStyle#defaultDestinationImage}.
 *
 * @param {ol.style.Stroke} stroke The route's stroke style.
 * @returns {ol.style.Image}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getDestinationImage = function(stroke) {
  return this.defaultDestinationImage();
};

/**
 * This style function returns a style for a stop with the
 * feature's 'stopType' property of {@link alk.val.StopType.Destination}.
 *
 * This implementation returns a style containing the image returned
 * by {@link alk.style.StopsRouteStyle#getDestinationImage}.
 *
 * @param {ol.Feature} feature The stop feature
 * @param {number} resolution
 * @returns {ol.style.Style|null}
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getDestinationStyleFunction = function (feature, resolution) {
  var strokeStyle = this.getStrokeStyle(feature, resolution);
  return new ol.style.Style({ image: this.getDestinationImage(strokeStyle) });
};

/**
 * @type {string}
 * @private
 */
alk.style.StopsRouteStyle.prototype.letterMap_ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

/**
 * @param {number} index
 * @returns {string}
 * @this {alk.style.StopsRouteStyle}
 */
alk.style.StopsRouteStyle.prototype.getTextForIndex = function (index) {
  var letters = '';
  var base = this.letterMap_.length;
  while(index >= 0) {
    var left = index % base;
    letters = this.letterMap_[left] + letters;
    index = Math.floor(index / base);
    if (index === 0) {
      break;
    }
  }
  return letters;
};

/**
 * This function returns an {@link ol.style.Style} that styles a stop feature.
 * The feature will be a Point geometry and will have its 'routeId', 'stop', 'stopIndex', and
 * 'stopType', and 'logicalStopIndex' properties set.
 *
 * This implementation calls out {@link getOriginStyleFunction},
 * {@link getWayPointStyleFunction}, {@link getViaPointStyleFunction},
 * and {@link getDestinationStyleFunction}, for each of the stop features.
 *
 * @param {ol.Feature} feature The stop feature.
 * @param {number} resolution The display resolution.
 * @returns {ol.style.Style|null} If this returns null, no stop will be drawn.
 * @this {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.StopsRouteStyle.prototype.getStopStyle = function(feature, resolution) {
  switch (feature.get('stopType')) {
    case alk.val.StopType.Origin:
      return this.getOriginStyleFunction(feature, resolution);
    case alk.val.StopType.Destination:
      return this.getDestinationStyleFunction(feature, resolution);
    case alk.val.StopType.ViaPoint:
      return this.getViaPointStyleFunction(feature, resolution);
    default:
      return this.getWayPointStyleFunction(feature, resolution);
  }
};

/**
 * This function styles the RoutingLayer.
 *
 * This particular implementation calls out to {@link getStrokeStyle} for color
 * and width of the route. It calls out to {@link getStopStyle} to get styling
 * for Stops.
 *
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @this {alk.style.StopsRouteStyle}
 * @override
 * @api
 */
alk.style.StopsRouteStyle.prototype.styleFunction = function(feature, resolution) {
  var styles = alk.style.StopsRouteStyle.base(this, 'styleFunction', feature, resolution);
  if (feature.get('stop')) {
    var style = this.getStopStyle(feature, resolution);
    if (style) {
      var image = style.getImage();
      var shadow;
      if (image instanceof ol.style.Circle) {
        var radius = image.getRadius();
        radius += image.getStroke().getWidth() / 2;
        radius += 1;
        var size = radius * 2 + 8;
        // We can only use our shadow if we are using ol-debug.js to get access to ol.style.Image
        if (typeof ol.style.Image.prototype.getImageState === 'function') {
          shadow = new alk.style.Shadow({size: [size, size], radius: radius, offset: [1, 0]});
        } else {
          // doesn't currently work
          shadow = new alk.style.ShadowedCircle({radius: radius, offset: [1, 0]});
        }
      } else {
        if (typeof image.getImageSize === 'function') {
          var size = image.getImageSize();
          // We can only use our shadow if we are using ol-debug.js to get access to ol.style.Image
          if (typeof ol.style.Image.prototype.getImageState === 'function') {
            shadow = new alk.style.Shadow({size: [size, size], offset: [4, 2]});
          } else {
            // doesn't currently work
            shadow = new alk.style.ShadowedCircle({radius: size/2, offset: [4, 2]});
          }
        }
      }
      var shadowStyle = new ol.style.Style({image: shadow});
      styles.push(shadowStyle);
      styles.push(style);
    }
  }
  return styles;
};
goog.provide('alk.style.EditRouteStyle');

goog.require('alk.color');
goog.require('alk.style.StopsRouteStyle');

/**
 * @classdesc
 * An instance of this class is a RoutingLayer style function for the
 * {@link alk.layer.RoutingLayer}. However, this particular one is used
 * on a {@link alk.interaction.RouteModify} object to style the
 * the features being modified.
 * @description
 * This constructor creates a Style function that styles the Routing Layer
 * that will be editing the route.
 *
 * Essentially this object reverses the stroke and fill colors
 * of the stops.
 *
 * @param {{
 *  strokeQueue: (alk.style.StrokeQueue|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.EditRouteStyle = function (opt_options) {
  alk.style.EditRouteStyle.base(this, 'constructor', opt_options);
};
goog.inherits(alk.style.EditRouteStyle, alk.style.StopsRouteStyle);

/**
 * This function returns the default image for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.ViaPoint}.
 *
 * It is the reverse of the default used in {@link alk.style.StopsRouteStyle}.
 * This image is only used as a backup if there is no stroke for the
 * route.
 *
 * @returns {ol.style.Image}
 * @override
 * @this {alk.style.EditRouteStyle}
 * @api
 */
alk.style.EditRouteStyle.prototype.defaultViaPointImage = function() {
  return new ol.style.Circle({
    radius: 5,
    fill: new ol.style.Fill({
      color: 'rgba(191,037,037,0.9)',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: 'blue',
      width: 1
    })
  });
};

/**
 * This function returns the image to use in styling a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.ViaPoint}.
 *
 * This implementation returns a {@link ol.style.Circle} styled with a white border, and a color
 * fill of the route's stroke color. The width of the stroke is 1 pixels, and the radius of the
 * circle is 5 pixels.
 *
 * @param {ol.style.Stroke} stroke The route's stroke style.
 * @returns {ol.style.Image}
 * @override
 * @this {alk.style.EditRouteStyle}
 * @api
 */
alk.style.EditRouteStyle.prototype.getViaPointImage = function (stroke) {
  var width = 1;
  var radius = 5;
  var color = stroke.getColor();
  var ncolor = alk.color.shadeColor(color, 0);
  return new ol.style.Circle({
    radius: radius,
    fill: new ol.style.Fill({
      color: "#ffec6e",
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: ncolor,
      width: width
    })
  });
};


/**
 * This style function returns a style for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.WayPoint}.
 *
 * This implementation returns the image returned by {@link alk.style.EditRouteStyle#getViaPointImage}
 * as the purpose is not to move way points so they shouldn't be styled. However, the Route Modify
 * wants something to style with, so it is given a via point style.
 *
 * @param {ol.Feature} feature The stop feature
 * @param {number} resolution
 * @returns {ol.style.Style|null}
 * @override
 * @this {alk.style.EditRouteStyle}
 * @api
 */
alk.style.EditRouteStyle.prototype.getWayPointStyleFunction = function (feature, resolution) {
  var style = this.getViaPointStyleFunction(feature, resolution);
  return style;
};

/**
 *
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @override
 * @this {alk.style.EditRouteStyle}
 */
alk.style.EditRouteStyle.prototype.styleFunction = function(feature, resolution) {
  var layerFeature = /** @type {ol.Feature} */ (feature.get('stopFeature'));
  if (layerFeature) {
    return alk.style.EditRouteStyle.base(this, 'styleFunction', layerFeature, resolution);
  }
  layerFeature = /** @type {ol.Feature} */ (feature.get('lineFeature'));
  if (layerFeature) {
    var stroke = this.getStrokeStyle(layerFeature, resolution);
    var image = this.getViaPointImage(stroke);
    return [
      new ol.style.Style({
        image: image
      })
    ];
  }
  return [];
};
goog.provide('alk.interaction.RouteModify');

goog.require('alk.interaction');
goog.require('alk.interaction.Snap');
goog.require('alk.style.EditRouteStyle');
goog.require('alk.style.StrokeQueue');
goog.require('alk.val.SRS');

goog.require('alkx.interaction.RouteModifyOptions');

/**
 * @classdesc
 * An instance of this class modifies a route in the RoutingLayer.
 *
 * @fires {change:routingLayer} This event fires when the routing layer is updated.
 *
 * @description
 * This constructor creates an Interaction object that gives its
 * user the ability to modify the route in a Routing Layer.
 *
 * @param {alkx.interaction.RouteModifyOptions=} opt_options
 * @extends {ol.interaction.Modify}
 * @constructor
 * @api
 */
alk.interaction.RouteModify = function (opt_options) {
  /** @type {alkx.interaction.RouteModifyOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.modifyFeaturesCollection_ = new ol.Collection();

  var style = this.processStyle(options.style);

  var pixelTolerance = options.pixelTolerance || 2;

  var opts = {
    condition: options.condition,
    //deleteCondition: undefined,
    pixelTolerance: pixelTolerance,
    style: style,
    features: this.modifyFeaturesCollection_,
    wrapX: options.wrapX
  };
  console.log("calling RouteModify.base.constructor");
  alk.interaction.RouteModify.base(this, 'constructor', opts);

  if (options.routingLayer !== undefined) {
    this.set('routingLayer', this.routingLayer = options.routingLayer, true);
  }

  this.stopsPixelTolerance_ = pixelTolerance;

  var self = this;
  this.getSource().on('change:route', function (event) {
    console.log("calling RouteModify.handleChangeRouteEvent_");
    self.handleChangeRouteEvent_(self.getSource());
  });

  this.on('modifystart', function (event) {
    console.log("calling RouteModify.handleModifyStartEvent_");
    self.handleModifyStartEvent_(event);
  });
  this.on('modifyend', function (event) {
    console.log("calling RouteModify.handleModifyEndEvent_");
    self.handleModifyEndEvent_(event);
  });
  this.getSource().on('change:updating', function (event) {
    var updating = /** @type {boolean} */ (self.getSource().get('updating'));
    self.setActive(!updating);
  });
};
goog.inherits(alk.interaction.RouteModify, ol.interaction.Modify);

/**
 * @type {number}
 */
alk.interaction.RouteModify.prototype.stopsPixelTolerance_;

/**
 * @type {alk.layer.RoutingLayer}
 * @api
 */
alk.interaction.RouteModify.prototype.routingLayer;

/**
 * This method sets the routing layer.
 * @param {alk.layer.RoutingLayer} layer The routing layer
 * @fires {change:routingLayer} This event fires when the routing layer is updated.
 * @this {alk.interaction.RouteModify}
 * @api
 */
alk.interaction.RouteModify.prototype.setRoutingLayer = function (layer) {
  this.set('routingLayer', this.routingLayer = layer);
};

/**
 * @type {ol.Collection.<ol.Feature>}
 * @private
 */
alk.interaction.RouteModify.prototype.modifyFeaturesCollection_;

/**
 * @type {ol.Collection.<ol.Feature>}
 * @private
 */
alk.interaction.RouteModify.prototype.stopPointFeaturesCollection_;
/**
 * @type {ol.Collection.<ol.Feature>}
 * @private
 */
alk.interaction.RouteModify.prototype.lineFeaturesCollection_;

/**
 * This function returns the source of the Routing Layer.
 * @returns {alk.source.SingleRoute}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.getSource = function () {
  return /** @type {alk.source.SingleRoute} */ (this.routingLayer.getSource());
};

/**
 * @type {ol.interaction.Snap}
 * @private
 */
alk.interaction.RouteModify.prototype.snapInteraction_;

/**
 * @param {ol.Map} map
 * @this {alk.interaction.RouteModify}
 * @override
 */
alk.interaction.RouteModify.prototype.setMap = function (map) {
  console.log("calling RouteModify.setMap");
  // map.removeInteraction(this) is called.
  if (map == null) {
    // map.removeInteraction
    if (this.getMap() && this.snapInteraction_) {
      this.getMap().removeInteraction(this.snapInteraction_);
    }
  }
  alk.interaction.RouteModify.base(this, 'setMap', map);
  if (map == null) {
    return;
  }

  this.stopPointFeaturesCollection_ = new ol.Collection();
  this.lineFeaturesCollection_ = new ol.Collection();

  var self = this;

  var stopPoints = this.getSource().getStopFeatures();
  if (stopPoints !== undefined) {
    stopPoints = stopPoints.filter(
      function(sp) {
        return self.stopFeaturesFilterFunction(sp);
      });
    this.stopPointFeaturesCollection_.extend(stopPoints);
    this.modifyFeaturesCollection_.extend(stopPoints);
  }
  var lineFeatures = this.getSource().getLineFeatures();
  if (lineFeatures !== undefined) {
    this.lineFeaturesCollection_.extend(lineFeatures);
    this.modifyFeaturesCollection_.extend(lineFeatures);
  }

  if (typeof ol.interaction.Snap.prototype.snapTo === 'function') {
    // Then we can override:
    console.log("Probably using ol-debug.js; overriding ol.interaction.Snap with alk.interaction.Snap");
    this.snapInteraction_ = new alk.interaction.Snap({
      features: this.stopPointFeaturesCollection_,
      pixelTolerance: 20
    });
  } else {
    // Hope for the best?
    console.log("Probably NOT using ol-debug.js; cannot override ol.interaction.Snap with alk.interaction.Snap");
    this.snapInteraction_ = new ol.interaction.Snap({
      features: this.stopPointFeaturesCollection_,
      pixelTolerance: 20
    });
  }

  map.addInteraction(this.snapInteraction_);
};

/**
 * This function is the filter function that returns true or false if the
 * feature should be included in the modifiable features. This function
 * calls out to the potentially overridden function
 * {@link alk.interaction.RouteModify#shouldModify} after extracting
 * stop, stopIndex, and stopType information from the feature.
 *
 * @param {ol.Feature} feature
 * @this {alk.interaction.RouteModify}
 * @returns {boolean}
 */
alk.interaction.RouteModify.prototype.stopFeaturesFilterFunction = function(feature) {
  var index = /** @type {number} */ (feature.get('stopIndex'));
  var stopType = /** @type {alk.val.StopType|undefined} */(feature.get('stopType'));
  var stop = /** @type {Array.<number>} */(feature.get('stop'));
  return this.shouldModify(stop, index, stopType);
};

/**
 * This function decides whether a stop will be modifiable by this
 * Route Modify.
 *
 * @param {Array.<number>} coords
 * @param {number} index
 * @param {alk.val.StopType|undefined} stopType
 * @this {alk.interaction.RouteModify}
 * @returns {boolean}
 * @api
 */
alk.interaction.RouteModify.prototype.shouldModify = function (coords, index, stopType) {
  return stopType === alk.val.StopType.ViaPoint;
};

/**
 * @type {Array.<ol.geom.Geometry>}
 * @private
 */
alk.interaction.RouteModify.prototype.geometryStore_;

/**
 * @type {ol.Feature}
 * @private
 */
alk.interaction.RouteModify.prototype.pendingStopFeature_;

/**
 * This property holds an array corresponding to the current stop
 * features when the modification event began. It holds their
 * initial geometry revisions at the beginning of the modification event.
 *
 * @type {Array.<number>}
 */
alk.interaction.RouteModify.prototype.stopGeoRevisions_;

/**
 * @param {ol.Feature} stop The Stop Feature
 * @returns {boolean}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.isStopModified = function(stop) {
  return this.stopGeoRevisions_[/** @type{number} */(stop.get('stopIndex'))] != stop.getGeometry().getRevision();
};

/**
 * This property holds an array corresponding to the current segment
 * features when the modification event began. It holds their
 * initial geometry revisions at the beginning of the modification event.
 * @type {Array.<number>}
 */
alk.interaction.RouteModify.prototype.segmentGeoRevisions_;

/**
 * @param {ol.Feature} stop The Segment Line Feature
 * @returns {boolean}multi.routing.layer
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.isSegmentModified = function(stop) {
  return this.segmentGeoRevisions_[/** @type{number} */(stop.get('segmentIndex'))] != stop.getGeometry().getRevision();
};

/**
 * This method stores the revisions of the stop and segment features so that
 * it may be determined which features were modified at the end of the
 * modify event.
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.storeRevisions = function () {

  this.stopGeoRevisions_ = this.getSource().getStopFeatures().map(function (s) {
    return s.getGeometry().getRevision();
  });
  this.segmentGeoRevisions_ = this.getSource().getLineFeatures().map(function (s) {
    return s.getGeometry().getRevision();
  });
};

/**
 * This function returns the stop features deemed to be modified since
 * the modify event began.
 *
 * @returns {Array.<ol.Feature>}
 * @this {alk.interaction.RouteModify}
 * @api
 */
alk.interaction.RouteModify.prototype.getModifiedStops = function () {
  var self = this;
  return this.getSource().getStopFeatures().filter(function (stop) {
    return self.isStopModified(stop);
  });
};

/**
 * This function returns the segment features deemed to be modified since
 * the modify event began.
 *
 * @returns {Array.<ol.Feature>}
 * @this {alk.interaction.RouteModify}
 * @api
 */
alk.interaction.RouteModify.prototype.getModifiedSegments = function () {
  var self = this;
  return this.getSource().getLineFeatures().filter(function (segment) {
    return self.isSegmentModified(segment);
  });
};

/**
 * @param {ol.interaction.Modify.Event} event
 * @this {alk.interaction.RouteModify}
 * @private
 */
alk.interaction.RouteModify.prototype.handleModifyStartEvent_ = function (event) {
  var self = this;
  self.geometryStore_ = [];
  var features = event.features;
  features.forEach(function (feature, index) {
    var geom = feature.getGeometry();
    self.geometryStore_[index] = geom.clone();
  });

  var coords = event.mapBrowserEvent.coordinate;
  this.pendingStopFeature_ = this.getStopFeatureByPixel(coords);
  if (this.pendingStopFeature_) {
    this.pendingStopFeature_.set('pending', true);
  }

  // Store the revisions so that we can tell what's been modified at the end.
  this.storeRevisions();
};

/**
 * This method clears out the features from this RouteModify.
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.clearFeatures = function () {
  this.lineFeaturesCollection_.clear();
  this.stopPointFeaturesCollection_.clear();
  this.modifyFeaturesCollection_.clear();
};

/**
 * @param {alk.source.SingleRoute} source
 * @this {alk.interaction.RouteModify}
 * @private
 */
alk.interaction.RouteModify.prototype.handleChangeRouteEvent_ = function (source) {
  this.clearFeatures();

  var self = this;
  var stopPoints = source.getStopFeatures();
  if (stopPoints !== undefined) {
    stopPoints = stopPoints.filter(function (sp) {
      return self.stopFeaturesFilterFunction(sp);
    });
    this.stopPointFeaturesCollection_.extend(stopPoints);
    this.modifyFeaturesCollection_.extend(stopPoints);
  }

  var lineFeatures = source.getLineFeatures();
  if (lineFeatures !== undefined) {
    this.lineFeaturesCollection_.extend(lineFeatures);
    this.modifyFeaturesCollection_.extend(lineFeatures);
  }

};

/**
 * @param {ol.interaction.Modify.Event} event
 * @this {alk.interaction.RouteModify}
 * @private
 */
alk.interaction.RouteModify.prototype.handleModifyEndEvent_ = function (event) {

  if (this.pendingStopFeature_) {
    this.pendingStopFeature_.unset('pending');
    this.pendingStopFeature_ = null;
  }

  var routeServiceOptions = this.processEvent(event);

  if (routeServiceOptions) {
    this.getSource().setRoute({
      routeServiceOptions: routeServiceOptions
    });
  }
};

/**
 * This function returns an array of the stop types that may be modified.
 * This particular implementation only allows {@link alk.val.StopType.ViaPoint}.
 *
 * @returns {Array.<alk.val.StopType>}
 * @api
 */
alk.interaction.RouteModify.prototype.getModifiableStopTypes = function () {
  return [alk.val.StopType.ViaPoint];
};

/**
 * This function returns the stop type of a stop that is added by this modifier.
 * @returns {alk.val.StopType}
 * @api
 */
alk.interaction.RouteModify.prototype.getCreationStopType = function () {
  return alk.val.StopType.ViaPoint;
};

/**
 * This method is invoked by the modify end handler to process the event.
 * If it returns routeServiceOptions, it sends them to the associated
 * {@link alk.layer.RoutingLayer} for a new Route, otherwise nothing is
 * done. This method gives the ability to override this method in sub-classes.
 *
 * @param {ol.interaction.Modify.Event} event
 * @this {alk.interaction.RouteModify}
 * @return {alkx.RouteServiceOptions|null}
 * @api
 */
alk.interaction.RouteModify.prototype.processEvent = function (event) {

  var modifiedStops = this.getModifiedStops();
  var modifiedSegments = this.getModifiedSegments();

  console.log(" MODIFY END   " + modifiedStops.length + " stops " + modifiedSegments.length + " segments.");
  var coords = event.mapBrowserEvent.coordinate;
  /** @type {alkx.RouteServiceOptions|null} */
  var routeServiceOptions = null;
  var rso = this.getSource().getRouteServiceOptions();
  // We are going to modify rso, so we clone it
  if (rso) {
    rso = this.getSource().cloneRouteServiceOptions(rso);
  }
  if (rso) {
    // In order to delete a stop, the user clicks on it, but it doesn't get modified, so we must look for it.
    if (modifiedStops.length === 0 && modifiedSegments.length === 0) {
      var stopFeatures = this.getSource().getStopFeatures();
      if (stopFeatures) {
        routeServiceOptions = this.processIfFoundStop(coords, rso, stopFeatures, this.getModifiableStopTypes());
      }
    } else {
      routeServiceOptions = this.processIfFoundStop(coords, rso, modifiedStops, this.getModifiableStopTypes());
      if (routeServiceOptions == null) {
        routeServiceOptions = this.processIfNewStop(coords, rso, modifiedSegments, this.getCreationStopType());
      }
      if (routeServiceOptions == null) {
        // modifiedStops.length === 0 && modifiedSegments.length > 0, but nothing added. Check for deleted just in case.
        var stopFeatures = this.getSource().getStopFeatures();
        if (stopFeatures) {
          routeServiceOptions = this.processIfFoundStop(coords, rso, stopFeatures, this.getModifiableStopTypes());
        }
      }
      if (routeServiceOptions == null) {
        // Nothing was done, restore all geometries
        this.restoreGeometries(event.features.getArray());
      }
    }
  } else {
    // Nothing was done, restore all geometries
    this.restoreGeometries(event.features.getArray());
  }
  return routeServiceOptions;
};

/**
 * @param {Array.<number>} c1
 * @param {Array.<number>} c2
 * @returns {boolean}
 */
alk.interaction.RouteModify.prototype.equalCoordinates = function (c1, c2) {
  return Math.floor(c1[0] * 1e7) === Math.floor(c2[0] * 1e7) && Math.floor(c1[1] * 1e7) === Math.floor(c2[1] * 1e7);
};


/**
 * @param {Array.<number>} c1
 * @param {Array.<number>} c2
 * @returns {boolean}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.equalPixels = function (c1, c2) {
  // We use Pixel Equality because the Modify and Snap cooperate but not that well.
  // Snap gets the right feature, but then Modify does not pay attention to
  // event.coordinate, which is set by Snap. It calls map.getCoordinateFromPixel(event.pixel).
  // So we must do the reverse process here, since we really care about matching features
  // on the map at its current state and resolution.
  var p1 = this.getMap().getPixelFromCoordinate(c1).map(function(p){return Math.floor(p);});
  var p2 = this.getMap().getPixelFromCoordinate(c2).map(function(p){return Math.floor(p);});
  return Math.abs(p1[0] - p2[0]) <= this.stopsPixelTolerance_ && Math.abs(p1[1] - p2[1]) <= this.stopsPixelTolerance_;
};

/**
 * This function returns the index of the first stop feature that matches the coordinates, or
 * -1 if not found. Note, the value returned is the index into the given list, not the 'stopIndex'.
 *
 * @param {Array.<ol.Feature>} stopFeatures
 * @param {Array.<number>} coords
 * @returns {number}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.findStopFeatureByCoordinates = function (stopFeatures, coords) {
  //console.log("trying to find " + coords);
  for (var i = 0; i < stopFeatures.length; i++) {
    var feature = stopFeatures[i];
    var pt = feature.getGeometry().getCoordinates();
    if (this.equalCoordinates(pt, coords)) {
      return i;
    }
  }
  return -1;
};

/**
 * This function returns the index of the first stop feature that matches the coordinates
 * by first converting to pixels, or -1 if not found. Note, the value returned is the
 * index into the given list, not the 'stopIndex'.
 *
 * @param {Array.<ol.Feature>} stopFeatures
 * @param {Array.<number>} coords
 * @returns {number}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.findStopByPixel = function (stopFeatures, coords) {
  for (var i = 0; i < stopFeatures.length; i++) {
    var feature = stopFeatures[i];
    var pt = feature.getGeometry().getCoordinates();
    if (this.equalPixels(pt, coords)) {
      return i;
    }
  }
  return -1;
};

/**
 * This function returns the index of the first matching coordinates in a list of coordinates.
 * Returns -1 if not found.
 *
 * @param {Array.<Array.<number>>} route
 * @param {Array.<number>} coords
 * @returns {number}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.findCoordinateOnRoute = function (route, coords) {
  for (var i = 0; i < route.length; i++) {
    var pt = route[i];
    if (this.equalCoordinates(pt, coords)) {
      return i;
    }
  }
  return -1;
};

/**
 * This function returns the index of the first matching coordinate in a list of coordinates
 * by first reducing them to pixel measure. Returns -1 if not found.
 *
 * @param {Array.<Array.<number>>} route
 * @param {Array.<number>} coords
 * @returns {number}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.findCoordinateOnRouteByPixel = function (route, coords) {
  var pcoords = this.getMap().getPixelFromCoordinate(coords);
  for (var i = 0; i < route.length; i++) {
    var pt = route[i];
    var pixel = this.getMap().getPixelFromCoordinate(pt);
    if (this.equalPixels(pixel, pcoords)) {
      return i;
    }
  }
  return -1;
};

/**
 * This function finds the coords on the first segment that has them, and return
 * the index of the segment. Returns -1 if coordinates cannot be found.
 * Note, this function returns the index into the given
 * array and not the 'segmentIndex' property.
 *
 * @param {Array.<ol.Feature>} lineFeatures
 * @param {Array.<number>} coords
 * @returns {number} 0 <= n <= stops.length-2, or -1 if none found.
 * @this {alk.interaction.RouteModify}
 */

alk.interaction.RouteModify.prototype.findSegmentIndex = function (lineFeatures, coords) {
  for (var i = 0; i < lineFeatures.length; i++) {
    var feature = lineFeatures[i];
    var route = feature.getGeometry().getCoordinates();
    var index = this.findCoordinateOnRoute(route, coords);
    if (0 <= index) {
      return i;
    }
  }
  return -1;
};

/**
 * This function finds the coords on the first segment that has them, and return
 * the index of the segment by comparing as pixels. Returns -1 if coordinates cannot be found.
 * Note, this function returns the index into the given
 * array and not the 'segmentIndex' property.
 *
 * @param {Array.<ol.Feature>} lineFeatures
 * @param {Array.<number>} coords
 * @returns {number} 0 <= n <= stops.length-2, or -1 if none found.
 * @this {alk.interaction.RouteModify}
 */

alk.interaction.RouteModify.prototype.findSegmentIndexByPixel = function (lineFeatures, coords) {
  for (var i = 0; i < lineFeatures.length; i++) {
    var feature = lineFeatures[i];
    var route = feature.getGeometry().getCoordinates();
    var index = this.findCoordinateOnRouteByPixel(route, coords);
    if (0 <= index) {
      return i;
    }
  }
  return -1;
};

/**
 * This function deletes a stop from stops, modifying it, and changes stopTypes
 * accordingly. It will only delete the stop if there are more than two stops
 * in the stops array. It returns true if the stop was deleted, false otherwise.
 *
 * @param {!number} stopIndex
 * @param {!Array.<Array.<number>>} stops
 * @param {!Array.<alk.val.StopType>|!Object.<number,alk.val.StopType>} stopTypes
 * @return {boolean} true if stop is deleted.
 */
alk.interaction.RouteModify.prototype.deleteStop = function (stopIndex, stops, stopTypes) {
  // Delete this Stop, but only if there are more than two.
  if (stops.length > 2) {
    // Adjust stopTypes.
    if (stopTypes[stopIndex] === alk.val.StopType.Origin) {
      // stopIndex === 0
      stopTypes[stopIndex+1] = alk.val.StopType.Origin;
    } else if (stopTypes[stopIndex] === alk.val.StopType.Destination){
      // stopIndex === stops.length - 1
      stopTypes[stopIndex-1] = alk.val.StopType.Destination;
    }
    stops.splice(stopIndex, 1);
    if (stopTypes instanceof Array) {
      stopTypes.splice(stopIndex, 1);
    } else {
      // StopTypes object. Delete it.
      delete stopTypes[stopIndex];
      // move all that are greater than the index down one.
      var keys = Object.keys(stopTypes).map(function (ks) {
        return parseInt(ks, 10);
      });
      var low2High = keys.sort(function (x, y) {
        return (x === y) ? 0 : (x > y ? 1 : -1);
      });
      low2High.forEach(function (k) {
        if (k > stopIndex) {
          stopTypes[k - 1] = stopTypes[k];
          delete stopTypes[k];
        }
      });
    }
    return true;
  } else {
    return false;
  }
};

/**
 * This method adds a stop to the stops after the index. If the index
 * is out of range the stop does not get added. It returns true if
 * the stop was added, and false otherwise. Both stops and stopTypes
 * are modified if true is returned.
 *
 * @param {!Array.<number>} pcoords
 * @param {!number} stopIndex The index into the current list of stops.
 * @param {!alk.val.StopType} stopType
 * @param {!Array.<Array.<number>>} stops
 * @param {!Array.<alk.val.StopType>|!Object.<number,alk.val.StopType>} stopTypes
 * @returns {boolean}
 */
alk.interaction.RouteModify.prototype.addStop = function (pcoords, stopIndex, stopType, stops, stopTypes) {
  if (0 <= stopIndex && stopIndex < stops.length-1) {
    // We are going to add a Stop at index + 1;
    stops.splice(stopIndex + 1, 0, pcoords);
    if (stopTypes instanceof Array) {
      stopTypes.splice(stopIndex + 1, 0, stopType);
    } else {
      // StopTypes is an object, keys are stringified numbers. Get the keys as numbers;
      var keys = Object.keys(/** @type {!Object} */(stopTypes)).map(function (ks) {
        return parseInt(ks, 10);
      });
      // sort from high to low.
      var high2Low = keys.sort(function (x, y) {
        return (x === y) ? 0 : (x < y ? 1 : -1);
      });
      // We are inserting a ViaPoint stop, so we have to move the stopTypes above index accordingly.
      high2Low.forEach(function (k) {
        if (k > stopIndex) {
          // Remember, we are traversing k high to low.
          stopTypes[k + 1] = stopTypes[k];
          delete stopTypes[k];
        }
      });
      stopTypes[stopIndex + 1] = stopType;
      // Adjust stopTypes.
      if (stopTypes[stopIndex] === alk.val.StopType.Destination) {
        stopTypes[stopIndex] = stopType;
        stopTypes[stopIndex + 1] = alk.val.StopType.Destination;
      }
    }
    return true;
  } else {
    return false;
  }
};

/**
 * This function finds and returns the stop feature according to the given coordinates.
 * If it cannot be found, this function returns null;
 *
 * @param {Array.<number>} coords
 * @returns {ol.Feature|null}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.getStopFeatureByPixel = function (coords) {
  if (coords == null) {
    return null;
  }
  var routeServiceOptions = this.getSource().getRouteServiceOptions();
  if (routeServiceOptions == null) {
    return null;
  }
  var stops = routeServiceOptions.stops;
  if (stops == null) {
    return null;
  }
  var stopFeatures = this.getSource().getStopFeatures();
  if (stopFeatures) {
    var stopIndex = this.findStopByPixel(stopFeatures, coords);
    if (0 <= stopIndex) {
      return stopFeatures[stopIndex];
    }
  }
  return null;
};

/**
 * This function will process a Stop if it has the coordinates and it has the
 * permitted stop type. If the coords identify a stopFeature, then recreate the
 * routeServiceOptions to handle its new geometry and coordinates and return it.
 *
 * @param {Array.<number>} coords The coordinates from the Modify End event.
 * @param {alkx.RouteServiceOptions} routeServiceOptions
 * @param {Array.<ol.Feature>} stopFeatures The list of modified stops.
 * @param {Array.<alk.val.StopType>} pStopTypes The permitted Stop Types.
 * @returns {alkx.RouteServiceOptions|null}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.processIfFoundStop = function (coords, routeServiceOptions, stopFeatures, pStopTypes) {
  if (coords == null) {
    return null;
  }
  var stops = routeServiceOptions.stops;
  if (stops == null) {
    return null;
  }
  var stopTypes = routeServiceOptions.stopTypes || {};
  var srs = /** @type {ol.ProjectionLike} */(routeServiceOptions.srs) || alk.val.SRS.EPSG4326;

  if (stopFeatures) {
    var index = this.findStopFeatureByCoordinates(stopFeatures, coords);
    if (0 <= index) {
      var st = stopFeatures[index].get('stopType');
      if (pStopTypes.some(function(p) {return p === st;})) {
        var stopIndex = /** @type {number} */ (stopFeatures[index].get('stopIndex'));
        if (0 <= stopIndex && stopIndex < stops.length) {
          var pcoords = ol.proj.transform(coords, alk.val.SRS.EPSG3857, srs);
          // If we clicked on a Stop and we didn't move it, it is a delete operation.
          if (this.equalCoordinates(stops[stopIndex], pcoords)) {
            this.deleteStop(stopIndex, stops, stopTypes);
          } else {
            // The Stop was moved to new coordinates.
            stops[stopIndex] = pcoords;
          }
          routeServiceOptions.stops = stops;
          routeServiceOptions.stopTypes = stopTypes;
          return routeServiceOptions;
        }
      }
    }
  }
  return null;
};

/**
 * This method looks for the coordinates on the list of lineFeatures that were modified. It
 * finds the first segment that matches the coordinates, and adds a stop at that that point.
 * It recreates routeServiceOptions to reflect that change. It returns null, if it cannot
 * find the coordinates on this listed line features.
 *
 * @param {Array.<number>} coords
 * @param {alkx.RouteServiceOptions} routeServiceOptions
 * @param {Array.<ol.Feature>} lineFeatures The list of line features.
 * @param {!alk.val.StopType} stopType The type of stop to create.
 * @returns {alkx.RouteServiceOptions|null}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.processIfNewStop = function (coords, routeServiceOptions, lineFeatures, stopType) {
  if (coords == null) {
    return null;
  }
  var stops = routeServiceOptions.stops;
  if (stops == null) {
    return null;
  }
  var stopTypes = routeServiceOptions.stopTypes || {};
  var srs = /** @type {ol.ProjectionLike} */(routeServiceOptions.srs) || alk.val.SRS.EPSG4326;

  if (lineFeatures) {
    var index = this.findSegmentIndex(lineFeatures, coords);
    if (0 <= index) {
      var segment = lineFeatures[index];
      var stopIndex = /** @type {number} */ (segment.get('segmentIndex'));
      var pcoords = /** @type {Array.<number>!} */(ol.proj.transform(coords, alk.val.SRS.EPSG3857, srs));
      var added = this.addStop(pcoords, stopIndex, stopType, stops, stopTypes);
      if (added) {
        routeServiceOptions.stops = stops;
        routeServiceOptions.stopTypes = stopTypes;
        return routeServiceOptions;
      }
    }
  }
  return null;
};

/**
 *
 * @param {Array.<!ol.Feature>} features
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.restoreGeometries = function (features) {
  var self = this;
  if (features) {
    features.forEach(function (feature, index) {
      var geom = self.geometryStore_[index];
      if (geom) {
        feature.setGeometry(geom);
      }
    });
  }
};


/**
 * This attribute contains the RoutingLayerStyle that was either assigned
 * or created for this RoutingLayer.
 * @type {alk.style.RoutingLayerStyle}
 * @api
 */
alk.interaction.RouteModify.prototype.routingLayerStyle;

/**
 * This function assigns or creates the RoutingLayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.RoutingLayerStyle|alk.style.StrokeQueue|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.interaction.RouteModify}
 * @api
 */
alk.interaction.RouteModify.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.RoutingLayerStyle) {
      self.routingLayerStyle = optStyle;
      style = function (feature, resolution) {
        return self.sketchFeatureStyleFunction(feature, resolution);
      };
    } else {
      var strokeQueue;
      if (optStyle instanceof alk.style.StrokeQueue) {
        strokeQueue = /** @type {alk.style.StrokeQueue} */ (optStyle.style);
      } else if (optStyle instanceof ol.style.Stroke) {
        var stroke = /** @type {ol.style.Stroke} */ (optStyle);
        strokeQueue = new alk.style.StrokeQueue({strokes: [stroke]});
      } else if (typeof optStyle === 'string') {
        var color = /** @type {string} */ (optStyle);
        strokeQueue = new alk.style.StrokeQueue({colors: [color]});
      } else if (optStyle instanceof Array) {
        var array = /** @type {Array.<*>} */ (optStyle);
        if (array.length > 0 && array[0] instanceof ol.style.Stroke) {
          strokeQueue = new alk.style.StrokeQueue({
            strokes: /** @type {Array.<ol.style.Stroke>} */(array)
          });
        }
      }
      if (this.routingLayer !== undefined) {
        var rlStyle = this.routingLayer.getRoutingLayerStyle();
        if (rlStyle instanceof alk.style.QueuedLineRouteStyle) {
          strokeQueue = /** @type {alk.style.QueuedLineRouteStyle} */(rlStyle).getStrokeQueue();
        }
      }
      if (strokeQueue !== undefined) {
        this.routingLayerStyle = new alk.style.EditRouteStyle({
          strokeQueue: strokeQueue
        });
        style = function (feature, resolution) {
          return self.sketchFeatureStyleFunction(feature, resolution);
        };
      } else {
        // We just go with the supplied style.
        style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
      }
    }
  } else {
    if (this.routingLayerStyle === undefined) {
      this.routingLayerStyle = new alk.style.EditRouteStyle({
        routingLayer: this.routingLayer
      });
    }
    style = function (feature, resolution) {
      return self.sketchFeatureStyleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function gets a vertex from the styleFunction, which is a Point geometry in the sketch.
 * We find the stop feature or line feature belonging to this feature's coordinates and assigns
 * this feature a property of 'stopFeature' or 'lineFeature' respectively.
 * The RouteModify style, which is an {@link alk.style.EditRouteStyle}
 * uses the associated features as they contain information for which to make the style,
 * such as 'stopIndex', 'routeId', etc.
 *
 * @param {ol.Feature} feature The vertex feature from the sketch.
 * @param {number} resolution The Resolution.
 * @returns {Array.<ol.style.Style>}
 * @this {alk.interaction.RouteModify}
 */
alk.interaction.RouteModify.prototype.sketchFeatureStyleFunction = function (feature, resolution) {
  var coords = feature.getGeometry().getCoordinates();
  var stopFeature = this.getStopFeatureByPixel(coords);
  if (stopFeature) {
    feature.set('stopFeature', stopFeature);
  } else {
    var lineFeatures = this.getSource().getLineFeatures();
    if (lineFeatures !== undefined) {
      var index = this.findSegmentIndex(lineFeatures, coords);
      if (0 <= index) {
        var lineFeature = lineFeatures[index];
        feature.set('lineFeature', lineFeature);
      }
    }
  }
  return this.routingLayerStyle.styleFunction(feature, resolution);
};

/**
 * This override handles an exception from the event handler usually on
 * 'pointerup' where it seems it is a delayed event or race condition
 * on removal of a feature, because the exception caught is it OID is
 * not found. We log the exception and continue without incident.
 * TODO: More research needed on why OID is not found or why feature went away, or why event happened at all.
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent
 * @returns {boolean}
 * @this {alk.interaction.RouteModify}
 * @override
 * @api
 */
alk.interaction.RouteModify.prototype.handleEvent = function (mapBrowserEvent) {
  try {
    console.log("calling RouteModify.base.handleEvent");
    return alk.interaction.RouteModify.base(this, 'handleEvent', mapBrowserEvent);
  } catch (exception) {
    console.warn("Caught error from Modify handle event: " + exception);
    return true;

  }
};
goog.provide('alk.overlay');

goog.require('alk');
alk.overlay = {};
goog.provide('alk.overlay.SingleSearchItemPopup');

goog.require('alk.overlay');

goog.require('alkx.SingleSearchLocation');
goog.require('alkx.SingleSearchItemPopupOptions');

/**
 * @classdesc
 * An instance of this class provides an overlay on the map
 * that will show a SingleSearchItemPopup. It creates the
 * following structure in the DOM.
 *
 * <div class='alk-popup'>
 *   <a class='alk-popup-close' href='#'></a>
 *   <div class='alk-popup-content alk-single-search'>
 *     <div class='alk-ss-address'>...</div>
 *     <div class='alk-ss-city'>...</div>
 *     <div class='alk-ss-state'>...</div>
 *     <div class='alk-ss-zip'>...</div>
 *   </div>
 * </div>
 *
 * @description
 * This constructor creates a Popup Overlay for an item from
 * the ALK Single Search Service.
 *
 * @param {alkx.SingleSearchItemPopupOptions=} opt_options
 * @constructor
 * @extends {ol.Overlay}
 * @api
 */
alk.overlay.SingleSearchItemPopup = function (opt_options) {
  /** @type {alkx.SingleSearchItemPopupOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var element = null;
  var close = null;
  if (options.singleSearchItem) {
    var ce = this.createPopupElement(options.singleSearchItem);
    element = ce.element;
    close = ce.close;
  }

  /** @type {olx.OverlayOptions} */
  var opts = {
    id: options.id,
    element: element,
    offset: options.offset,
    position: options.position,
    positioning: options.positioning,
    stopEvent: options.stopEvent,
    insertFirst: options.insertFirst,
    autoPan: options.autoPan,
    autoPanAnimation: options.autoPanAnimation,
    autoPanMargin: options.autoPanMargin
  };
  alk.overlay.SingleSearchItemPopup.base(this, 'constructor', opts);

  this.closeElement = close;
};
goog.inherits(alk.overlay.SingleSearchItemPopup, ol.Overlay);

/**
 * This property holds the close element.
 * @type {Element}
 * @api
 */
alk.overlay.SingleSearchItemPopup.prototype.closeElement;

/**
 * This method sets the traffic camera metadata for this popup.
 * @param {alkx.SingleSearchLocation} singleSearchItemPopupSpec The Traffic Camera.
 * @fires {change:element} Fires this event when changed.
 * @this {alk.overlay.SingleSearchItemPopup}
 * @api
 */
alk.overlay.SingleSearchItemPopup.prototype.setSingleSearchItemPopup = function (singleSearchItemPopupSpec) {
  var ce = this.createPopupElement(singleSearchItemPopupSpec);
  this.closeElement = ce.close;
  this.setElement(ce.element);
};

/**
 * This property contains the HTML string that has {{content}} string for form the list.
 * @type {string}
 * @api
 */
alk.overlay.SingleSearchItemPopup.prototype.listFormat =
  '<ul class="{{class}}">{{content}}</ul>';

/**
 * This method returns the inner HTML, which is a list of items.
 * @param {string} format The format of the list that contains {{class}} and {{content}}
 * @param {string} klass The class of the list, if applicable.
 * @param {string} content The HTML string of the list contents.
 * @returns {string}
 * @api
 */
alk.overlay.SingleSearchItemPopup.prototype.createListHTML = function (format, klass, content) {
  var str = format;
  str = str.replace(/\{\{class\}\}/g, klass);
  str = str.replace(/\{\{content\}\}/g, content);
  return str;
};

/**
 * This returns the div for the Single Search Item
 * @param {alkx.SingleSearchLocation} location
 * @returns {Element}
 * @api
 */
alk.overlay.SingleSearchItemPopup.prototype.createContentElement = function (location) {
  var children = [];
  var address = location.Address.StreetAddress;
  if (address) {
    children.push('<span class="alk-ss-address">' + address + '</span><br>');
  }
  var city = location.Address.City;
  if (city) {
    children.push('<span class="alk-ss-city">'+
      city + ',&nbsp;</span>');
  }
  var state = location.Address.State;
  if (state) {
    children.push('<span class="alk-ss-state">'+
      state + '&nbsp;</span>');
  }
  var zip = location.Address.Zip;
  if (zip) {
    children.push('<span class="alk-ss-zip">'+
      zip + '</span>');
  }
  var contentHTML = children.join('');
  var content = document.createElement('div');
  content.className = 'alk-popup-content alk-single-search';
  content.innerHTML = contentHTML;
  return content;
};

/**
 * This creates the popup element.
 * @param {alkx.SingleSearchLocation} alert
 * @returns {{close: Element, element: Element}}
 * @this {alk.overlay.SingleSearchItemPopup}
 * @api
 */
alk.overlay.SingleSearchItemPopup.prototype.createPopupElement = function (alert) {
  var content = this.createContentElement(alert);
  var popup = document.createElement('div');
  popup.className = 'alk-popup';
  var close = document.createElement('a');
  close.href = "#";
  close.className = 'alk-popup-close';
  popup.appendChild(close);
  popup.appendChild(content);
  return {
    close: close,
    element: popup
  };
};
goog.provide('alk.interaction.SingleSearchPopupInteraction');

goog.require('alk.interaction');
goog.require('alk.overlay.SingleSearchItemPopup');

goog.require('alkx.SingleSearchPopupInteractionOptions');
/**
 * @classdesc
 * An object of this class provides a means by which users may interact
 * with features on the map that are results from the ALK Single Search Service or clusters
 * of such results, providing tooltips and clickable popups.
 * @description
 * This constructor creates an Interaction object that creates popups and tooltips
 * for Single Search results.
 *
 * @param {alkx.SingleSearchPopupInteractionOptions=} opt_options
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @api
 */
alk.interaction.SingleSearchPopupInteraction = function (opt_options) {
  var self = this;
  ///** @type {alkx.SingleSearchPopupInteractionOptions} */
  //var options = opt_options !== undefined ? opt_options : {};
  /** @type {olx.interaction.InteractionOptions} */
  var opts = {
    handleEvent:
      /**
       * @param {ol.MapBrowserEvent} evt
       * @returns {boolean}
       */
      function (evt) {
        return self.handleMapBrowserEvent(evt);
      }
  };

  alk.interaction.SingleSearchPopupInteraction.base(this, 'constructor', opts);

  this.currentPopups_ = [];
};
goog.inherits(alk.interaction.SingleSearchPopupInteraction, ol.interaction.Interaction);

/**
 * This property holds the currently displayed popups.
 * @type {Array.<ol.Overlay>}
 * @private
 */
alk.interaction.SingleSearchPopupInteraction.prototype.currentPopups_;

/**
 * This method returns a list of traffic camera features found under the
 * event pixel. It first looks for a cluster feature and if they are all of
 * the same coordinates, they are returned. It never returns more than
 * four features.
 * @param {ol.MapBrowserEvent} evt
 * @returns {Array.<ol.Feature>|undefined}
 * @this {alk.interaction.SingleSearchPopupInteraction}
 */
alk.interaction.SingleSearchPopupInteraction.prototype.getFeatures = function (evt) {
  var features = this.getMap().forEachFeatureAtPixel(evt.pixel, function (feature) {
    var features = /** @type {Array.<ol.Feature>} */(feature.get('features'));
    if (features && features.length < 5) {
      var coord = features[0].getGeometry().getCoordinates();
      if (features.every(function(feature) {
          return ol.coordinate.equals(coord, feature.getGeometry().getCoordinates())
            && feature.get('location');
        })) {
        return features;
      }
    }
  });
  if (!features) {
    var cameraFeatures = [];
    features = this.getMap().forEachFeatureAtPixel(evt.pixel, function (feature) {
      var incident = /** @type {alkx.SingleSearchLocation} */(feature.get('location'));
      if (incident) {
        cameraFeatures.push(feature);
      }
    });
    if (cameraFeatures.length > 0) {
      features = cameraFeatures;
    }
  }
  return features ? features.slice(0,4) : undefined;
};

/**
 * This method handles the popup event. Usually this is a pointer 'click' event.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.SingleSearchPopupInteraction}
 */
alk.interaction.SingleSearchPopupInteraction.prototype.handlePopupEvent = function (evt) {
  var self = this;

  if (this.currentPopups_) {
    this.currentPopups_.forEach(function (popup) {
      self.getMap().removeOverlay(popup);
    });
    this.currentPopups_ = [];
  }
  var features = this.getFeatures(evt);
  if (features) {
    this.displayPopups(features);
  }
};

/**
 * This method displays popups for the given traffic camera features.
 * @param {Array.<ol.Feature>} features
 * @this {alk.interaction.SingleSearchPopupInteraction}
 * @protected
 */
alk.interaction.SingleSearchPopupInteraction.prototype.displayPopups = function (features) {
  var self = this;
  if (features) {
    features.forEach(function (feature,i) {
      var location = /** @type {alkx.SingleSearchLocation} */(feature.get('location'));
      var popup = new alk.overlay.SingleSearchItemPopup({
        autoPan: true,
        singleSearchItem: location
      });
      self.getMap().addOverlay(popup);
      // We must do setPosition after we add it to the map, otherwise it will not pan into view.
      popup.setPosition(feature.getGeometry().getCoordinates());
      self.currentPopups_.push(popup);
      popup.closeElement.onclick = function () {
        this.blur();
        popup.setPosition(undefined);
        // remove it from the current popups.
        self.currentPopups_ = self.currentPopups_.filter(function(x){return x !== popup;});
        self.getMap().removeOverlay(popup);
      };
      // We bring the popup to the top on a click.
      // Based on reordering. Last added ends up behind.
      popup.getElement().onclick = function () {
        self.currentPopups_.forEach(function(p) {
          if (p !== popup) {
            self.getMap().removeOverlay(p);
            self.getMap().addOverlay(p);
          }
        });
      };
    });
  }
};

/**
 * This handles this interaction's map browser events when it is placed on the map.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.SingleSearchPopupInteraction}
 * @returns {boolean}
 */
alk.interaction.SingleSearchPopupInteraction.prototype.handleMapBrowserEvent = function (evt) {
  if (evt.dragging) {
    return true;
  }
  switch (evt.type) {
    case "click" /* ol.events.EventType.CLICK */:
      this.handlePopupEvent(evt);
      return false;
    default:
      return true;
  }
};

/**
 * This method adds the static tooltip overlay to the map's overlays.
 * @param {ol.PluggableMap} map
 * @this {alk.interaction.SingleSearchPopupInteraction}
 * @override
 */
alk.interaction.SingleSearchPopupInteraction.prototype.setMap = function (map) {
  if (map == null) {
    this.removeOverlays(this.getMap());
  }
  alk.interaction.SingleSearchPopupInteraction.base(this, 'setMap', map);
};

/**
 * This method removes any of the overlays that were placed on the map.
 * @param {ol.PluggableMap} map
 * @this {alk.interaction.SingleSearchPopupInteraction}
 * @api
 */
alk.interaction.SingleSearchPopupInteraction.prototype.removeOverlays = function (map) {
  if (map) {
    if (this.currentPopups_) {
      this.currentPopups_.forEach(function (popup) {
        map.removeOverlay(popup);
      });
    }
  }
};
goog.provide('pcmws.api.TrafficCameraMetadataService');


goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Identifier');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.TrafficCameraMetadataServiceOptions');
goog.require('pcmws.api.TrafficCameraMetadataURL');


/**
 * @param {pcmws.api.TrafficCameraMetadataServiceOptions=} opt_options Options
 * @constructor
 * @extends {pcmws.api.StaticService}
 *
 */
pcmws.api.TrafficCameraMetadataService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['identifier', pcmws.api.Identifier]
  ];
  pcmws.api.TrafficCameraMetadataService.base(this, 'constructor', specs, opt_options);

  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.TrafficCameraMetadataURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.TrafficCameraMetadataService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.TrafficCameraMetadataService}
 * @returns {pcmws.api.TrafficCameraMetadataService}
 */
pcmws.api.TrafficCameraMetadataService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.TrafficCameraMetadataServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.TrafficCameraMetadataService(opts);
};
goog.provide('alk.service.TrafficCameraMetadataService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('alkx.TrafficCameraMetadataServiceOptions');
goog.require('alkx.TrafficCameraMetadataServiceResponse');
goog.require('pcmws.api.TrafficCameraMetadataService');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the PCM TrafficCameraMetadataService.
 *
 * @description
 * This constructor creates a Service object to access the ALK PC Miler
 * Traffic Camera Metadata Service.
 *
 * @param {alkx.TrafficCameraMetadataServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.TrafficCameraMetadataService = function (opt_options) {
  alk.service.TrafficCameraMetadataService.base(this, 'constructor', opt_options);
  this.pcmServiceOptions = this.getPCMServiceOptions(opt_options);
  this.trafficCameraMetadataService = this.pcmws = new pcmws.api.TrafficCameraMetadataService(this.pcmServiceOptions);
};
goog.inherits(alk.service.TrafficCameraMetadataService, alk.service.Service);

/**
 * @description
 * The ALK Traffic Camera Metadat Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.TrafficCameraMetadataService} object.
 *
 * @type {pcmws.api.TrafficCameraMetadataService}
 */
alk.service.TrafficCameraMetadataService.prototype.trafficCameraMetadataService;

/**
 * @description
 * This function performs a request for a {@link alkx.TrafficCameraMetadataServiceResponse} from
 * the options and defaults set on this {@link alk.service.TrafficCameraMetadataService} object.
 *
 * The response is handled by a asynchronous callback.
 *
 * @param {(alkx.TrafficCameraMetadataServiceOptions|null|
 *     function(alkx.TrafficCameraMetadataServiceResponse))=} opts_or_callback
 *     Options override, if not the callback.
 * @param {function(alkx.TrafficCameraMetadataServiceResponse)=} responseCallback
 *     The callback that handles the response.
 * @override
 * @this {alk.service.TrafficCameraMetadataService}
 * @api
 */
alk.service.TrafficCameraMetadataService.prototype.get = function(opts_or_callback, responseCallback) {
  /** @type {alkx.TrafficCameraMetadataServiceOptions} */
  var options = {};
  /** function(alkx.TrafficCameraMetadataServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.TrafficCameraMetadataServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.TrafficCameraMetadataService.base(this, 'get', downcastOptions, downcastCallback);
};

goog.provide('alk.source');

goog.require('alk');

alk.source = {};goog.provide('alk.source.TrafficCameraMetadataCache');

goog.require('alk.source');
goog.require('alk.service.TrafficCameraMetadataService');

goog.require('alkx.TrafficCameraMetadata');
goog.require('alkx.TrafficCameraMetadataCacheOptions');

/**
 * @classdesc
 * This class wraps the Traffic Camera Metadata Service and
 * caches the meta data.
 * @description
 * This constructor creates a wrapper around the Traffic Camera
 * Metadata Source to cache the metadata.
 *
 * @param {alkx.TrafficCameraMetadataCacheOptions=} opt_options
 * @constructor
 * @api
 */
alk.source.TrafficCameraMetadataCache = function (opt_options) {
  /** @type {alkx.TrafficCameraMetadataCacheOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var service = options.trafficCameraMetadataService;
  if (service == null) {
    service = new alk.service.TrafficCameraMetadataService();
  }

  this.trafficCameraMetadataService_ = service;
  this.metadataCache_ = {};
};

/**
 * @type {Object.<string, alkx.TrafficCameraMetadata|undefined>}
 * @private
 */
alk.source.TrafficCameraMetadataCache.prototype.metadataCache_;

/**
 * @this {alk.source.TrafficCameraMetadataCache}
 * @param {alkx.TrafficCameraMetadata=} metadata The metadata
 * @api
 */
alk.source.TrafficCameraMetadataCache.prototype.store = function (metadata) {
  this.metadataCache_[metadata.PublicId] = metadata;
};

/**
 * @type {alk.service.TrafficCameraMetadataService}
 * @private
 */
alk.source.TrafficCameraMetadataCache.prototype.trafficCameraMetadataService_;

/**
 * @this {alk.source.TrafficCameraMetadataCache}
 * @param {string} id
 * @returns {alkx.TrafficCameraMetadata|undefined}
 * @api
 */
alk.source.TrafficCameraMetadataCache.prototype.retrieve = function (id) {
  return this.metadataCache_[id];
};

/**
 * @this {alk.source.TrafficCameraMetadataCache}
 * @param {string} id
 * @param {function(alkx.TrafficCameraMetadata=)} complete
 * @api
 */
alk.source.TrafficCameraMetadataCache.prototype.get = function (id, complete) {
  var metadata = this.retrieve(id);
  var self = this;
  if (metadata) {
    if (typeof complete === 'function') {
      complete(metadata);
    }
  } else {
    this.trafficCameraMetadataService_.get({
      identifier: id
    }, /** @type{function(alkx.TrafficCameraMetadata=)} */(function (metadata) {
      self.store(metadata);
      if (typeof complete === 'function') {
        complete(metadata);
      }
    }));
  }
};
goog.provide('alk.overlay.ListTooltipOverlay');

goog.require('alk.overlay');
goog.require('alkx.ListTooltipOverlayOptions');

/**
 * @classdesc
 * An instance of this class creates an list type overlay that is normally
 * used as a tooltip on a hover. Its basic structure is:
 *     <div class="alk.tooltip-content">
 *             <ul class="alk-tooltip-list">
 *                     <li class="alk-tooltip-list-element">text</li>
 *                     <li class="alk-tooltip-list-element">text</li>
 *             </ul>
 *     </div>
 * @description
 * This constructor creates an overlay that creates an HTML object in the DOM.
 * If a cssClass option is given, this object adds it all the elements it creates.
 * @param {alkx.ListTooltipOverlayOptions=} opt_options
 * @extends {ol.Overlay}
 * @constructor
 * @api
 */
alk.overlay.ListTooltipOverlay = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  if (options.cssClass !== undefined) {
    this.cssClass = options.cssClass;
  }

  this.container_ = this.createContainer();
  this.container_ = this.createContainer();
  this.listElement_ = this.createListElement();
  this.container_.appendChild(this.listElement_);

  var opts = {
     id: options.id,
     element: this.container_,
     offset: options.offset,
     position: options.position,
     positioning: options.positioning,
     stopEvent: options.stopEvent,
     insertFirst: options.insertFirst,
     autoPan: options.autoPan,
     autoPanAnimation: options.autoPanAnimation,
     autoPanMargin: options.autoPanMargin
  };

  alk.overlay.ListTooltipOverlay.base(this, 'constructor', opts);
  this.setAssigned(false);
};
goog.inherits(alk.overlay.ListTooltipOverlay, ol.Overlay);

/**
 * This method sets the assigned property.
 * @param {boolean} bool
 * @this {alk.overlay.ListTooltipOverlay}
 * @api
 */
alk.overlay.ListTooltipOverlay.prototype.setAssigned = function (bool) {
  this.set('assigned', this.assigned = bool);
};

/**
 * This function returns the value of the 'assigned' property.
 * @returns {boolean}
 * @this {alk.overlay.ListTooltipOverlay}
 * @api
 */
alk.overlay.ListTooltipOverlay.prototype.getAssigned = function () {
  return /** @type {boolean} */(this.get('assigned'));
};

/**
 * This property signifies that the overlay is in the process of getting
 * assigned. The addListItem functions maybe called asynchronously and
 * there is a need to set a boolean on this object so the caller may
 * know they have already assigned this object.
 * @api
 */
alk.overlay.ListTooltipOverlay.prototype.assigned;

/**
 * This property holds the CSS class given in the options.
 * @type {string|undefined}
 */
alk.overlay.ListTooltipOverlay.prototype.cssClass;

/**
 * This property contains the tooltip container.
 * @type {Element}
 * @private
 */
alk.overlay.ListTooltipOverlay.prototype.container_;
/**
 * This property contains the tooltip list.
 * @type {Element}
 * @private
 */
alk.overlay.ListTooltipOverlay.prototype.listElement_;

/**
 * This method creates the tooltip container.
 * @returns {Element}
 * @this {alk.overlay.ListTooltipOverlay}
 * @protected
 */
alk.overlay.ListTooltipOverlay.prototype.createContainer = function () {
  var container = document.createElement('div');
  container.className = 'alk-tooltip-content ' + (this.cssClass ? this.cssClass : '');
  return container;
};

/**
 * This method creates the tooltip list element.
 * @returns {Element}
 * @this {alk.overlay.ListTooltipOverlay}
 * @protected
 */
alk.overlay.ListTooltipOverlay.prototype.createListElement = function () {
  var element = document.createElement('ul');
  element.className = 'alk-tooltip-list ' + (this.cssClass ? this.cssClass : '');
  return element;
};

/**
 * This method returns the tooltip container.
 * @returns {Element}
 * @this {alk.overlay.ListTooltipOverlay}
 */
alk.overlay.ListTooltipOverlay.prototype.getContainer = function () {
  return this.container_;
};

/**
 * This method returns the tooltip list.
 * @returns {Element}
 * @this {alk.overlay.ListTooltipOverlay}
 */
alk.overlay.ListTooltipOverlay.prototype.getListElement = function () {
  return this.listElement_;
};

/**
 * This method creates a list item element.
 * @returns {Element}
 * @this {alk.overlay.ListTooltipOverlay}
 */
alk.overlay.ListTooltipOverlay.prototype.createListItemElement = function () {
  var li = document.createElement('li');
  li.className = 'alk-tooltip-item ' + (this.cssClass ? this.cssClass : '');
  return li;
};

/**
 * This method adds the string as an list element of the tooltip list.
 * @param {string} item
 * @this {alk.overlay.ListTooltipOverlay}
 * @api
 */
alk.overlay.ListTooltipOverlay.prototype.addListItem = function (item) {
  var li = this.createListItemElement();
  li.innerHTML = item;
  this.getListElement().appendChild(li);
};

/**
 * This method clears the innerHTML of the tooltip list, and sets the assigned
 * property to false;
 * @this {alk.overlay.ListTooltipOverlay}
 * @api
 */
alk.overlay.ListTooltipOverlay.prototype.clear = function () {
  this.getListElement().innerHTML = '';
  this.setAssigned(false);
};

/**
 * This method sets the display style for the overlay. True means display of ''
 * and false means display of 'none'.
 * @param {boolean} bool
 * @this {alk.overlay.ListTooltipOverlay}
 * @api
 */
alk.overlay.ListTooltipOverlay.prototype.setDisplay = function (bool) {
  this.getContainer().style.display = bool ? '' : 'none';
};
goog.provide('pcmws.api.TrafficCameraImageService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Identifier');
goog.require('pcmws.api.Resolution');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.TrafficCameraImageServiceOptions');
goog.require('pcmws.api.TrafficCameraImageURL');

/**
 * @param {pcmws.api.TrafficCameraImageServiceOptions=} opt_options Options
 * @constructor
 * @extends {pcmws.api.StaticService}
 *
 */
pcmws.api.TrafficCameraImageService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['identifier', pcmws.api.Identifier],
    ['resolution', pcmws.api.Resolution]
  ];
  pcmws.api.TrafficCameraImageService.base(this, 'constructor', specs, opt_options);

  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.TrafficCameraImageURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.TrafficCameraImageService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.TrafficCameraImageService}
 * @returns {pcmws.api.TrafficCameraImageService}
 */
pcmws.api.TrafficCameraImageService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.TrafficCameraImageServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.TrafficCameraImageService(opts);
};
goog.provide('alk.overlay.TrafficCameraPopup');

goog.require('alk.overlay');

goog.require('alkx.TrafficCameraMetadata');
goog.require('alkx.TrafficCameraPopupOptions');

goog.require('pcmws.api.TrafficCameraImageService');

/**
 * @classdesc
 * An instance of this class provides an overlay on the map
 * that will show a TrafficCameraPopup. It creates the
 * following structure in the DOM.
 *
 * <div class='alk-popup'>
 *   <a class='alk-popup-close' href='#'></a>
 *   <div class='alk-popup-header'>Traffic Camera</div>
 *   <div class='alk-popup-content alk-traffic-camera'>
 *     <ul class='alk-popup-list'>
 *       <li class='alk-popup-item alk-ca-name'>...</li>
 *       <li class='alk-popup-item alk-ca-orientation'>...</li>
 *     </ul>
 *     <img class='alk-ca-image' src='...'>
 *   </div>
 * </div>
 *
 * @description
 * This constructor creates a popup overlay for a traffic
 * camera.
 *
 * @param {alkx.TrafficCameraPopupOptions=} opt_options
 * @constructor
 * @extends {ol.Overlay}
 * @api
 */
alk.overlay.TrafficCameraPopup = function (opt_options) {
  /** @type {alkx.TrafficCameraPopupOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var element = null;
  var close = null;
  if (options.trafficCamera) {
    var ce = this.createPopupElement(options.trafficCamera);
    element = ce.element;
    close = ce.close;
  }

  /** @type {olx.OverlayOptions} */
  var opts = {
    id: options.id,
    element: element,
    offset: options.offset,
    position: options.position,
    positioning: options.positioning,
    stopEvent: options.stopEvent,
    insertFirst: options.insertFirst,
    autoPan: options.autoPan,
    autoPanAnimation: options.autoPanAnimation,
    autoPanMargin: options.autoPanMargin
  };
  alk.overlay.TrafficCameraPopup.base(this, 'constructor', opts);

  this.closeElement = close;
};
goog.inherits(alk.overlay.TrafficCameraPopup, ol.Overlay);

/**
 * This property holds the close element.
 * @type {Element}
 * @api
 */
alk.overlay.TrafficCameraPopup.prototype.closeElement;

/**
 * This method sets the traffic camera metadata for this popup.
 * @param {alkx.TrafficCameraMetadata} trafficCameraMetadata The Traffic Camera.
 * @fires {change:element} Fires this event when changed.
 * @this {alk.overlay.TrafficCameraPopup}
 * @api
 */
alk.overlay.TrafficCameraPopup.prototype.setTrafficCamera = function (trafficCameraMetadata) {
  var ce = this.createPopupElement(trafficCameraMetadata);
  this.closeElement = ce.close;
  this.setElement(ce.element);
};

/**
 *
 * @param {string} id
 * @returns {string}
 */
alk.overlay.TrafficCameraPopup.prototype.getTrafficCameraImageURL = function(id) {
  return new pcmws.api.TrafficCameraImageService().getURL({
    identifier: id,
    resolution: 0
  });
};

/**
 * This property contains the HTML string that has {{content}} string for form the list in the
 * weather alert.
 * @type {string}
 * @api
 */
alk.overlay.TrafficCameraPopup.prototype.listFormat =
  '<ul class="{{class}}">{{content}}</ul>';

/**
 * This method returns the inner HTML, which is a list of items.
 * @param {string} format The format of the list that contains {{class}} and {{content}}
 * @param {string} klass The class of the list, if applicable.
 * @param {string} content The HTML string of the list contents.
 * @returns {string}
 * @api
 */
alk.overlay.TrafficCameraPopup.prototype.createListHTML = function (format, klass, content) {
  var str = format;
  str = str.replace(/\{\{class\}\}/g, klass);
  str = str.replace(/\{\{content\}\}/g, content);
  return str;
};

/**
 * This returns the div for the Traffic Camera
 * @param {alkx.TrafficCameraMetadata} alert
 * @returns {Element}
 * @this {alk.overlay.TrafficCameraPopup}
 * @api
 */
alk.overlay.TrafficCameraPopup.prototype.createContentElement = function (alert) {
  var children = [];
  var name = alert.Name;
  if (name) {
    children.push('<li class="alk-popup-item alk-ca-name">' + name + '</li>');
  }
  var orientation = alert.Orientation;
  if (orientation) {
    orientation = orientation.toLocaleLowerCase();
    // TODO: Internationalization
    children.push('<li class="alk-popup-item alk-ca-orientation">'+
      'Traffic closest to the camera is traveling ' + orientation+'.</li>');
  }
  var listContentHTML = children.join('');
  var listHTML = this.createListHTML(this.listFormat, 'alk-popup-list', listContentHTML);
  var content = document.createElement('div');
  content.className = 'alk-popup-content alk-traffic-camera';
  listHTML += '<img class="alk-popup-ca-image" src="' + this.getTrafficCameraImageURL(alert.PublicId) + '"/>';
  content.innerHTML = listHTML;
  return content;
};

/**
 * This creates the popup element.
 * @param {alkx.TrafficCameraMetadata} alert
 * @returns {{close: Element, element: Element}}
 * @this {alk.overlay.TrafficCameraPopup}
 * @api
 */
alk.overlay.TrafficCameraPopup.prototype.createPopupElement = function (alert) {
  var content = this.createContentElement(alert);
  var popup = document.createElement('div');
  popup.className = 'alk-popup';
  var header = document.createElement('div');
  header.className = 'alk-popup-header';
  header.innerHTML = "<strong>Traffic Camera</strong>";
  var close = document.createElement('a');
  close.href = "#";
  close.className = 'alk-popup-close';
  popup.appendChild(header);
  popup.appendChild(close);
  popup.appendChild(content);
  return {
    close: close,
    element: popup
  };
};
goog.provide('alk.interaction.TrafficCameraPopupInteraction');

goog.require('alk.interaction');
goog.require('alk.service.TrafficCameraMetadataService');
goog.require('alk.source.TrafficCameraMetadataCache');
goog.require('alk.overlay.ListTooltipOverlay');
goog.require('alk.overlay.TrafficCameraPopup');

goog.require('alkx.TrafficCameraPopupInteractionOptions');
/**
 * @classdesc
 * An object of this class provides a means by which users may interact
 * with features on the map that are traffic cameras or clusters
 * of traffic cameras, providing tooltips and clickable popups.
 * @description
 * This constructor creates an Interaction object that allows its user
 * to interact with traffic cameras that exist in the layer.
 *
 * @param {alkx.TrafficCameraPopupInteractionOptions=} opt_options
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @api
 */
alk.interaction.TrafficCameraPopupInteraction = function (opt_options) {
  var self = this;
  /** @type {alkx.TrafficCameraPopupInteractionOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {olx.interaction.InteractionOptions} */
  var opts = {
    handleEvent:
      /**
       * @param {ol.MapBrowserEvent} evt
       * @returns {boolean}
       */
      function (evt) {
        return self.handleMapBrowserEvent(evt);
      }
  };

  alk.interaction.TrafficCameraPopupInteraction.base(this, 'constructor', opts);

  this.tooltipOverlay_ = this.createTooltipOverlay();

  if (options.trafficCameraMetadataCache) {
    this.trafficCameraMetadataCache_ = options.trafficCameraMetadataCache;
  } else {
    this.trafficCameraMetadataService_ = options.trafficCameraMetadataService;
    this.trafficCameraMetadataCache_ = new alk.source.TrafficCameraMetadataCache({
      trafficCameraMetadataService: this.trafficCameraMetadataService_
    });
  }
  this.currentPopups_ = [];
};
goog.inherits(alk.interaction.TrafficCameraPopupInteraction, ol.interaction.Interaction);

/**
 * This property holds the created tooltipOverlay.
 * @type {alk.overlay.ListTooltipOverlay}
 * @private
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.tooltipOverlay_;

/**
 * This property holds the currently displayed popups.
 * @type {Array.<ol.Overlay>}
 * @private
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.currentPopups_;

/**
 * This property holds the meta data service for the traffic cameras.
 * @type {alk.service.TrafficCameraMetadataService|undefined}
 * @private
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.trafficCameraMetadataService_;
/**
 * This property holds the meta data cache for the traffic camera metadata.
 * @type {alk.source.TrafficCameraMetadataCache}
 * @private
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.trafficCameraMetadataCache_;

/**
 * This returns the current tooltip overlay in use with this interaction object.
 * This object persists throughout the life of this interaction object.
 * @returns {alk.overlay.ListTooltipOverlay}
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 * @protected
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.getTooltipOverlay = function () {
  return this.tooltipOverlay_;
};

/**
 * This method creates the tooltip overlay that will be used to hover over
 * features with one or multiple (in the event of clustering). It will only be
 * called once as it is persistent for the life of this interaction object.
 * @returns {alk.overlay.ListTooltipOverlay}
 * @protected
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.createTooltipOverlay = function() {
  return new alk.overlay.ListTooltipOverlay({
    cssClass: 'alk-traffic-camera',
    offset: [20, 0],
    positioning: "bottom-left" /* ol.OverlayPositioning.BOTTOM_LEFT */
  });
};

/**
 * This method handles a tooltip event. Usually this event is the 'pointermove'
 * event.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.handleTooltipEvent = function(evt) {
  var self = this;
  if (this.currentPopups_ && this.currentPopups_.length > 0) {
    return;
  }
  var features = this.getFeatures(evt);
  var tooltip = this.getTooltipOverlay();
  if (features) {
    tooltip.setPosition(evt.coordinate);
    tooltip.setDisplay(true);
    if (tooltip.getAssigned() !== true) {
      tooltip.setAssigned(true);
      features.forEach(function (feature) {
        var camera = /** @type {alkx.TrafficCameraSpec} */(feature.get('trafficCamera'));
        self.trafficCameraMetadataCache_.get(camera.PublicId, function (metadata) {
          tooltip.addListItem(metadata.Name);
        });
      });
    }
  } else {
    tooltip.clear();
    tooltip.setDisplay(false);
  }
};
/**
 * This method returns a list of traffic camera features found under the
 * event pixel. It first looks for a cluster feature and if they are all of
 * the same coordinates, they are returned. It never returns more than
 * four features.
 * @param {ol.MapBrowserEvent} evt
 * @returns {Array.<ol.Feature>|undefined}
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.getFeatures = function (evt) {
  var features = this.getMap().forEachFeatureAtPixel(evt.pixel, function (feature) {
    var features = /** @type {Array.<ol.Feature>} */(feature.get('features'));
    if (features && features.length < 5) {
      var coord = features[0].getGeometry().getCoordinates();
      if (features.every(function(feature) {
          return ol.coordinate.equals(coord, feature.getGeometry().getCoordinates())
            && feature.get('trafficCamera');
        })) {
        return features;
      }
    }
  });
  if (!features) {
    var cameraFeatures = [];
    features = this.getMap().forEachFeatureAtPixel(evt.pixel, function (feature) {
      var trafficCamera = /** @type {alkx.TrafficCameraSpec} */(feature.get('trafficCamera'));
      if (trafficCamera) {
        cameraFeatures.push(feature);
      }
    });
    if (cameraFeatures.length > 0) {
      features = cameraFeatures;
    }
  }
  return features ? features.slice(0,4) : undefined;
};

/**
 * This method handles the popup event. Usually this is a pointer 'click' event.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.handlePopupEvent = function (evt) {
  var self = this;
  var tooltip = this.getTooltipOverlay();
  tooltip.clear();
  tooltip.setDisplay(false);

  if (this.currentPopups_) {
    this.currentPopups_.forEach(function (popup) {
      self.getMap().removeOverlay(popup);
    });
    this.currentPopups_ = [];
  }
  var features = this.getFeatures(evt);
  if (features) {
    this.displayPopups(features);
  }
};

/**
 * This method displays popups for the given traffic camera features.
 * @param {Array.<ol.Feature>} features
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 * @protected
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.displayPopups = function (features) {
  var self = this;
  /** Could not get this approach to work.
  var overlayPositioning = [
    ol.OverlayPositioning.TOP_CENTER,
    ol.OverlayPositioning.CENTER_LEFT,
    ol.OverlayPositioning.BOTTOM_CENTER,
    ol.OverlayPositioning.CENTER_RIGHT
  ];
   */
  if (features) {
    features.forEach(function (feature,i) {
      /** Could not get this approach to work.
      var positioning = overlayPositioning[i % 4];
       */
      var offset = [15*i,-15*i];
      var camera = /** @type {alkx.TrafficCameraSpec} */(feature.get('trafficCamera'));
      self.trafficCameraMetadataCache_.get(camera.PublicId, function (metadata) {
        var popup = new alk.overlay.TrafficCameraPopup({
          autoPan: true,
          offset: offset,  // positioning doesn't work, we go with offset
          // positioning: positioning, // Doesn't work
          trafficCamera: /** @type {alkx.TrafficCameraMetadata} */(metadata)
        });
        self.getMap().addOverlay(popup);
        // We must do setPosition after we add it to the map, otherwise it will not pan into view.
        popup.setPosition(feature.getGeometry().getCoordinates());
        //popup.setPositioning(positioning); // Doesn't work.
        self.currentPopups_.push(popup);
        popup.closeElement.onclick = function () {
          this.blur();
          popup.setPosition(undefined);
          // remove it from the current popups.
          self.currentPopups_ = self.currentPopups_.filter(function(x){return x !== popup;});
          self.getMap().removeOverlay(popup);
        };
        // We bring the popup to the top on a click.
        // Based on reordering. Last added ends up behind.
        popup.getElement().onclick = function () {
          self.currentPopups_.forEach(function(p) {
            if (p !== popup) {
              self.getMap().removeOverlay(p);
              self.getMap().addOverlay(p);
            }
          });
        };
      });
    });
  }
};

/**
 * This handles this interaction's map browser events when it is placed on the map.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 * @returns {boolean}
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.handleMapBrowserEvent = function (evt) {
  if (evt.dragging) {
    return true;
  }
  switch (evt.type) {
    case "pointermove" /* ol.pointer.EventType.POINTERMOVE */:
      this.handleTooltipEvent(evt);
      return false;
    case "click" /* ol.events.EventType.CLICK */:
      this.handlePopupEvent(evt);
      return false;
    default:
      return true;
  }
};

/**
 * This method adds the static tooltip overlay to the map's overlays.
 * @param {ol.PluggableMap} map
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 * @override
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.setMap = function (map) {
  if (map == null) {
    this.removeOverlays(this.getMap());
  }
  alk.interaction.TrafficCameraPopupInteraction.base(this, 'setMap', map);
  if (this.getMap()) {
    this.getMap().addOverlay(this.getTooltipOverlay());
  }
};

/**
 * This method removes any of the overlays that were placed on the map.
 * @param {ol.PluggableMap} map
 * @this {alk.interaction.TrafficCameraPopupInteraction}
 * @api
 */
alk.interaction.TrafficCameraPopupInteraction.prototype.removeOverlays = function (map) {
  if (map) {
    map.removeOverlay(this.getTooltipOverlay());
    if (this.currentPopups_) {
      this.currentPopups_.forEach(function (popup) {
        map.removeOverlay(popup);
      });
    }
  }
};
goog.provide('alk.overlay.TrafficIncidentPopup');

goog.require('alk.overlay');

goog.require('alkx.TrafficIncidentSpec');
goog.require('alkx.TrafficIncidentPopupOptions');

/**
 * @classdesc
 * An instance of this class provides an overlay on the map
 * that will show a TrafficIncidentPopup. It creates the
 * following structure in the DOM.
 *
 * <div class='alk-popup'>
 *   <a class='alk-popup-close' href='#'></a>
 *   <div class='alk-popup-header'>Traffic Incident</div>
 *   <div class='alk-popup-content alk-traffic-incident'>
 *     <ul class='alk-popup-list'>
 *       <li class='alk-popup-item alk-ti-title'>...</li>
 *       <li class='alk-popup-item alk-ti-description'>...</li>
 *     </ul>
 *   </div>
 * </div>
 *
 * @description
 * This constructor creates a DOM element that will be displayed
 * for an ALK supplied Traffic Incident in a map.
 *
 * @param {alkx.TrafficIncidentPopupOptions=} opt_options
 * @constructor
 * @extends {ol.Overlay}
 * @api
 */
alk.overlay.TrafficIncidentPopup = function (opt_options) {
  /** @type {alkx.TrafficIncidentPopupOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var element = null;
  var close = null;
  if (options.trafficIncident) {
    var ce = this.createPopupElement(options.trafficIncident);
    element = ce.element;
    close = ce.close;
  }

  /** @type {olx.OverlayOptions} */
  var opts = {
    id: options.id,
    element: element,
    offset: options.offset,
    position: options.position,
    positioning: options.positioning,
    stopEvent: options.stopEvent,
    insertFirst: options.insertFirst,
    autoPan: options.autoPan,
    autoPanAnimation: options.autoPanAnimation,
    autoPanMargin: options.autoPanMargin
  };
  alk.overlay.TrafficIncidentPopup.base(this, 'constructor', opts);

  this.closeElement = close;
};
goog.inherits(alk.overlay.TrafficIncidentPopup, ol.Overlay);

/**
 * This property holds the close element.
 * @type {Element}
 * @api
 */
alk.overlay.TrafficIncidentPopup.prototype.closeElement;

/**
 * This method sets the traffic camera metadata for this popup.
 * @param {alkx.TrafficIncidentSpec} trafficIncidentSpec The Traffic Camera.
 * @fires {change:element} Fires this event when changed.
 * @this {alk.overlay.TrafficIncidentPopup}
 * @api
 */
alk.overlay.TrafficIncidentPopup.prototype.setTrafficIncident = function (trafficIncidentSpec) {
  var ce = this.createPopupElement(trafficIncidentSpec);
  this.closeElement = ce.close;
  this.setElement(ce.element);
};

/**
 * This property contains the HTML string that has {{content}} string for form the list in the
 * weather alert.
 * @type {string}
 * @api
 */
alk.overlay.TrafficIncidentPopup.prototype.listFormat =
  '<ul class="{{class}}">{{content}}</ul>';

/**
 * This method returns the inner HTML, which is a list of items.
 * @param {string} format The format of the list that contains {{class}} and {{content}}
 * @param {string} klass The class of the list, if applicable.
 * @param {string} content The HTML string of the list contents.
 * @returns {string}
 * @api
 */
alk.overlay.TrafficIncidentPopup.prototype.createListHTML = function (format, klass, content) {
  var str = format;
  str = str.replace(/\{\{class\}\}/g, klass);
  str = str.replace(/\{\{content\}\}/g, content);
  return str;
};

/**
 * This returns the div for the Traffic Camera
 * @param {alkx.TrafficIncidentSpec} trafficIncident
 * @returns {Element}
 * @this {alk.overlay.TrafficIncidentPopup}
 * @api
 */
alk.overlay.TrafficIncidentPopup.prototype.createContentElement = function (trafficIncident) {
  var children = [];
  var title = trafficIncident.DescriptionShort || trafficIncident.EventCategory;
  if (title) {
    children.push('<li class="alk-popup-item alk-ti-title">' + title + '</li>');
  }
  var description = trafficIncident.DescriptionLong;
  if (description) {
    children.push('<li class="alk-popup-item alk-ti-description">'+
       description + '.</li>');
  }
  var listContentHTML = children.join('');
  var listHTML = this.createListHTML(this.listFormat, 'alk-popup-list', listContentHTML);
  var content = document.createElement('div');
  content.className = 'alk-popup-content alk-traffic-incident';
  content.innerHTML = listHTML;
  return content;
};

/**
 * This creates the popup element.
 * @param {alkx.TrafficIncidentSpec} alert
 * @returns {{close: Element, element: Element}}
 * @this {alk.overlay.TrafficIncidentPopup}
 * @api
 */
alk.overlay.TrafficIncidentPopup.prototype.createPopupElement = function (alert) {
  var content = this.createContentElement(alert);
  var popup = document.createElement('div');
  popup.className = 'alk-popup';
  var header = document.createElement('div');
  header.className = 'alk-popup-header';
  header.innerHTML = "<strong>Traffic Incident</strong>";
  var close = document.createElement('a');
  close.href = "#";
  close.className = 'alk-popup-close';
  popup.appendChild(header);
  popup.appendChild(close);
  popup.appendChild(content);
  return {
    close: close,
    element: popup
  };
};
goog.provide('alk.interaction.TrafficIncidentPopupInteraction');

goog.require('alk.interaction');
goog.require('alk.overlay.ListTooltipOverlay');
goog.require('alk.overlay.TrafficIncidentPopup');

goog.require('alkx.TrafficIncidentPopupInteractionOptions');
/**
 * @classdesc
 * An object of this class provides a means by which users may interact
 * with features on the map that are traffic incidents or clusters
 * of traffic incidents, providing tooltips and clickable popups.
 * @description
 * This constructor creates an Interaction object that gives its user
 * the ability to interact with traffic incidents show in the layer.
 *
 * @param {alkx.TrafficIncidentPopupInteractionOptions=} opt_options
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @api
 */
alk.interaction.TrafficIncidentPopupInteraction = function (opt_options) {
  var self = this;
  ///** @type {alkx.TrafficIncidentPopupInteractionOptions} */
  //var options = opt_options !== undefined ? opt_options : {};
  /** @type {olx.interaction.InteractionOptions} */
  var opts = {
    handleEvent:
      /**
       * @param {ol.MapBrowserEvent} evt
       * @returns {boolean}
       */
      function (evt) {
        return self.handleMapBrowserEvent(evt);
      }
  };

  alk.interaction.TrafficIncidentPopupInteraction.base(this, 'constructor', opts);

  this.tooltipOverlay_ = this.createTooltipOverlay();
  this.currentPopups_ = [];
};
goog.inherits(alk.interaction.TrafficIncidentPopupInteraction, ol.interaction.Interaction);

/**
 * This property holds the created tooltipOverlay.
 * @type {alk.overlay.ListTooltipOverlay}
 * @private
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.tooltipOverlay_;

/**
 * This property holds the currently displayed popups.
 * @type {Array.<ol.Overlay>}
 * @private
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.currentPopups_;

/**
 * This returns the current tooltip overlay in use with this interaction object.
 * This object persists throughout the life of this interaction object.
 * @returns {alk.overlay.ListTooltipOverlay}
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 * @protected
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.getTooltipOverlay = function () {
  return this.tooltipOverlay_;
};

/**
 * This method creates the tooltip overlay that will be used to hover over
 * features with one or multiple (in the event of clustering). It will only be
 * called once as it is persistent for the life of this interaction object.
 * @returns {alk.overlay.ListTooltipOverlay}
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 * @protected
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.createTooltipOverlay = function() {
  return new alk.overlay.ListTooltipOverlay({
    cssClass: 'alk-traffic-incident',
    offset: [20, 0],
    positioning: "bottom-left" /* ol.OverlayPositioning.BOTTOM_LEFT */
  });
};

/**
 * This method handles a tooltip event. Usually this event is the 'pointermove'
 * event.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.handleTooltipEvent = function(evt) {
  if (this.currentPopups_ && this.currentPopups_.length > 0) {
    return;
  }
  var features = this.getFeatures(evt);
  var tooltip = this.getTooltipOverlay();
  if (features) {
    tooltip.setPosition(evt.coordinate);
    tooltip.setDisplay(true);
    if (tooltip.getAssigned() !== true) {
      tooltip.setAssigned(true);
      features.forEach(function (feature) {
        var incident = /** @type {alkx.TrafficIncidentSpec} */(feature.get('trafficIncident'));
        tooltip.addListItem(incident.DescriptionShort || incident.EventCategory);
      });
    }
  } else {
    tooltip.clear();
    tooltip.setDisplay(false);
  }
};
/**
 * This method returns a list of traffic camera features found under the
 * event pixel. It first looks for a cluster feature and if they are all of
 * the same coordinates, they are returned. It never returns more than
 * four features.
 * @param {ol.MapBrowserEvent} evt
 * @returns {Array.<ol.Feature>|undefined}
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.getFeatures = function (evt) {
  var features = this.getMap().forEachFeatureAtPixel(evt.pixel, function (feature) {
    var features = /** @type {Array.<ol.Feature>} */(feature.get('features'));
    if (features && features.length < 5) {
      var coord = features[0].getGeometry().getCoordinates();
      if (features.every(function(feature) {
          return ol.coordinate.equals(coord, feature.getGeometry().getCoordinates())
            && feature.get('trafficIncident');
        })) {
        return features;
      }
    }
  });
  if (!features) {
    var cameraFeatures = [];
    features = this.getMap().forEachFeatureAtPixel(evt.pixel, function (feature) {
      var incident = /** @type {alkx.TrafficIncidentSpec} */(feature.get('trafficIncident'));
      if (incident) {
        cameraFeatures.push(feature);
      }
    });
    if (cameraFeatures.length > 0) {
      features = cameraFeatures;
    }
  }
  return features ? features.slice(0,4) : undefined;
};

/**
 * This method handles the popup event. Usually this is a pointer 'click' event.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.handlePopupEvent = function (evt) {
  var self = this;
  var tooltip = this.getTooltipOverlay();
  tooltip.clear();
  tooltip.setDisplay(false);

  if (this.currentPopups_) {
    this.currentPopups_.forEach(function (popup) {
      self.getMap().removeOverlay(popup);
    });
    this.currentPopups_ = [];
  }
  var features = this.getFeatures(evt);
  if (features) {
    this.displayPopups(features);
  }
};

/**
 * This method displays popups for the given traffic camera features.
 * @param {Array.<ol.Feature>} features
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 * @protected
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.displayPopups = function (features) {
  var self = this;
  if (features) {
    features.forEach(function (feature) {
      var trafficIncident = /** @type {alkx.TrafficIncidentSpec} */(feature.get('trafficIncident'));
      var popup = new alk.overlay.TrafficIncidentPopup({
        autoPan: true,
        trafficIncident: trafficIncident
      });
      self.getMap().addOverlay(popup);
      // We must do setPosition after we add it to the map, otherwise it will not pan into view.
      popup.setPosition(feature.getGeometry().getCoordinates());
      self.currentPopups_.push(popup);
      popup.closeElement.onclick = function () {
        (/** (Element) */(this)).blur();
        popup.setPosition(undefined);
        // remove it from the current popups.
        self.currentPopups_ = self.currentPopups_.filter(function(x){return x !== popup;});
        self.getMap().removeOverlay(popup);
      };
      // We bring the popup to the top on a click.
      // Based on reordering. Last added ends up behind.
      popup.getElement().onclick = function () {
        self.currentPopups_.forEach(function(p) {
          if (p !== popup) {
            self.getMap().removeOverlay(p);
            self.getMap().addOverlay(p);
          }
        });
      };
    });
  }
};

/**
 * This handles this interaction's map browser events when it is placed on the map.
 * @param {ol.MapBrowserEvent} evt
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 * @returns {boolean}
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.handleMapBrowserEvent = function (evt) {
  if (evt.dragging) {
    return true;
  }
  switch (evt.type) {
    case "pointermove" /* ol.pointer.EventType.POINTERMOVE */:
      this.handleTooltipEvent(evt);
      return false;
    case "click" /* ol.events.EventType.CLICK */:
      this.handlePopupEvent(evt);
      return false;
    default:
      return true;
  }
};

/**
 * This method adds the static tooltip overlay to the map's overlays.
 * @param {ol.PluggableMap} map
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 * @override
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.setMap = function (map) {
  if (map == null) {
    this.removeOverlays(this.getMap());
  }
  alk.interaction.TrafficIncidentPopupInteraction.base(this, 'setMap', map);
  if (this.getMap()) {
    this.getMap().addOverlay(this.getTooltipOverlay());
  }
};

/**
 * This method removes any of the overlays that were placed on the map.
 * @param {ol.PluggableMap} map
 * @this {alk.interaction.TrafficIncidentPopupInteraction}
 * @api
 */
alk.interaction.TrafficIncidentPopupInteraction.prototype.removeOverlays = function (map) {
  if (map) {
    map.removeOverlay(this.getTooltipOverlay());
    if (this.currentPopups_) {
      this.currentPopups_.forEach(function (popup) {
        map.removeOverlay(popup);
      });
    }
  }
};
goog.provide('alk.interaction.ViaPointRouteModify');

goog.require('alk.interaction.RouteModify');

goog.require('alkx.interaction.RouteModifyOptions');

/**
 * @classdesc
 * An instance of this class provides a Route Modify object for the
 * {@link alk.layer.RoutingLayer}.
 * @description
 * This constructor creates an Interaction object that provides a Route
 * Modify object for the {@link alk.layer.RoutingLayer} that only creates
 * and deletes ViaPoints.
 *
 * The given stops, or stops labeled {@link alk.val.StopType.WayPoint},
 * {@link alk.val.StopType.Origin} or {@link alk.val.StopType.Destination}
 * are protected in that they cannot be deleted or moved. Any points created on the
 * route will be created as ViaPoints and they subsequently may be deleted.
 *
 * @param {alkx.interaction.RouteModifyOptions=} opt_options
 * @constructor
 * @extends {alk.interaction.RouteModify}
 * @api
 */
alk.interaction.ViaPointRouteModify = function(opt_options) {
  // Actually, the base object is this RouteModify's behavior.
  alk.interaction.ViaPointRouteModify.base(this, 'constructor', opt_options);
};
goog.inherits(alk.interaction.ViaPointRouteModify, alk.interaction.RouteModify);
goog.provide('alk.style.WayPointsEditRouteStyle');

goog.require('alk.color');
goog.require('alk.style.EditRouteStyle');

/**
 * @classdesc
 * An instance of this class is a RoutingLayer style function for the
 * {@link alk.layer.RoutingLayer}. However, this particular one is used
 * on a {@link alk.interaction.RouteModify} object to style the
 * the features being modified.
 *
 * Essentially this object reverses the stroke and fill colors
 * of the stops.
 * @description
 * This constructor creates a style function that will style the
 * Routing Layer in such a way that it handles points classified as
 * Waypoints.
 *
 * @param {{
 *  strokeQueue: (alk.style.StrokeQueue|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.EditRouteStyle}
 * @api
 */
alk.style.WayPointsEditRouteStyle = function (opt_options) {
  alk.style.WayPointsEditRouteStyle.base(this, 'constructor', opt_options);
};
goog.inherits(alk.style.WayPointsEditRouteStyle, alk.style.EditRouteStyle);

/**
 * This function returns the default image for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.Origin}.
 *
 * For this implementation, the defaultOriginImage is used for all stopTypes of
 * {@link alk.val.StopType.Origin} regardless of the route's stroke color.
 *
 * It is the reverse of the default used in {@link alk.style.StopsRouteStyle}.
 *
 * @returns {ol.style.Image}
 * @override
 * @this {alk.style.WayPointsEditRouteStyle}
 * @api
 */
alk.style.WayPointsEditRouteStyle.prototype.defaultOriginImage = function() {
  return new ol.style.Circle({
    radius: 6.6,
    fill: new ol.style.Fill({
      color: '#ffec6e',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(039,159,000,1.0)',
      width: 5.5
    })
  });
};

/**
 * This function returns the default style for a stop feature with the feature's
 * 'stopType' property of {@link alk.val.StopType.Destination}.
 *
 * For this implementation, the defaultOriginImage is used for all stopTypes of
 * {@link alk.val.StopType.Destination} regardless of the route's stroke color.
 *
 * It is the reverse of the default used in {@link alk.style.StopsRouteStyle}.
 *
 * @returns {ol.style.Image}
 * @override
 * @this {alk.style.WayPointsEditRouteStyle}
 * @api
 */
alk.style.WayPointsEditRouteStyle.prototype.defaultDestinationImage = function() {
  return new ol.style.Circle({
    radius: 6.6,
    fill: new ol.style.Fill({
      color: '#ffec6e',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(191,037,037,1.0)',
      width: 5.5
    })
  });
};

/**
 * This function returns the default image for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.ViaPoint}.
 *
 * For this implementation, the defaultOriginImage is used for all stopTypes of
 * {@link alk.val.StopType.Origin} regardless of the route's stroke color.
 *
 * It is the reverse of the default used in {@link alk.style.StopsRouteStyle}.
 *
 * @returns {ol.style.Image}
 * @override
 * @this {alk.style.WayPointsEditRouteStyle}
 * @api
 */
alk.style.WayPointsEditRouteStyle.prototype.defaultViaPointImage = function() {
  return new ol.style.Circle({
    radius: 5,
    fill: new ol.style.Fill({
      color: '#ffec63',
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(191,037,037,0.9)',
      width: 1
    })
  });
};

/**
 * This function returns the image to use in styling a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.WayPoint}.
 *
 * This implementation returns a {@link ol.style.Circle} styled with a white fill, and a color
 * border of the route's stroke color. The width of the stroke is 3 pixels, and the radius of the
 * circle is 9 pixels.
 *
 * @param {ol.style.Stroke} stroke The route's stroke style.
 * @returns {ol.style.Image}
 * @override
 * @this {alk.style.WayPointsEditRouteStyle}
 * @api
 */
alk.style.WayPointsEditRouteStyle.prototype.getWayPointImage = function (stroke) {
  var width = 3;
  var radius = 9;
  var color = stroke.getColor();
  var ncolor = alk.color.shadeColor(color, 0);
  return new ol.style.Circle({
    radius: radius,
    fill: new ol.style.Fill({
      color: "#ffec6e",
      opacity: 1.0
    }),
    stroke: new ol.style.Stroke({
      color: ncolor,
      width: width
    })
  });
};

/**
 * This function returns the image to use in styling a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.ViaPoint}.
 *
 * This implementation returns a the image used for a WayPoint, since
 * in this Modify model we are creating way points and not via points.
 *
 * @param {ol.style.Stroke} stroke The route's stroke style.
 * @returns {ol.style.Image}
 * @override
 * @this {alk.style.WayPointsEditRouteStyle}
 * @api
 */
alk.style.WayPointsEditRouteStyle.prototype.getViaPointImage = function (stroke) {
  return this.getWayPointImage(stroke);
};

/**
 * This style function returns a style for a stop feature with the
 * feature's 'stopType' property of {@link alk.val.StopType.WayPoint}.
 *
 * This implementation returns the image returned by {@link alk.style.StopsRouteStyle#getWayPointImage},
 * superimposed with a index corresponding to the feature's 'logicalStopIndex' property. The index is
 * a letter or number based on whether the feature's 'hubRouting' property is set to true,
 * or not, respectively.
 *
 * @param {ol.Feature} feature The stop feature
 * @param {number} resolution
 * @returns {ol.style.Style|null}
 * @override
 * @this {alk.style.WayPointsEditRouteStyle}
 * @api
 */
alk.style.WayPointsEditRouteStyle.prototype.getWayPointStyleFunction = function (feature, resolution) {
  var strokeStyle = this.getStrokeStyle(feature, resolution);
  var textStyle = this.getWayPointText(feature, resolution);
  var image = this.getWayPointImage(strokeStyle);
  var style = new ol.style.Style({
    image: image,
    text: textStyle
  });
  if (feature.get('pending')) {
    // TODO: something here. Unfortunately, we set 'pending' in RouteModify.handleModifyStartEvent_, but although
    // this styler reacts on a hover, it apparently doesn't register the pointerdown even until the
    // pointer is down and it moves, which is counter productive here, because we wanted to use it to
    // style between down and up events, especially for a delete, where we wanted it to style differently
    // on a down, until it got dragged. We only want a 'delete' styling when the pointer is down
    // and the stop hasn't moved. Once it moves, it should just go back to the normal hover highlight until
    // the pointer lets up.
  }
  return style;
};

goog.provide('alk.interaction.WayPointRouteModify');

goog.require('alk.interaction.RouteModify');
goog.require('alk.style.StrokeQueue');
goog.require('alk.style.WayPointsEditRouteStyle');

goog.require('alkx.interaction.RouteModifyOptions');

/**
 * @classdesc
 * An instance of this class provides a Route Modify object for the
 * {@link alk.layer.RoutingLayer}.
 * @description
 * This constructor creates an Interaction object that
 * provides a Route Modify object for the
 * {@link alk.layer.RoutingLayer} that only creates and deletes WayPoints.
 * The given stops, or stops labeled {@link alk.val.StopType.WayPoint},
 * {@link alk.val.StopType.Origin} or {@link alk.val.StopType.Destination}
 * are not protected so they may be deleted. Any points created on the
 * route will be created as WayPoints, which may increase or decrease the
 * numbering or lettering of the WayPoints accordingly..
 *
 * @param {alkx.interaction.RouteModifyOptions=} opt_options
 * @constructor
 * @extends {alk.interaction.RouteModify}
 * @api
 */
alk.interaction.WayPointRouteModify = function (opt_options) {
  /** @type {alkx.interaction.RouteModifyOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  var opts = {
    condition: options.condition,
    //deleteCondition: undefined,
    pixelTolerance: options.pixelTolerance || 2,
    routingLayer: options.routingLayer,
    style: options.style,
    wrapX: options.wrapX
  };
  alk.interaction.WayPointRouteModify.base(this, 'constructor', opts);

  this.modifiableStopTypes_ = [
    alk.val.StopType.ViaPoint,
    alk.val.StopType.WayPoint,
    alk.val.StopType.Origin,
    alk.val.StopType.Destination
  ];
};
goog.inherits(alk.interaction.WayPointRouteModify, alk.interaction.RouteModify);

/**
 * @type {Array.<alk.val.StopType>}
 */
alk.interaction.WayPointRouteModify.prototype.modifiableStopTypes_;

/**
 * @inheritDoc
 */
alk.interaction.WayPointRouteModify.prototype.getCreationStopType = function () {
  return alk.val.StopType.WayPoint;
};

/**
 * @inheritDoc
 * @this {alk.interaction.WayPointRouteModify}
 */
alk.interaction.WayPointRouteModify.prototype.getModifiableStopTypes = function () {
  return this.modifiableStopTypes_;
};

/**
 * This function decides whether a stop will be modifiable by this
 * Route Modify, depending on coordinates, index, and stopType.
 *
 * This implementation allows all WayPoints and ViaPoints, regardless.
 *
 * @param {Array.<number>} coords
 * @param {number} index
 * @param {alk.val.StopType|undefined} stopType
 * @returns {boolean}
 * @override
 * @api
 */
alk.interaction.WayPointRouteModify.prototype.shouldModify = function (coords, index, stopType) {
  return true;
};


/**
 * This function assigns or creates the RoutingLayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.RoutingLayerStyle|alk.style.StrokeQueue|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.interaction.WayPointRouteModify}
 * @override
 * @protected
 */
alk.interaction.WayPointRouteModify.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.RoutingLayerStyle) {
      self.routingLayerStyle = optStyle;
      style = function (feature, resolution) {
        return self.sketchFeatureStyleFunction(feature, resolution);
      };
    } else {
      var strokeQueue;
      if (optStyle instanceof alk.style.StrokeQueue) {
        strokeQueue = /** @type {alk.style.StrokeQueue} */ (optStyle.style);
      } else if (optStyle instanceof ol.style.Stroke) {
        var stroke = /** @type {ol.style.Stroke} */ (optStyle);
        strokeQueue = new alk.style.StrokeQueue({strokes: [stroke]});
      } else if (typeof optStyle === 'string') {
        var color = /** @type {string} */ (optStyle);
        strokeQueue = new alk.style.StrokeQueue({colors: [color]});
      } else if (optStyle instanceof Array) {
        var array = /** @type {Array.<*>} */ (optStyle);
        if (array.length > 0 && array[0] instanceof ol.style.Stroke) {
          strokeQueue = new alk.style.StrokeQueue({
            strokes: /** @type {Array.<ol.style.Stroke>} */(array)
          });
        }
      }
      if (this.routingLayer !== undefined) {
        var rlStyle = this.routingLayer.getRoutingLayerStyle();
        if (rlStyle instanceof alk.style.QueuedLineRouteStyle) {
          strokeQueue = /** @type {alk.style.QueuedLineRouteStyle} */(rlStyle).getStrokeQueue();
        }
      }
      if (strokeQueue !== undefined) {
        this.routingLayerStyle = new alk.style.WayPointsEditRouteStyle({
          strokeQueue: strokeQueue
        });
        style = function (feature, resolution) {
          return self.sketchFeatureStyleFunction(feature, resolution);
        };
      } else {
        // We just go with the supplied style.
        style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
      }
    }
  } else {
    if (this.routingLayerStyle === undefined) {
      this.routingLayerStyle = new alk.style.WayPointsEditRouteStyle({
        routingLayer: this.routingLayer
      });
    }
    style = function (feature, resolution) {
      return self.sketchFeatureStyleFunction(feature, resolution);
    };
  }
  return style;
};
goog.provide('alk.layer');

goog.require('alk');

alk.layer = {};goog.provide('pcmws.api.MapTileService');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.MapTileServiceOptions');
goog.require('pcmws.api.MapTileURL');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.Width');
goog.require('pcmws.api.X');
goog.require('pcmws.api.Y');
goog.require('pcmws.api.Z');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the OpenLayers XYZ source layer for
 * PCMiler Maptile service.
 * @param {pcmws.api.MapTileServiceOptions=} opt_options Options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.MapTileService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['drawerGroups', pcmws.api.DrawerGroups],
    ['format', pcmws.api.Format],
    ['imgOption', pcmws.api.ImgOption],
    ['imgSrc', pcmws.api.ImgSrc],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['style', pcmws.api.Style],
    ['width', pcmws.api.Width],
    ['height', pcmws.api.Height],
    ['x', pcmws.api.X, '{x}'],
    ['y', pcmws.api.Y, '{y}'],
    ['z', pcmws.api.Z, '{z}']
  ];
  pcmws.api.MapTileService.base(this, 'constructor', specs, opt_options);
  /** @type {pcmws.api.MapTileServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.MapTileURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.MapTileService, pcmws.api.StaticService);

/**
 * @override
 * @returns {pcmws.api.MapTileService}
 * @this {pcmws.api.MapTileService}
 */
pcmws.api.MapTileService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.MapTileServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.MapTileService(opts);
};

/**
 * @override
 * @returns {string}
 * @this {pcmws.api.MapTileService}
 */
pcmws.api.MapTileService.prototype.constructURL = function (hostURL, path, paramsArray) {
  var url = pcmws.api.MapTileService.base(this, 'constructURL', hostURL, path, paramsArray);

  function bg(p){
    return (p.value === 'Background');
  }

  var bgTile = paramsArray.filter(bg);

  if (bgTile.length === 0){
    url = url.replace('style=', 'vectorStyle=');
  } else {
    paramsArray.push(new pcmws.api.Param("provider", "DigitalGlobeAPIImagery"));
    paramsArray.push(new pcmws.api.Param("proj", "EPSG:900913"));
    url = pcmws.api.MapTileService.base(this, 'constructURL', pcmws.api.ContentServiceURL.prototype.hostURL, pcmws.api.SatelliteTileURL.prototype.path, paramsArray);
  }

  return url;
};

/**
 * @description
 * This method will get the parse the JSON from an HTTP response from this configured
 * service using the URL that is generated by {@link getAttributionURL}. It does NOT
 * pass this result through {@link pcmws.api.StaticService#processResponse}.
 *
 * @param {(Object|function(Object))=} opts_or_callback The options that
 *               will combine with the base options
 *               overriding any options set in the base, or the response callback.
 * @param {function(Object)=} responseCallback
 *
 * @override
 * @this {pcmws.api.MapTileService}
 */
pcmws.api.MapTileService.prototype.getAttribution = function(opts_or_callback, responseCallback) {
  /** @type {function(Object)|undefined} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    callback = responseCallback;
  }
  if (typeof callback === 'function') {
    callback.call(this, {
      text: "Copyright &copy; " + new Date().getFullYear() + " ALK Technologies Inc. Portions &copy; OpenStreetMap contributors.",
      url: 'http://alkmaps.com',
      image: pcmws.ALK_LOGO_URL
    });
  }
};
goog.provide('alk.service.MapTileService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.MapTileService');

goog.require('alkx.MapTileServiceOptions');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults, generates a URL for the
 * ALK Map Tile service.
 * @description
 * This constructor creates a Service object that accesses the various ALK Image Map Tile
 * Services. It is primarily used in {@link alk.source.BaseMapSource}.
 * @param {alkx.MapTileServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.MapTileService = function (opt_options) {
  alk.service.MapTileService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.mapTileService = this.pcmws = new pcmws.api.MapTileService(this.pcmServiceOptions);
};
goog.inherits(alk.service.MapTileService, alk.service.Service);

/**
 * @description
 * The ALK Map Tile Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.MapTileService} object.
 *
 * @type {pcmws.api.MapTileService}
 */
alk.service.MapTileService.prototype.mapTileService;
goog.provide('alk.source.XYZSource');

goog.require('alk');
goog.require('alk.source');

goog.require('alkx.XYZSourceOptions');

/**
 * @classdesc
 * An instance of this class takes a alk.service.Service object, which generates the XYZ URL for the OpenLayers
 * XYZ source. It is meant to be extended.
 * @description
 * This constructor is the base constructor for an XYZ Source object for accessing ALK Sources.
 *
 * Important options:
 *
 * **service**:
 *
 * This option contains the {@link alk.service.Service} that will create the
 * URL that has the {x}, {y}, {z} template in it.
 *
 * **attribution**:
 *
 * This option contains the attribution object for this source. This option is an override.
 * Should a subclass not provide one, the service will be asked for its attribution.
 * Should that not be provided, the default ALK attribution will be supplied.
 *
 * @constructor
 * @extends {ol.source.XYZ}
 * @param {alkx.XYZSourceOptions=} opt_options Options
 * @api
 */
alk.source.XYZSource = function (opt_options) {
  /** @type {alkx.XYZSourceOptions} */
  var options = opt_options !== undefined? opt_options : {};

  if (options.service !== undefined) {
    this.service = options.service;
  }

  if (this.service == null) {
    throw 'No Tile Service or URL Defined.';
  }

  var url = this.service.getURL();

  alk.source.XYZSource.base(this, 'constructor', {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileSize: options.tileSize,
    tileUrlFunction: options.tileUrlFunction,
    url: url,
    wrapX: options.wrapX,
    transistion: options.transition
  });

  var self = this;
  var attributions = this.getAttributions();
  if (attributions == null || attributions.length === 0) {
    this.service.getAttribution(function (obj, data, success) {
      self.processAttributionResponse.call(self, obj);
    });
  }
};
goog.inherits(alk.source.XYZSource, ol.source.XYZ);

/**
 * This method sets the Service for this source. It generates a new URL.
 *
 * @param {alk.service.Service} service
 * @this {alk.source.XYZSource}
 * @api
 */
alk.source.XYZSource.prototype.setService = function (service) {
  this.service = service;
  this.setUrl(service.getURL());
};

/**
 * @description
 * This is the service that was used to create the URL. It is not used internally,
 * and just serves as a reference.
 * @type {alk.service.Service}
 * @readonly
 * @api
 */
alk.source.XYZSource.prototype.service;

/**
 *
 * @param {alkx.AttributionJSON=} attributionJSON
 * @this {alk.source.XYZSource}
 */
alk.source.XYZSource.prototype.processAttributionResponse = function(attributionJSON) {
  /** @type {ol.AttributionLike} */
  var attribution;
  if (attributionJSON) {
    var text = attributionJSON.text;
    var url = attributionJSON.url;
    var image = attributionJSON.image;
    attribution = '<a href="'+url+'" target="_blank"><img src="'+image+'">'+text+'</a>';
  } else {
    attribution = alk.ATTRIBUTION;
  }
  this.setAttributions([attribution]);
};
goog.provide('alk.source.ImageTileSource');

goog.require('alk.source');
goog.require('alk.source.XYZSource');

goog.require('alkx.XYZSourceOptions');

/**
 * @classdesc
 * An instance of this class takes a alk.service.Service object, which generates the XYZ URL for the OpenLayers
 * XYZ source. Specifically, this works for Image Tiles from various services,
 * such as {@link alk.service.MapTileService} and {@link alk.service.TrafficTileService}
 *
 * @description
 * This constructor creates a Source object to get ALK Image Tiles from ALK Tile Services.
 *
 * The argument precedence is the following:
 * 1. url:      contains the full URL of the XYZService. Note, this is an override.
 * 2. service:  Contains the alk.service.Service object
 * @constructor
 * @extends {alk.source.XYZSource}
 * @param {alkx.XYZSourceOptions=} opt_options Options
 * @api
 */
alk.source.ImageTileSource = function (opt_options) {
  alk.source.ImageTileSource.base(this, 'constructor', opt_options);
  // TODO: Technically, there is nothing to do here, but we may have some different options if it comes to vector tiles.
};
goog.inherits(alk.source.ImageTileSource, alk.source.XYZSource);
goog.provide('alk.source.BaseMapSource');

goog.require('alk.service.MapTileService');
goog.require('alk.source.ImageTileSource');

goog.require('alkx.BaseMapSourceOptions');

/**
 * @classdesc
 * An instance of this class contains the ALK source that is used
 * in the {@link alk.layer.BaseMapLayer}.
 *
 * It is an {@link ol.source.Tile} source that uses the ALK Map Tile Service.
 * @description
 * This constructor creates a Source object with which to access an
 * ALK Map Tile Service.
 *
 * @param {alkx.BaseMapSourceOptions=} opt_options
 * @extends {alk.source.ImageTileSource}
 * @constructor
 * @api
 */
alk.source.BaseMapSource = function (opt_options) {
  /** @type {alkx.BaseMapSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.MapTileServiceOptions} */
  var serviceOptions = options.serviceOptions !== undefined ? options.serviceOptions : {};

  var service = new alk.service.MapTileService(serviceOptions);

  alk.source.BaseMapSource.base(this, 'constructor', {
    attributions: options.attributions,
    service: service,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    opaque: options.opaque,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileSize: options.tileSize,
    tileUrlFunction: options.tileUrlFunction,
    wrapX: options.wrapX,
    transition: options.transition
  });
};
goog.inherits(alk.source.BaseMapSource, alk.source.ImageTileSource);
goog.provide('alk.layer.ImageTileLayer');

//goog.require('ol.layer.Tile');

goog.require('alk.layer');
goog.require('alk.source.ImageTileSource');

goog.require('alkx.TileLayerOptions');

/**
 * @classdesc
 * An instance of this class forms an Image based Tile Layer
 * for an ALK Image Tile Source.
 * @description
 * This constructor creates an Image based Tile Layer for an
 * {@link alk.source.ImageTileSource}.
 *
 * @param {alkx.TileLayerOptions=} opt_options
 * @extends {ol.layer.Tile}
 * @constructor
 * @api
 */
alk.layer.ImageTileLayer = function (opt_options) {

  var options = opt_options || {};

  var source;

  if (options.source !== undefined) {
    source = options.source;
  }
  // TODO: Should this value be checked against null or wrong type?
  if (source === undefined) {
    if (options.sourceOptions !== undefined) {
      source = new alk.source.ImageTileSource(options.sourceOptions);
    }
  }
  if (source === undefined) {
    throw "No ALK Tile Source provided";
  }
  alk.layer.ImageTileLayer.base(this, 'constructor', {
    opacity: options.opacity,
    preload: options.preload,
    source: source,
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError,
    zIndex: options.zIndex
  });
};
goog.inherits(alk.layer.ImageTileLayer, ol.layer.Tile);
goog.provide('alk.layer.BaseMapLayer');

goog.require('alk.layer');
goog.require('alk.source.BaseMapSource');
goog.require('alk.layer.ImageTileLayer');

goog.require('alkx.BaseMapLayerOptions');
goog.require('alkx.BaseMapSourceOptions');

/**
 * @classdesc
 * An instance of this class is to be used for the base map (i.e. lowest)
 * layer in an {@link ol.Map}. It uses a {@link ol.source.Tile} source that is
 * specific to the ALK Map Tile Service.
 *
 * @description
 * This constructor creates an Openlayers compatible {@link ol.Layer} for an
 * {ol.Map} based on the default {@alk.source.BaseMapSource}.
 *
 * @example
 * var map = new ol.Map();
 * var baseLayer = new alk.layer.BaseMapLayer({
 *   sourceOptions: {
 *     serviceOptions: {
 *        style: alk.val.Style.Satellite
 *     }
 *   }
 * })
 * map.addLayer(baseLayer);
 *
 * @param {alkx.BaseMapLayerOptions=} opt_options
 * @extends {alk.layer.ImageTileLayer}
 * @constructor
 * @api
 */
alk.layer.BaseMapLayer = function(opt_options) {
  /** @type {alkx.BaseMapLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.BaseMapSourceOptions} */
  var sourceOptions = options.sourceOptions !== undefined ? options.sourceOptions : {};

  var source = new alk.source.BaseMapSource({
    attributions: sourceOptions.attributions,
    serviceOptions: sourceOptions.serviceOptions,
    cacheSize: sourceOptions.cacheSize,
    crossOrigin: sourceOptions.crossOrigin,
    opaque: sourceOptions.opaque,
    projection: sourceOptions.projection,
    reprojectionErrorThreshold: sourceOptions.reprojectionErrorThreshold,
    maxZoom: sourceOptions.maxZoom,
    minZoom: sourceOptions.minZoom,
    tileGrid: sourceOptions.tileGrid,
    tileLoadFunction: sourceOptions.tileLoadFunction,
    tilePixelRatio: sourceOptions.tilePixelRatio,
    tileSize: sourceOptions.tileSize,
    tileUrlFunction: sourceOptions.tileUrlFunction,
    wrapX: sourceOptions.wrapX,
    transition: sourceOptions.transition
  });

  alk.layer.BaseMapLayer.base(this, 'constructor',  {
    opacity: options.opacity,
    preload: options.preload,
    source: /** @type {alk.source.XYZSource} */(source),
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError
  });
};
goog.inherits(alk.layer.BaseMapLayer, alk.layer.ImageTileLayer);
goog.provide('pcmws.api.ReduceResponsePoints');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the ReduceResponsePoints parameter for a PCM service.
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.ReduceResponsePoints = function (value) {
  pcmws.api.ReduceResponsePoints.base(this, 'constructor', 'reduceResponsePoints', value);
};
goog.inherits(pcmws.api.ReduceResponsePoints, pcmws.api.BooleanParam);
goog.provide('pcmws.api.DriveTimePolygonService');

goog.require('pcmws.api');
goog.require('pcmws.api.AfSetIds');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.AvoidFavors');
goog.require('pcmws.api.AvoidTolls');
goog.require('pcmws.api.Axles');
goog.require('pcmws.api.Center');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DistanceUnits');
goog.require('pcmws.api.DriveTimePolygonServiceOptions');
goog.require('pcmws.api.DriveTimePolygonURL');
goog.require('pcmws.api.ElevationLimit');
goog.require('pcmws.api.EstimatedTimeOpts');
goog.require('pcmws.api.FerryDiscourage');
goog.require('pcmws.api.GovernorSpeedLimit');
goog.require('pcmws.api.HazMat');
goog.require('pcmws.api.HighwayOnly');
goog.require('pcmws.api.LCV');
goog.require('pcmws.api.Minutes');
goog.require('pcmws.api.OpenBorders');
goog.require('pcmws.api.OverrideClass');
goog.require('pcmws.api.OverrideRestrict');
goog.require('pcmws.api.ReduceResponsePoints');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.RouteType');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.TruckConfig');
goog.require('pcmws.api.VehicleDimensionUnits');
goog.require('pcmws.api.VehicleHeight');
goog.require('pcmws.api.VehicleLength');
goog.require('pcmws.api.VehicleType');
goog.require('pcmws.api.VehicleWeight');
goog.require('pcmws.api.VehicleWidth');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.DriveTimePolygonServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.DriveTimePolygonService = function (opt_options) {
  var specs = [
    ['afSetIds', pcmws.api.AfSetIds],
    ['authToken', pcmws.api.AuthToken],
    ['avoidFavors', pcmws.api.AvoidFavors],
    ['avoidTolls', pcmws.api.AvoidTolls],
    ['axles', pcmws.api.Axles],
    ['center', pcmws.api.Center],
    ['dataset', pcmws.api.Dataset],
    ['distanceUnits', pcmws.api.DistanceUnits],
    ['elevationLimit', pcmws.api.ElevationLimit],
    ['estimatedTimeOpts', pcmws.api.EstimatedTimeOpts],
    ['ferryDiscourage', pcmws.api.FerryDiscourage],
    ['governorSpeedLimit', pcmws.api.GovernorSpeedLimit],
    ['hazMat', pcmws.api.HazMat],
    ['highwayOnly', pcmws.api.HighwayOnly],
    ['lcv', pcmws.api.LCV],
    ['minutes', pcmws.api.Minutes],
    ['openBorders', pcmws.api.OpenBorders],
    ['overrideClass', pcmws.api.OverrideClass],
    ['overrideRestrict', pcmws.api.OverrideRestrict],
    ['reduceResponsePoints', pcmws.api.ReduceResponsePoints],
    ['region', pcmws.api.Region],
    ['routeOptimization', pcmws.api.RouteOptimization],
    ['routeType', pcmws.api.RouteType],
    ['sideOfStreetAdherence', pcmws.api.SideOfStreetAdherence],
    ['srs', pcmws.api.SRS],
    ['truckConfig', pcmws.api.TruckConfig],
    ['vehicleDimensionUnits', pcmws.api.VehicleDimensionUnits],
    ['vehicleHeight', pcmws.api.VehicleHeight],
    ['vehicleLength', pcmws.api.VehicleLength],
    ['vehicleType', pcmws.api.VehicleType],
    ['vehicleWeight', pcmws.api.VehicleWeight],
    ['vehicleWidth', pcmws.api.VehicleWidth]
  ];
  pcmws.api.DriveTimePolygonService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.DriveTimePolygonServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.DriveTimePolygonURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.DriveTimePolygonService, pcmws.api.StaticService);

/**
 * This method returns a clone of this DriveTimePolygonService object.
 * @override
 * @returns {pcmws.api.DriveTimePolygonService}
 * @this {pcmws.api.DriveTimePolygonService}
 *
 */
pcmws.api.DriveTimePolygonService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.DriveTimePolygonServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.DriveTimePolygonService(opts);
};
goog.provide('alk.service.DriveTimePolygonService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.DriveTimePolygonService');

goog.require('alkx.DriveTimePolygonServiceOptions');
goog.require('alkx.DriveTimePolygonServiceResponse');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK DriveTimePolygon Service.
 *
 * @description
 * This constructor creates a Service object to access the ALK Drive Time Polygon Service.
 * It is primarily used as URL generator in the {@link alk.source.DriveTimePolygonSource}.
 * @param {alkx.DriveTimePolygonServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.DriveTimePolygonService = function (opt_options) {
  alk.service.DriveTimePolygonService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.driveTimePolygonService = this.pcmws = new pcmws.api.DriveTimePolygonService(this.pcmServiceOptions);
};
goog.inherits(alk.service.DriveTimePolygonService, alk.service.Service);

/**
 * @description
 * The ALK DriveTimePolygon Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.DriveTimePolygonService} object.
 *
 * @type {pcmws.api.DriveTimePolygonService}
 */
alk.service.DriveTimePolygonService.prototype.driveTimePolygonService;


/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from DriveTimePolygon Service returns an object
 * containing a type identifier and list of coordinates, which defines a polygon.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.DriveTimePolygonService}.
 * @param {Object} obj The GeoJSON response from the {@link alk.service.DriveTimePolygonService}.
 * @returns {alkx.DriveTimePolygonServiceResponse} Containing the driveTimePolygonServiceOptions and if a successful call
 *  also contains an object containing the coordinates and a type property.
 * @override
 * @api
 */
alk.service.DriveTimePolygonService.prototype.processResponse = function (options, obj) {
  return {
    driveTimePolygonServiceOptions: /** @type {alkx.DriveTimePolygonServiceOptions} */(options),
    result: /** @type {alkx.DriveTimePolygonServiceResponse} */(obj)
  };
};

/**
 * @description
 * This method performs a call to the DriveTimePolygon Service to return a route.
 * @param {(alkx.DriveTimePolygonServiceOptions|null|function(alkx.DriveTimePolygonServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.DriveTimePolygonServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.DriveTimePolygonService}
 * @api
 */
alk.service.DriveTimePolygonService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.DriveTimePolygonServiceOptions} */
  var options = {};
  /** function(alkx.DriveTimePolygonServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.DriveTimePolygonServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.DriveTimePolygonService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.source.DriveTimePolygon');

goog.require('alk');
goog.require('alk.source');
goog.require('alk.service.DriveTimePolygonService');

goog.require('alkx.DriveTimePolygonSourceOptions');

/**
 * @classdesc
 * An instance of this class provides a vector source that may get a polygon for a point
 * and a driving time.
 *
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 * @fires {'change'} This event is fired when after the request to the
 *                         {@link alk.service.DriveTimePolygonService} is processed and a feature
 *                         is added.
 * @fires {'change:driveTimePolygons'}  Fires the 'change:driveTimePolygons' event when done processing the response.
 *
 *
 * @description
 * This constructor creates a Source object with which to access the ALK Drive Time Polygon
 * Service.
 *
 * @param {alkx.DriveTimePolygonSourceOptions=} opt_options
 *
 * @constructor
 * @extends {ol.source.Vector}
 * @api
 */
alk.source.DriveTimePolygon = function (opt_options) {
  /** @type {alkx.DriveTimePolygonSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.driveTimePolygonService_ = new alk.service.DriveTimePolygonService(options.driveTimePolygonServiceOptions);

  this.baseOptions_ = {
    driveTimePolygonServiceOptions: options.driveTimePolygonServiceOptions
  };

  var opts = {
    wrapX: options.wrapX
  };
  alk.source.DriveTimePolygon.base(this, 'constructor', opts);
};
goog.inherits(alk.source.DriveTimePolygon, ol.source.Vector);

/**
 * @type {alk.service.DriveTimePolygonService}
 * @private
 */
alk.source.DriveTimePolygon.prototype.driveTimePolygonService_;

/**
 * @returns {alk.service.DriveTimePolygonService}
 * @this {alk.source.DriveTimePolygon}
 * @api
 */
alk.source.DriveTimePolygon.prototype.getDriveTimePolygonService = function () {
  return this.driveTimePolygonService_;
};

/**
 * @param {alk.service.DriveTimePolygonService} service
 * @this {alk.source.DriveTimePolygon}
 * @api
 */
alk.source.DriveTimePolygon.prototype.setDriveTimePolygonService = function (service) {
  this.driveTimePolygonService_ = service;
};

/**
 * This attribute contains the options with which the DriveTimePolygon source was created.
 * @type {Object.<string,*>}
 * @private
 */
alk.source.DriveTimePolygon.prototype.baseOptions_;

/**
 * @type {number}
 * @private
 */
alk.source.DriveTimePolygon.prototype.featureIdCounter_;

/**
 * This method processes the response from the DriveTimePolygonService before it is handled by the
 * DriveTimePolygon Source. The default behavior is to pass it through.
 *
 * @param {alkx.DriveTimePolygonServiceResponse} response The response from the DriveTimePolygonService.
 * @param {function((alkx.DriveTimePolygonServiceResponse|undefined)=)=} success
 * @param {function((alkx.DriveTimePolygonServiceResponse|undefined)=)=} failure
 * @protected
 * @this {alk.source.DriveTimePolygon}
 */
alk.source.DriveTimePolygon.prototype.handleDriveTimePolygonServiceResponse = function (response, success, failure) {
  var result = response.result;
  if (result && result.type === 'Polygon') {
    var listOfCoordsList = result.coordinates;
    if (listOfCoordsList && listOfCoordsList instanceof Array && listOfCoordsList.length > 0) {
      var listOfCoords = listOfCoordsList[0];
      /**
       * @param {Array.<number>} coord
       * @returns {ol.Coordinate}
       */
      function fromLonLat(coord) {
        return ol.proj.fromLonLat(coord);
      }
      var pCoords = listOfCoords.map(fromLonLat);
      var geometry = new ol.geom.Polygon([pCoords]);
      var feature = new ol.Feature(geometry);
      feature.setId(alk.getUid(feature));
      this.addFeature(feature);
      if (typeof success === 'function') {
        success(response);
      }
    } else {
      if (typeof failure === 'function') {
        failure(response);
      }
    }
  } else {
    if (typeof failure === 'function') {
      failure(response);
    }
  }
};

/**
 * This method combines the given options with the base options used to create
 * this layer before making a call to the underlying DriveTimePolygonServiceService. The response
 * is taken from the DriveTimePolygonServiceService call and handed off to {@link alk.source.DriveTimePolygon#processResponse}
 * before being given to the 'success' callback given here.
 * @param {alkx.DriveTimePolygonServiceOptions=} opt_options
 * @param {function((alkx.DriveTimePolygonServiceResponse|undefined)=)=} success
 * @param {function((alkx.DriveTimePolygonServiceResponse|undefined)=)=} failure
 * @fires {'change:driveTimePolygons'}  Fires the 'change:driveTimePolygons' event when done processing the response.
 * @this {alk.source.DriveTimePolygon}
 * @api
 */
alk.source.DriveTimePolygon.prototype.addDriveTimePolygon = function (opt_options, success, failure) {
  var options = opt_options !== undefined ? opt_options : {};

  var self = this;
  this.set('updating', true);
  this.getDriveTimePolygonService().get(options, function (response) {
    self.set('updating', false);
    if (response) {
      self.handleDriveTimePolygonServiceResponse(response, success, failure);
    } else {
      if (typeof failure === 'function') {
        failure(response);
      }
    }
  });
};
goog.provide('alk.style.StyleQueue');

goog.require('alk.style');
/**
 * @classdesc
 * An instance of this class holds a rotating queue of styles;
 * @description
 * This constructor creates a Style Queue of fills, and corresponding
 * strokes and of a set width. If the width is set by means of {@link alk.style.StyleQueue#setWidth}
 * all strokes contained within will have their width property updated to the specified value.
 * If styles is defined, the colors option is ignored. If the colors option is set, it generates
 * a list of styles with a fill and a stroke with those colors at 0.5 and 0.9 opacity, respectively.
 * If width is set, it sets the width of all strokes.
 * The default width is 3 (pixels).
 * @constructor
 * @param {{styles: (Array.<ol.style.Style>|undefined),
 *          colors: (Array.<string>|undefined),
 *          width: (number|undefined)}=} opt_options
 * @extends {ol.Object}
 * @api
 */
alk.style.StyleQueue = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  var width = options.width || 3;

  this.currentIndex = 0;
  alk.style.StyleQueue.base(this, 'constructor');
  if (options.styles !== undefined) {
    this.styles = options.styles.map(function(z){return z;});
  } else if (options.colors !== undefined) {
    var styles = [];
    if (options.colors instanceof Array) {
      options.colors.forEach(function (color) {
        var ca = ol.color.asArray(color);
        var fc = [ca[0],ca[1],ca[2],0.5];
        var sc = [ca[0],ca[1],ca[2],0.9];
        styles.push(
          new ol.style.Style({
            fill: new ol.style.Fill({color: fc}),
            stroke: new ol.style.Stroke({color: sc, width: width})
          })
        );
      });
      this.styles = styles;
    }
  }
  this.on('change:width', this.updateWidth_);
  this.set('width', width);
};
goog.inherits(alk.style.StyleQueue, ol.Object);

/**
 * @returns {number}
 * @this {alk.style.StyleQueue}
 * @api
 */
alk.style.StyleQueue.prototype.getWidth = function () {
  return /** @type {number} */ (this.get('width'));
};

/**
 * @param {number} width
 * @this {alk.style.StyleQueue}
 * @api
 */
alk.style.StyleQueue.prototype.setWidth = function (width) {
  this.set('width', width);
};

/**
 * @private
 * @this {alk.style.StyleQueue}
 */
alk.style.StyleQueue.prototype.updateWidth_ = function () {
  var width = /** @type{number} */(this.get('width'));
  this.styles.forEach(function (style) {
    style.getStroke().setWidth(width);
  });
};

/**
 * @type {Array.<ol.style.Style>}
 * @api
 */
// This assignment is a pass through function application because the closure
// compiler gives the following error on a direct assignment:
//   ERROR - Prototype property styles should be a primitive, not an Array or Object.
alk.style.StyleQueue.prototype.styles = function () {
  return [
    new ol.style.Style({
      //123ec4
      fill: new ol.style.Fill({color: 'rgba(018,062,196,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(018,062,196,0.5)', width: 3})
    }),
    new ol.style.Style({
      //b84a00
      fill: new ol.style.Fill({color: 'rgba(184,074,000,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(184,074,000,0.5)', width: 3})
    }),
    new ol.style.Style({
      //7318a1
      fill: new ol.style.Fill({color: 'rgba(115,024,161,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(115,024,161,0.5)', width: 3})
    }),
    new ol.style.Style({
      //1e6ca8
      fill: new ol.style.Fill({color: 'rgba(031,109,168,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(031,109,168,0.5)', width: 3})
    }),
    new ol.style.Style({
      //b50.59
      fill: new ol.style.Fill({color: 'rgba(181,0.5,0.2,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(181,0.5,0.2,0.5)', width: 3})
    }),
    new ol.style.Style({
      //450dbd
      fill: new ol.style.Fill({color: 'rgba(0.2,013,189,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(0.2,013,189,0.5)', width: 3})
    }),
    new ol.style.Style({
      //0.2dc4
      fill: new ol.style.Fill({color: 'rgba(000,157,196,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(000,157,196,0.5)', width: 3})
    }),
    new ol.style.Style({
      //e63d00
      fill: new ol.style.Fill({color: 'rgba(230,061,000,0.2)'}),
      stroke: new ol.style.Stroke({color: 'rgba(230,061,000,0.5)', width: 3})
    })
  ];
}();

/**
 * @returns {ol.style.Style}
 * @this {alk.style.StyleQueue}
 * @api
 */
alk.style.StyleQueue.prototype.next = function() {
  return this.styles[this.currentIndex++ % this.styles.length];
};
goog.provide('alk.style.UpdatingLayerStyle');

goog.require('alk.style');

/**
 * @classdesc
 * An instance of this class creates a styling function for a layer that notifies the
 * user when it is updating.
 * @description
 * This constructor is the base constructor to create a Style Function that works on
 * notifying the user when its connected layer is updating.
 * @constructor
 * @extends {ol.Object}
 * @abstract
 * @api
 */
alk.style.UpdatingLayerStyle = function () {
  alk.style.UpdatingLayerStyle.base(this, 'constructor');
};
goog.inherits(alk.style.UpdatingLayerStyle, ol.Object);

/**
 * @type {ol.layer.Vector}
 * @api
 */
alk.style.UpdatingLayerStyle.prototype.layer;

/**
 * This method is called by the UpdatingLayer when installed. This
 * method also registers for the 'updating' property change on the
 * layer and calls 'beginUpdate' and 'endUpdate' for the values of
 * true and false respectively.
 *
 * @param {ol.layer.Vector} layer
 * @this {alk.style.UpdatingLayerStyle}
 */
alk.style.UpdatingLayerStyle.prototype.setLayer = function (layer) {
  var self = this;
  this.set('layer', this.layer = layer);
  var source;
  if (this.layer && (source = this.layer.getSource())) {
    source.on('change:updating', function (event) {
      var source = /** @type {ol.source.Vector} */(event.target);
      var updating = /** @type {boolean} */ (source.get('updating'));
      self.setUpdating(updating);
    });
    // In case the source is changed.
    this.layer.on('change:source', function (event) {
      var source = /** @type {ol.layer.Vector} */(event.target).getSource();
      if (source) {
        source.on('change:updating', function (event) {
          var updating = /** @type {boolean} */ (source.get('updating'));
          self.setUpdating(updating);
        });
      }
    });
  }
};

/**
 * @type {boolean}
 */
alk.style.UpdatingLayerStyle.prototype.updateInProgress_;

/**
 * This function returns whether the style is in between 'beginUpdate' and
 * 'endUpdate' calls from the update capable layer.
 *
 * @returns {boolean}
 * @this {alk.style.UpdatingLayerStyle}
 */
alk.style.UpdatingLayerStyle.prototype.isUpdateInProgress = function () {
  return this.updateInProgress_;
};

/**
 * This method is called when the 'updating' property of the
 * associated vector layer's source is changed.
 *
 * @param {!boolean} value
 * @this {alk.style.UpdatingLayerStyle}
 */
alk.style.UpdatingLayerStyle.prototype.setUpdating = function (value) {
  this.updateInProgress_ = value;
  if (value) {
    if (this.layer) {
      var features = this.layer.getSource().getFeatures();
      features.forEach(function(s) {s.changed();});
    }
  }
};


/**
 * This function provides the styleFunction for the Routing Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @abstract
 * @api
 */
alk.style.UpdatingLayerStyle.prototype.styleFunction = function(feature, resolution) {};
goog.provide('alk.style.QueuedStyleLayerStyle');

goog.require('alk.style');
goog.require('alk.style.StyleQueue');
goog.require('alk.style.UpdatingLayerStyle');

/**
 * @classdesc
 * An instance of this class provides a {@link ol.style.StyleFunction}
 * that styles items based on an id.
 * @description
 * This constructor creates a Style Function that rotates styles based
 * upon a given id.
 *
 * @param {{
 *  styleQueue: (alk.style.StyleQueue|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.UpdatingLayerStyle}
 * @api
 */
alk.style.QueuedStyleLayerStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  if (options.styleQueue !== undefined) {
    this.styleQueue_ = options.styleQueue;
  }
  alk.style.QueuedStyleLayerStyle.base(this, 'constructor');
  if (this.styleQueue_ === undefined) {
    this.styleQueue_ = new alk.style.StyleQueue();
  }
  this.styleMap_ = {};
};
goog.inherits(alk.style.QueuedStyleLayerStyle, alk.style.UpdatingLayerStyle);

/**
 * @type {alk.style.StyleQueue}
 * @private
 */
alk.style.QueuedStyleLayerStyle.prototype.styleQueue_;

/**
 * This function sets the stroke style for this QueuedStyleLayerStyle.
 * @param {alk.style.StyleQueue} styleQueue
 * @this {alk.style.QueuedStyleLayerStyle}
 * @api
 */
alk.style.QueuedStyleLayerStyle.prototype.setStyleQueue = function (styleQueue) {
  this.styleQueue_ = styleQueue;
};

/**
 * This function returns the stroke Queue.
 * @returns {alk.style.StyleQueue|undefined}
 * @this {alk.style.QueuedStyleLayerStyle}
 * @api
 */
alk.style.QueuedStyleLayerStyle.prototype.getStyleQueue = function () {
  return this.styleQueue_;
};

/**
 * @type {Object.<string, Object<number, ol.style.Style>>}
 * @private
 */
alk.style.QueuedStyleLayerStyle.prototype.styleMap_;

/**
 * This function returns the color in the routeStrokeMap for the given routeId.
 * If there is no color in the map, the next one is gotten from the StyleQueue
 * and assigned.
 * @param {string} id The Id
 * @param {number} resolution
 * @return {ol.style.Style}
 * @this {alk.style.QueuedStyleLayerStyle}
 */
alk.style.QueuedStyleLayerStyle.prototype.getStyleForId = function (id, resolution) {
  var width = this.getWidthForResolution(resolution);
  var styles = this.styleMap_[id];
  if (!styles) {
    this.styleMap_[id] = {};
    this.styleMap_[id][0] = this.styleQueue_.next();
  }
  var style = this.styleMap_[id][width];
  if (!style) {
    style = this.styleMap_[id][0];
    var ns = new ol.style.Style({
      fill: style.getFill(),
      stroke: new ol.style.Stroke({
        color: style.getStroke().getColor(),
        width: width
      })
    });
    style = this.styleMap_[id][width] = ns;
  }
  return style;
};

/**
 * This function clears the assigned, if any, stroke style for the given routeId identifier.
 *
 * @param {string} id
 * @this {alk.style.QueuedStyleLayerStyle}
 * @api
 */
alk.style.QueuedStyleLayerStyle.prototype.clearStyleForId = function (id) {
  delete this.styleMap_[id];
};

/**
 * This function returns the 'update' style for the feature's id property
 * according to the default or supplied {@link alk.style.StyleQueue}. This stroke
 * will have the color at 0.4 of its original opacity.
 *
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @return {ol.style.Style}
 * @this {alk.style.QueuedStyleLayerStyle}
 */
alk.style.QueuedStyleLayerStyle.prototype.getUpdateStyle = function (feature, resolution) {
  var featureId = /** @type {string} */ (feature.getId());
  var style = this.getStyleForId(featureId, resolution);
  var color = style.getFill().getColor();
  var strokeColor = style.getStroke().getColor();
  var width = this.getWidthForResolution(resolution);
  // Clone the color array. Otherwise, it messes up the internal OL string->color array cache.
  var colora = ol.color.asArray(/** @type {ol.Color|string} */(color));
  var nc = colora.map(function(m) {return m;});
  // Opacity is set to 40% of it, or just 20%
  nc[3] = nc[3] ? nc[3] * 0.4 : 0.2;
  return new ol.style.Style({
    fill: new ol.style.Fill({color: nc}),
    stroke: new ol.style.Stroke({
      color: strokeColor,
      width: width
    })
  });
};

/**
 * This method gets the stroke style using the feature's 'routeId' property according
 * to default or supplied {@link alk.style.StyleQueue}. If a stroke has not been
 * assigned to the value of the feature's 'routeId' property, the next available from
 * the StyleQueue is taken, and that stroke is then mapped to the 'routeId'.
 *
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @return {ol.style.Style}
 * @this {alk.style.QueuedStyleLayerStyle}
 */
alk.style.QueuedStyleLayerStyle.prototype.getStyle = function (feature, resolution) {
  if (this.isUpdateInProgress()) {
    return this.getUpdateStyle(feature, resolution);
  } else {
    var id = /** @type {string} */ (feature.getId());
    return this.getStyleForId(id, resolution);
  }
};

/**
 * This function returns the stroke with to be used at the resolution.
 * It is married to the Road Surface Style, in that the road surface
 * lines will be wider than the lines used here.
 * @param {number} resolution
 * @returns {number}
 * @this {alk.style.QueuedStyleLayerStyle}
 */
alk.style.QueuedStyleLayerStyle.prototype.getWidthForResolution = function (resolution) {
  //
  if (resolution > 10000) {
    return 0.5;
  } else if (resolution > 5000) {
    return 1;
  } else if (resolution > 2500) {
    return 3;
  } else if (resolution > 1000) {
    return 2;
  } else {
    return 1;
  }
};


/**
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @override
 * @this {alk.style.QueuedStyleLayerStyle}
 * @api
 */
alk.style.QueuedStyleLayerStyle.prototype.styleFunction = function(feature, resolution) {
  var styles = [];
  var style = this.getStyle(feature, resolution);
  styles.push(style);
  return styles;
};
goog.provide('alk.style.DriveTimeLayerStyle');

goog.require('alk');
goog.require('alk.style.QueuedStyleLayerStyle');

goog.require('alkx.DriveTimeLayerStyleOptions');

/**
 * @classdesc
 * An object of this class provides a style function to style the
 * Drive Time Polygons of the {@link alk.layer.DriveTimeLayer}.
 * @description
 * This constructor creates a Style function with which to style
 * the {@alk.layer.DriveTimeLayer}.
 *
 * @param {alkx.DriveTimeLayerStyleOptions=} opt_options
 * @constructor
 * @extends {alk.style.QueuedStyleLayerStyle}
 * @api
 */
alk.style.DriveTimeLayerStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  var opts = {
    styleQueue: options.styleQueue
  };
  alk.style.DriveTimeLayerStyle.base(this, 'constructor', opts);
};
goog.inherits(alk.style.DriveTimeLayerStyle, alk.style.QueuedStyleLayerStyle);
goog.provide('alk.layer.DriveTimeLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.source.DriveTimePolygon');
goog.require('alk.style.DriveTimeLayerStyle');
goog.require('alk.style.StyleQueue');

goog.require('alkx.DriveTimeLayerOptions');
goog.require('alkx.DriveTimePolygonServiceResponse');

/**
 * @classdesc
 * An instance of this class is a layer that displays the drive time polygons from a
 * {@link alk.source.DriveTimePolygon} source.
 *
 * @description
 * This constructor creates a layer that displays the drive time polygons.
 *
 * If no 'source' is provided in the options, then a new {@link alk.source.DriveTimePolygon} source
 * is created with a new {@link alk.service.DriveTimePolygonService} service created with
 * the provided 'driveTimePolygonServiceOptions' in the options.
 *
 * All visual representation is handled by the
 * 'style' option. As a default, the {@link alk.style.QueuedStyleLayerStyle} is used, which
 * round robins between its styles for each polygon added to the layer.
 *
 * @example
 * var map = ol.Map({
 *   layers: [
 *     new alk.layer.BaseMapLayer(),
 *     new alk.layer.DriveTimeLayer()
 *   ]);
 *
 * @param {alkx.DriveTimeLayerOptions=} opt_options
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.DriveTimeLayer = function (opt_options) {
  /** @type {alkx.DriveTimeLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var source = options.source;

  if (source === undefined) {
    var driveTimePolygonServiceOptions = options.driveTimePolygonServiceOptions;
    source = new alk.source.DriveTimePolygon({
      driveTimePolygonServiceOptions: driveTimePolygonServiceOptions
    });
  }

  var style = this.processStyle(options.style);

  var opts = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting,
    zIndex: options.zIndex
  };

  alk.layer.DriveTimeLayer.base(this, 'constructor', opts);
  if (this.driveTimeLayerStyle) {
    this.driveTimeLayerStyle.setLayer(this);
  }
};
goog.inherits(alk.layer.DriveTimeLayer, ol.layer.Vector);

/**
 * @inheritDoc
 * @this {alk.layer.DriveTimeLayer}
 */
alk.layer.DriveTimeLayer.prototype.setStyle = function (style) {
  var nStyle = this.processStyle(style);
  alk.layer.DriveTimeLayer.base(this, 'setStyle', nStyle);
  if (this.driveTimeLayerStyle) {
    this.driveTimeLayerStyle.setLayer(this);
  }
};

/**
 * This method calls directly to the associated source's {@link alk.source.MultiRoute#addRoute} method.
 *
 * @param {{
 *  driveTimePolygonServiceOptions: (alkx.DriveTimePolygonServiceOptions)
 * }=} opt_options
 * @param {function(alkx.DriveTimePolygonServiceResponse=)=} success
 * @param {function(alkx.DriveTimePolygonServiceResponse=)=} failure
 * @this {alk.layer.DriveTimeLayer}
 * @api
 */
alk.layer.DriveTimeLayer.prototype.addDriveTimePolygon = function (opt_options, success, failure) {
  this.getSource().addDriveTimePolygon(opt_options, success, failure);
};



/**
 * This function assigns or creates the DriveTimeLayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.DriveTimeLayerStyle|alk.style.StyleQueue|Array.<ol.style.Style>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.DriveTimeLayer}
 * @protected
 */
alk.layer.DriveTimeLayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.DriveTimeLayerStyle) {
      self.driveTimeLayerStyle = optStyle;
      style = function (feature, resolution) {
        return self.driveTimeLayerStyle.styleFunction(feature, resolution);
      };
    } else if (optStyle instanceof alk.style.StyleQueue) {
      self.driveTimeLayerStyle = new alk.style.DriveTimeLayerStyle({
        styleQueue: /** @type {alk.style.StyleQueue} */(optStyle)
      });
      style = function (feature, resolution) {
        return self.driveTimeLayerStyle.styleFunction(feature, resolution);
      };
    } else if (optStyle instanceof Array && optStyle.length > 0 && optStyle[0] instanceof ol.style.Style) {
      var styleQueue = new alk.style.StyleQueue({
        styles: /** @type {Array.<ol.style.Style>} */(optStyle)
      });
      self.driveTimeLayerStyle = new alk.style.DriveTimeLayerStyle({
        styleQueue: styleQueue
      });
      style = function (feature, resolution) {
        return self.driveTimeLayerStyle.styleFunction(feature, resolution);
      };
    } else {
        // We just go with the supplied style.
        style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
    }
  } else {
    if (this.driveTimeLayerStyle === undefined) {
      this.driveTimeLayerStyle = new alk.style.DriveTimeLayerStyle();
    }
    style = function (feature, resolution) {
      return self.driveTimeLayerStyle.styleFunction(feature, resolution);
    };
  }
  return style;
};
goog.provide('alk.val.StopType');

/**
 * @enum {string}
 * @api
 */
alk.val.StopType = {
  /** @api */
  Origin: 'O',
  /** @api */
  WayPoint: 'W',
  /** @api */
  Destination: 'D',
  /** @api */
  ViaPoint: 'V'
};
goog.provide('pcmws.api.RouteService');

goog.require('pcmws.api');
goog.require('pcmws.api.AfSetIds');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.AvoidFavors');
goog.require('pcmws.api.AvoidTolls');
goog.require('pcmws.api.Axles');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DistanceUnits');
goog.require('pcmws.api.ElevationLimit');
goog.require('pcmws.api.EstimatedTimeOpts');
goog.require('pcmws.api.FerryDiscourage');
goog.require('pcmws.api.GovernorSpeedLimit');
goog.require('pcmws.api.HazMat');
goog.require('pcmws.api.HighwayOnly');
goog.require('pcmws.api.HosEnabled');
goog.require('pcmws.api.HosRemCycleDutyTime');
goog.require('pcmws.api.HosRemDriveTime');
goog.require('pcmws.api.HosRemDriveTimeUntilBreak');
goog.require('pcmws.api.HosRemOnDutyTime');
goog.require('pcmws.api.HubRouting');
goog.require('pcmws.api.LCV');
goog.require('pcmws.api.OpenBorders');
goog.require('pcmws.api.OverrideClass');
goog.require('pcmws.api.OverrideRestrict');
goog.require('pcmws.api.ReduceResponsePoints');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.RouteOptimization');
goog.require('pcmws.api.RouteServiceOptions');
goog.require('pcmws.api.RouteType');
goog.require('pcmws.api.RouteURL');
goog.require('pcmws.api.SideOfStreetAdherence');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Stops');
goog.require('pcmws.api.StopsAsViaPoints');
goog.require('pcmws.api.TruckConfig');
goog.require('pcmws.api.VehicleDimensionUnits');
goog.require('pcmws.api.VehicleHeight');
goog.require('pcmws.api.VehicleLength');
goog.require('pcmws.api.VehicleType');
goog.require('pcmws.api.VehicleWeight');
goog.require('pcmws.api.VehicleWidth');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.RouteServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.RouteService = function (opt_options) {
  var specs = [
    ['afSetIds', pcmws.api.AfSetIds],
    ['authToken', pcmws.api.AuthToken],
    ['avoidFavors', pcmws.api.AvoidFavors],
    ['avoidTolls', pcmws.api.AvoidTolls],
    ['axles', pcmws.api.Axles],
    ['dataset', pcmws.api.Dataset],
    ['distanceUnits', pcmws.api.DistanceUnits],
    ['elevationLimit', pcmws.api.ElevationLimit],
    ['estimatedTimeOpts', pcmws.api.EstimatedTimeOpts],
    ['ferryDiscourage', pcmws.api.FerryDiscourage],
    ['governorSpeedLimit', pcmws.api.GovernorSpeedLimit],
    ['hazMat', pcmws.api.HazMat],
    ['highwayOnly', pcmws.api.HighwayOnly],
    ['hosEnabled', pcmws.api.HosEnabled],
    ['hosRemCycleDutyTime', pcmws.api.HosRemCycleDutyTime],
    ['hosRemDriveTime', pcmws.api.HosRemDriveTime],
    ['hosRemDriveTimeUntilBreak', pcmws.api.HosRemDriveTimeUntilBreak],
    ['hosRemOnDutyTime', pcmws.api.HosRemOnDutyTime],
    ['hubRouting', pcmws.api.HubRouting],
    ['lcv', pcmws.api.LCV],
    ['openBorders', pcmws.api.OpenBorders],
    ['overrideClass', pcmws.api.OverrideClass],
    ['overrideRestrict', pcmws.api.OverrideRestrict],
    ['reduceResponsePoints', pcmws.api.ReduceResponsePoints],
    ['region', pcmws.api.Region],
    ['routeOptimization', pcmws.api.RouteOptimization],
    ['routeType', pcmws.api.RouteType],
    ['sideOfStreetAdherence', pcmws.api.SideOfStreetAdherence],
    ['srs', pcmws.api.SRS],
    ['stops', pcmws.api.Stops],
    ['stopsAsViaPoints', pcmws.api.StopsAsViaPoints],
    ['truckConfig', pcmws.api.TruckConfig],
    ['vehicleDimensionUnits', pcmws.api.VehicleDimensionUnits],
    ['vehicleHeight', pcmws.api.VehicleHeight],
    ['vehicleLength', pcmws.api.VehicleLength],
    ['vehicleType', pcmws.api.VehicleType],
    ['vehicleWeight', pcmws.api.VehicleWeight],
    ['vehicleWidth', pcmws.api.VehicleWidth]
  ];
  pcmws.api.RouteService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.RouteServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.RouteURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.RouteService, pcmws.api.StaticService);

/**
 * This method returns a clone of this RouteService object.
 * @override
 * @this {pcmws.api.RouteService}
 * @returns {pcmws.api.RouteService}
 *
 */
pcmws.api.RouteService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.RouteServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.RouteService(opts);
};
goog.provide('alk.service.RouteService');

goog.require('alk.val');
goog.require('alk.val.StopType');
goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.RouteService');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Route Service.
 * @description
 * This constructor creates a Service object to the ALK Routing engine.
 *
 * @param {alkx.RouteServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.RouteService = function (opt_options) {
  alk.service.RouteService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.routeService = this.pcmws = new pcmws.api.RouteService(this.pcmServiceOptions);
};
goog.inherits(alk.service.RouteService, alk.service.Service);

/**
 * @description
 * The ALK Route Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.RouteService} object.
 *
 * @type {pcmws.api.RouteService}
 */
alk.service.RouteService.prototype.routeService;


/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from Route Service returns a GeoJSON object
 * containing a single MultiLineString defining the route between stops in the sequence
 * presented in the 'stops' option in the call.
 *
 * This method adds GeoJSON features representing the given stops and their given stop types.
 * Each stop is returned with the following properties:
 * -   stopIndex:  (number) The index into the given stops option.
 * -   stopType:   ({@link alk.val.StopType}) The stopType of the stop as given in the stopTypes option.
 * -   logicalStopIndex:  (number) The logical index, which means the sequence index not counting Via Points.
 * -   hubRouting: (boolean|number|string|undefined),
 * -   stopsAsViaPoints (boolean) True if the stopsAsViaPoints option was set to true.
 *
 * If a StopType were not specified for the first stop, the first stop is given the 'stopType' attribute
 * of {@link alk.val.StopType.Origin}.
 *
 * If a StopType was not specified for the last stop, and 'hubRouting' options was not set to true, then the
 * last stop is given the 'stopType' attribute of {@link alk.val.StopType.Destination}.
 *
 * If a StopType was not specified for a particular stop, and the 'stopsAsViaPoints' option was set to true,
 * the first stop is given the 'stopType' attribute of {@link alk.val.StopType.Origin}, the last stop is given
 * the 'stopType' attribute of {@link alk.val.StopType.Destination}, and all others are given a 'stopType'
 * attribute of {@link alk.val.StopType.ViaPoint}.
 *
 * StopTypes in the 'stopTypes' option override all the above, and if set for a particular stop, the given
 * type is assigned to the 'stopType' attribute of that stop feature.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.RouteService}.
 * @param {Object} obj The GeoJSON response from the {@link alk.service.RouteService}.
 * @returns {alkx.RouteServiceResponse} Containing the routeServiceOptions and if a successful call
 *  also contains a FeatureCollection containing the stops and the route as a MultiLineString.
 * @override
 * @api
 */
alk.service.RouteService.prototype.processResponse = function (options, obj) {
  // We are going to add the stops an their types and index.
  var stops = options.stops || [];
  var stopTypes = options.stopTypes || [];
  var hubRouting = options.hubRouting;
  var stopsAsViaPoints = options.stopsAsViaPoints;
  var features = [];
  // There should always be two stops!
  for(var i = 0; i < stops.length; i++) {
    var stopType = stopTypes[i];
    if (stopType === undefined) {
      if (i === 0) {
        stopType = alk.val.StopType.Origin;
      } else if (i === stops.length - 1) {
        if (!hubRouting) {
          stopType = alk.val.StopType.Destination;
        }
      } else {
        if (stopsAsViaPoints) {
          stopType = alk.val.StopType.ViaPoint;
        }
      }
    }
    var stop = stops[i];
    var feature = {
      'type' : 'Feature',
      'geometry' : {
        'type' : 'Point',
        'coordinates' : [stop[0], stop[1]]
      },
      'properties' : {
        'stop' : [stop[0], stop[1]],
        'stopIndex' : i,
        'stopsAsViaPoints' : stopsAsViaPoints,
        'hubRouting' : hubRouting,
        'stopType' : stopType
      }
    };
    features.push(feature);
  }
  features.push({
    'type' : 'Feature',
    'geometry' : obj['geometry']
  });

  var result = {
    'type' : 'FeatureCollection',
    'features' : features
  };
  return {
    routeServiceOptions: options,
    geoJSON: result,
    distance: obj['TDistance'],
    minutes: obj['TMinutes']
  };
};

/**
 * @description
 * This method performs a call to the Route Service to return a route.
 * @param {(alkx.RouteServiceOptions|null|function(alkx.RouteServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.RouteServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.RouteService}
 * @api
 */
alk.service.RouteService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.RouteServiceOptions} */
  var options = {};
  /** function(alkx.RouteServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.RouteServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.RouteService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.source.Route');

goog.require('alk.source');
goog.require('alk.service.RouteService');

goog.require('alkx.RouteSourceOptions');

/**
 * @classdesc
 * An instance of this class provides a vector source that may lookup a route between two or more
 * stops and add features to this source.
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 * @fires {'change:route'} This event is fired when after the request to the
 *                         {@link alk.service.RouteService} is processed.
 *
 * @description
 * This constructor creates a Vector Source object that retrieves routes from the ALK Routing Engine.
 *
 * If the 'hubRouting' option is 'true', then
 * the first stop is considered the 'hub' and the last stop is represented as a numbered circle in
 * the ordered chain of stops.
 *
 * A Stop is represented as a {@link ol.Feature} with a {@link ol.geom.Point} geometry.
 * The segment between Stops is represented by a {@link ol.Feature} with a {@link ol.geom.LineString}
 * geometry. The segments are tagged with a 'segmentIndex' property with the ordinal index, i.e. first
 * is zero.
 *
 * All stops are {@link ol.Feature} tagged with the 'stop' attribute, which contains
 * the original coordinates given to the {@link alk.source.Route#setRoute} function. All stops
 * are tagged with a "stopIndex" attribute indicating the ordinal index in the given stop list, i.e.
 * start stop is '0'. Stops are also tagged with a 'stopType' attribute, designating
 * {@link alk.val.StopType.Origin} for the first (start) stop,
 * {@link alk.val.StopType.Destination} for the last stop.
 * If the 'hubRouting' option is true, all features, including lines are tagged with the 'hubRouting' attribute,
 * and the last stop does not carry the 'Destination' type, unless overridden by the 'stopTypes' option
 * in the call. All stops are tagged with a 'logicalStopIndex' attribute
 * which labels the stop in its ordinal position in the stops list, while ignoring stops with the 'stopType'
 * of {@link alk.val.StopType.ViaPoint}.
 *
 * @param {alkx.RouteSourceOptions=} opt_options
 *
 * @constructor
 * @extends {ol.source.Vector}
 * @api
 */
alk.source.Route = function (opt_options) {
  /** @type {alkx.RouteSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.routeService_ = new alk.service.RouteService(options.routeServiceOptions);

  this.baseOptions_ = {
    routeServiceOptions: options.routeServiceOptions
  };

  var opts = {
    wrapX: options.wrapX
  };
  alk.source.Route.base(this, 'constructor', opts);
};
goog.inherits(alk.source.Route, ol.source.Vector);

/**
 * @type {alk.service.RouteService}
 * @private
 */
alk.source.Route.prototype.routeService_;

/**
 * @returns {alk.service.RouteService}
 * @this {alk.source.Route}
 * @api
 */
alk.source.Route.prototype.getRouteService = function () {
  return this.routeService_;
};

/**
 * @param {alk.service.RouteService} service
 * @this {alk.source.Route}
 * @api
 */
alk.source.Route.prototype.setRouteService = function (service) {
  this.routeService_ = service;
};

/**
 * This attribute contains the options with which the Route source was created.
 * @type {Object.<string,*>}
 * @private
 */
alk.source.Route.prototype.baseOptions_;


/**
 * This method processes clones the RouteServiceOptions including a deep copy of the
 * 'stops' and 'stopTypes' properties.
 *
 * @param {alkx.RouteServiceOptions} options The RouteServiceOptions to clone.
 * @returns {alkx.RouteServiceOptions} The cloned object.
 * @api
 */
alk.source.Route.prototype.cloneRouteServiceOptions = function (options) {
  var stops = options.stops.map(function (a) { return [a[0],a[1]]; });
  var stopTypes;
  if (options.stopTypes) {
    if (options.stopTypes instanceof Array) {
      stopTypes = options.stopTypes.map(function (a) {return a;});
    } else {
      stopTypes = {};
      Object.keys(/** @type {!Object} */(options.stopTypes)).forEach(function (k) {
        stopTypes[k] = options.stopTypes[k];
      });
    }
  }
  return {
    routeType: options.routeType,
    routeOptimization: options.routeOptimization,
    vehicleDimensionUnits: options.vehicleDimensionUnits || options.trkUnits,
    vehicleHeight: options.vehicleHeight || options.trkHeight,
    vehicleWidth: options.vehicleWidth || options.trkWidth,
    vehicleWeight: options.vehicleWeight || options.trkWeight,
    axles: options.axles || options.trkAxles,
    lcv: options.lcv || options.trkLCV,
    avoidTolls: options.avoidTolls || options.tollDiscourage,
    overrideClass: options.overrideClass || options.classOverrides,
    hazMat: options.hazMat || options.hazMatType,
    apiKey: options.apiKey,
    stops: stops,
    stopTypes: stopTypes,
    highwayOnly: options.highwayOnly,
    avoidFavors: options.avoidFavors,
    distanceUnits: options.distanceUnits,
    openBorders: options.openBorders,
    overrideRestrict: options.overrideRestrict,
    hubRouting: options.hubRouting,
    truckConfig: options.truckConfig,
    estimatedTimeOpts: options.estimatedTimeOpts,
    stopsAsViaPoints: options.stopsAsViaPoints,
    elevationLimit: options.elevationLimit,
    afSetIds: options.afSetIds,
    ferryDiscourage: options.ferryDiscourage,
    hosEnabled: options.hosEnabled,
    hosRemDriveTimeUntilBreak: options.hosRemDriveTimeUntilBreak,
    hosRemDriveTime: options.hosRemDriveTime,
    hosRemOnDutyTime: options.hosRemOnDutyTime,
    hosRemCycleDutyTime: options.hosRemCycleDutyTime,
    sideOfStreetAdherence: options.sideOfStreetAdherence,
    governorSpeedLimit: options.governorSpeedLimit
  };
};


/**
 * This method processes the response from the RouteService before it is handled by the
 * Route Source. The default behavior is to pass it through.
 *
 * @param {alkx.RouteServiceResponse} response The response from the RouteService.
 * @returns {Object} The response complete with options.
 * @protected
 * @this {alk.source.Route}
 */
alk.source.Route.prototype.processResponse = function (response) {
  // The service responds with the original routeServiceOptions, so we should be safe
  // and clone it here.
  var routeServiceOptions = this.cloneRouteServiceOptions(response.routeServiceOptions);
  return {
    routeServiceOptions: routeServiceOptions,
    geoJSON: response.geoJSON,
    distance: response.distance,
    minutes: response.minutes
  };
};

/**
 * This function extracts the LineString features from the (any,all) MultiLineString features.
 * @param {Array.<ol.Feature>} features
 * @returns {Array.<ol.Feature>} An array of Feature with the LineString geometry and a 'segmentIndex'
 *                               property corresponding to the segment in the MultiLineString.
 * @protected
 */
alk.source.Route.prototype.flattenMultiLineFeatures = function (features) {
  var lineStringFeatures = [];
  var lineSegmentIndex = 0;
  features.forEach(function (feature) {
    var type = feature.getGeometry().getType();
    if (type === 'LineString') {
      // We don't really get these, but put it here just in case.
      feature.set('segmentIndex', lineSegmentIndex++);
      lineStringFeatures.push(feature);
    } else if (type === 'MultiLineString') {
      var lines = feature.getGeometry().getCoordinates();
      lines.forEach(function (line) {
        var feature = new ol.Feature({
          geometry: new ol.geom.LineString(line)
        });
        feature.set('segmentIndex', lineSegmentIndex++);
        lineStringFeatures.push(feature);
      });
    } else {
      // Ignore
    }
  });
  return lineStringFeatures;
};

/**
 * @param {Array.<ol.Feature>} features The list of features that contains 'stop' tagged features.
 * @returns {Array.<ol.Feature>} A list of features that contain the 'stop' tag. Also, assigns
 *                               the appropriate 'logicalStopIndex' attribute to stops.
 * @protected
 */
alk.source.Route.prototype.collectStopFeatures = function (features) {
  var logicalIndex = 0;
  var stopFeatures = features.filter(function (feature) {
    return feature.get('stop') !== undefined;
  });
  // The stops should be ordered already, but just to make sure since
  // it is not defined in OL.
  function stopOrder(stop1, stop2) {
    var s1 = /** @type {number} */ (stop1.get('stopIndex'));
    var s2 = /** @type {number} */ (stop2.get('stopIndex'));
    return (s1 < s2) ? -1 : (s1 === s2) ? 0 : 1;
  }
  stopFeatures = stopFeatures.sort(stopOrder);
  stopFeatures.forEach(function (feature) {
    switch (feature.get('stopType')) {
      case alk.val.StopType.ViaPoint:
        // Ignore via points.
        break;
      // Number everything else
      case alk.val.StopType.Origin:
      case alk.val.StopType.Destination:
      case alk.val.StopType.WayPoint:
      default:
        feature.set('logicalStopIndex', logicalIndex++);
    }
  });
  return stopFeatures;
};



/**
 * This method joins the stops to the line features by altering their geometries, in adding
 * equal coordinates on the ends of the line strings.
 * @param {boolean} hubRouting
 * @param {Array.<ol.Feature>} stopFeatures
 * @param {Array.<ol.Feature>} lineFeatures
 */
alk.source.Route.prototype.connectFeatures = function (hubRouting, stopFeatures, lineFeatures) {
  // There should always be one more stopFeature than lineFeatures
  if (lineFeatures.length + 1 !== stopFeatures.length) {
    console.warn("Bad response, number of lines not 1 less than stops");
    return;
  }
  for(var i = 0; i < lineFeatures.length; i++) {
    // There should always be one more stopFeature than lineFeatures
    var stop1C = (hubRouting ? stopFeatures[0] : stopFeatures[i]).getGeometry().getCoordinates();
    var lineCs = lineFeatures[i].getGeometry().getCoordinates();
    var first = lineCs[0];
    if (stop1C[0] !== first[0] || stop1C[0] !== first[1]) {
      lineCs.splice(0,0,[stop1C[0], stop1C[1]]);
    }
    var stop2C = stopFeatures[i+1].getGeometry().getCoordinates();
    var last = lineCs[lineCs.length - 1];
    if (stop2C[0] !== last[0] || stop2C[0] !== last[1]) {
      lineCs.push([stop2C[0], stop2C[1]]);
    }
    lineFeatures[i].getGeometry().setCoordinates(lineCs);
  }
};
goog.provide('alk.source.SingleRoute');

goog.require('alk');
goog.require('alk.source.Route');
goog.require('alk.val.SRS');


goog.require('alkx.RouteSourceOptions');
goog.require('alkx.RouteServiceResponse');


/**
 * @classdesc
 * An instance of this class accesses the ALK Routing Engine.
 * @fires {'change:route'}  Fires the 'change:route' event when done processing the response.
 * @fires {'change:request'}  Fires the 'change:request' event when done processing the response.
 *
 * @description
 * This constructor creates a Source object that retrieves a
 * Single Route from the ALK Routing Engine.
 *
 * @param {alkx.RouteSourceOptions=} opt_options
 * @constructor
 * @extends {alk.source.Route}
 * @api
 */
alk.source.SingleRoute = function (opt_options) {
  alk.source.SingleRoute.base(this, 'constructor', opt_options);
};
goog.inherits(alk.source.SingleRoute, alk.source.Route);

/**
 * This method combines the given options with the base options used to create
 * this layer before making a call to the underlying RouteService. The response
 * is taken from the RouteService call and handed off to {@link alk.source.SingleRoute#processResponse}
 * before being given to the 'success' callback given here.
 * @param {{
 *  routeServiceOptions: (alkx.RouteServiceOptions)
 * }=} opt_options
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} success
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} failure
 * @fires {'change:route'}  Fires the 'change:route' event when done processing the response.
 * @this {alk.source.SingleRoute}
 * @api
 */
alk.source.SingleRoute.prototype.setRoute = function (opt_options, success, failure) {
  var options = opt_options !== undefined ? opt_options : {};

  var self = this;
  var callOptions = options.routeServiceOptions;
  this.set('updating', true);
  this.getRouteService().get(callOptions, function (response) {
    self.set('updating', false);
    if (response) {
      var processedResponse = /** @type {alkx.RouteServiceResponse!} */(self.processResponse(response));
      self.handleRouteServiceResponse(processedResponse, success, failure);
    } else {
      if (typeof failure === 'function') {
        failure();
      }
    }
  });
};

/**
 * This function returns the Route Service options that were in effect when the
 * request was made to the {@link alk.service.RouteService}, and its response
 * as a GeoJSON object.
 * @returns {alkx.RouteServiceResponse}
 * @this {alk.source.SingleRoute}
 * @api
 */
alk.source.SingleRoute.prototype.getRoute = function () {
  return /** @type {alkx.RouteServiceResponse} */ (this.get('route'));
};

/**
 * @param {alkx.RouteServiceResponse} response
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} success
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} failure
 * @this {alk.source.SingleRoute}
 * @return {*}
 * @fires {'change:request'}  Fires the 'change:request' event when done processing the response.
 * @protected
 */
alk.source.SingleRoute.prototype.handleRouteServiceResponse = function (response, success, failure) {
  if (response.geoJSON !== undefined) {
    // We always work in EPSG:3857 internally.
    var allFeatures = (new ol.format.GeoJSON()).readFeatures(response.geoJSON, {
      featureProjection: alk.val.SRS.EPSG3857
    });
    if (allFeatures !== undefined) {
      var lineFeatures = this.flattenMultiLineFeatures(allFeatures);
      var stopFeatures = this.collectStopFeatures(allFeatures);

      // The first coordinate of the first segment is almost guaranteed to have the
      // same coordinates as the origin. However, not so much the last. We should
      // connect the line strings by their coordinates at the stops, which will
      // lead the modifiers to pick up the stop and its connected line features.
      var hubRouting = !!response.routeServiceOptions.hubRouting;
      this.connectFeatures(hubRouting, stopFeatures, lineFeatures);

      // Now lets add them to the layer.
      this.addRouteFeatures_(response.routeServiceOptions, lineFeatures, stopFeatures);

      // Notify everybody.
      // If you are wondering why we clone the response object here, it is because
      // we always want the change:route to fire regardless if response is the same.
      // Case is in EditTrail. This call will get the same response object at the base of the
      // edit trail (i.e. multiple undo, or resetEditTrail). That will not fire as a 'change'.
      this.set('route', {
        routeServiceOptions: response.routeServiceOptions,
        geoJSON: response.geoJSON,
        distance: response.distance,
        minutes: response.minutes
      });
      if (typeof success === 'function') {
        return success(/** @type {alkx.RouteServiceResponse} */(this.get('route')));
      }
    }
  } else {
    this.set('route', {
      routeServiceOptions: response.routeServiceOptions
    });
    if (typeof failure === 'function') {
      return failure(/** @type {alkx.RouteServiceResponse} */(this.get('route')));
    }
  }
};

/**
 * This method just adds the Route to the layer's source. We keep track of the options, lines, and stops
 * in feature form.
 * @param {alkx.RouteServiceOptions} routeServiceOptions
 * @param {Array.<ol.Feature>} lineFeatures
 * @param {Array.<ol.Feature>} stopFeatures
 * @this {alk.source.SingleRoute}
 * @private
 */
alk.source.SingleRoute.prototype.addRouteFeatures_ = function (routeServiceOptions, lineFeatures, stopFeatures) {
  this.removeRouteFeatures_();
  this.routeServiceOptions_ = routeServiceOptions;
  this.lineFeatures_ = lineFeatures;
  this.stopFeatures_ = stopFeatures;
  var self = this;
  lineFeatures.forEach(function (feature) {
    self.addFeature(feature);
  });
  stopFeatures.forEach(function (feature) {
    self.addFeature(feature);
  });
};

/**
 * This method returns an array of the features that are stops that resulted from
 * the last successful call to {@link alk.source.SingleRoute#setRoute}.
 * @returns {Array.<ol.Feature> | undefined} The stop features.
 * @api
 */
alk.source.SingleRoute.prototype.getStopFeatures = function () {
  return this.stopFeatures_;
};

/**
 * This method returns an array of the features that are the segments between
 * stops that resulted from the last successful call to {@link alk.source.SingleRoute#setRoute}.
 * @returns {Array.<ol.Feature>|undefined} The line segment features.
 * @this {alk.source.SingleRoute}
 * @api
 */
alk.source.SingleRoute.prototype.getLineFeatures = function () {
  return this.lineFeatures_;
};

/**
 * This method returns the routeServiceOptions that were used to make the last
 * successful call to {@link alk.source.SingleRoute#setRoute}.
 * @returns {alkx.RouteServiceOptions|undefined}
 * @this {alk.source.SingleRoute}
 * @api
 */
alk.source.SingleRoute.prototype.getRouteServiceOptions = function () {
  return this.routeServiceOptions_;
};

/**
 * This method removes the route from the layer, removing all stop
 * and line segment features from the layer's source, which results in their
 * visual removal from the layer.
 * @this {alk.source.SingleRoute}
 * @api
 */
alk.source.SingleRoute.prototype.removeRoute = function () {
  delete this.routeServiceOptions_;
  this.unset('route');
  this.removeRouteFeatures_();
};

/**
 *
 * @private
 * @this {alk.source.SingleRoute}
 */
alk.source.SingleRoute.prototype.removeRouteFeatures_ = function () {
  this.removeFeatures_(this.lineFeatures_);
  delete this.lineFeatures_;
  this.removeFeatures_(this.stopFeatures_);
  delete this.stopFeatures_;
};

/**
 * This method removes the given features from the layer's source.
 * @param {Array.<ol.Feature>|undefined} features
 * @this {alk.source.SingleRoute}
 * @private
 */
alk.source.SingleRoute.prototype.removeFeatures_ = function (features) {
  if (features !== undefined) {
    var self = this;
    features.forEach(function (feature) {
      self.removeFeature(feature);
    });
  }
};
goog.provide('alk.layer.RoutingLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.source.SingleRoute');
goog.require('alk.style.RoutingLayerStyle');
goog.require('alk.style.StopsRouteStyle');
goog.require('alk.style.StrokeQueue');

goog.require('alkx.RoutingLayerOptions');

/**
 * @classdesc
 * An instance of this class provides a display layer for a {@link alk.source.Route} source, in which
 * depending its type will display routes according to the associated style. If no source is supplied,
 * the default is the {@link alk.source.SingleRoute} source with the given routeServiceOptions option,
 * if supplied.
 *
 * This class may be sub-classed to provide for different functionality. For instance, there are
 * {@link alk.layer.SingleRoutingLayer}, {@link alk.layer.MultiRoutingLayer}, and
 * {@link alk.layer.EditTrailRoutingLayer}, all which set up different default sources appropriate
 * for their functionality, {@link alk.source.SingleRoute}, {@link alk.source.MultiRoute}, and
 * {@link alk.source.EditTrailRoute}, respectively.
 *
 * @description
 * This constructor creates the base layer for a Routing Layer to retrieve routing information
 * from ALK Routing server and displaying the route in a map according to a style.
 *
 * If no 'source' is provided in the options, then a new {@link alk.source.SingleRoute} source
 * is created with a new {@link alk.service.RouteService} service created with
 * the provided 'routeServiceOptions' in the options.
 *
 * All visual representation is handled by the 'style' option.
 * As a default, the {@link alk.style.StopsRouteStyle} is used, which
 * draws stops as cardinally numbered circles, save for the first and last stop, which are drawn with
 * non-numbered circles, green and red, respectively. The numbered circles retain the color of the
 * route line.
 *
 * If the 'hubRouting' option is 'true', then
 * the first stop is considered the 'hub' and the last stop is represented as a numbered circle in
 * the ordered chain of stops.
 *
 * Should you need a specific styling, please see {@link alk.style.RoutingLayerStyle}
 * as a base object to implement from, and other classes such as {@link alk.style.LineRouteStyle}, etc.
 * The {@link alk.style.StopsRouteStyle} has some options governing width of the line. If you need
 * specific styling, look to the '*RouteStyle' objects in {@link alk.style}.
 *
 * A Stop is represented as a {@link ol.Feature} with a {@link ol.geom.Point} geometry.
 * The segment between Stops is represented by a {@link ol.Feature} with a {@link ol.geom.LineString}
 * geometry. The segments are tagged with a 'segmentIndex' property with the ordinal index, i.e. first
 * is zero.
 *
 * All stops are {@link ol.Feature} tagged with the 'stop' attribute, which contains
 * the original coordinates given to the {@link alk.layer.RoutingLayer#setRoute} function. All stops
 * are tagged with a "stopIndex" attribute indicating the ordinal index in the given stop list, i.e.
 * start stop is '0'. Stops are also tagged with a 'stopType' attribute, designating {@link alk.val.StopType.Origin}
 * for the first (start) stop, {@link alk.val.StopType.Destination} for the last stop.
 * If the 'hubRouting' option is true, all features, including lines are tagged with the 'hubRouting' attribute,
 * and the last stop does not carry the 'Destination' type, unless overridden by the 'stopTypes' option
 * in the call. All stops are tagged with a 'logicalStopIndex' attribute
 * which labels the stop in its ordinal position in the stops list, while ignoring stops with the 'stopType'
 * of {@link alk.val.StopType.ViaPoint}.
 *
 * @param {alkx.RoutingLayerOptions=} opt_options
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.RoutingLayer = function (opt_options) {
  /** @type {alkx.RoutingLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var style = this.processStyle(options.style);

  this.baseOptions_ = {
    routeServiceOptions: options.routeServiceOptions
  };

  var source = options.source;
  if (source === undefined) {
    source = new alk.source.SingleRoute({
      routeServiceOptions: options.routeServiceOptions
    });
  }

  // We save these on the object so we can have them for changeStyle.
  this.layerOptions_ = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting,
    zIndex: options.zIndex
  };
  alk.layer.RoutingLayer.base(this, 'constructor', this.layerOptions_);


  this.routingLayerStyle.setLayer(this);
};
goog.inherits(alk.layer.RoutingLayer, ol.layer.Vector);

/**
 * This attribute contains the RoutingLayerStyle that was either assigned
 * or created for this RoutingLayer.
 * @type {alk.style.RoutingLayerStyle}
 * @private
 */
alk.layer.RoutingLayer.prototype.routingLayerStyle;

/**
 * This function returns the RoutingLayerStyle that was either assigned or
 * created for this RoutingLayer.
 * @returns {alk.style.RoutingLayerStyle|undefined}
 * @this {alk.layer.RoutingLayer}
 * @api
 */
alk.layer.RoutingLayer.prototype.getRoutingLayerStyle = function () {
  return this.routingLayerStyle;
};

/**
 * This function assigns or creates the RoutingLayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.RoutingLayerStyle|alk.style.StrokeQueue|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.RoutingLayer}
 * @protected
 */
alk.layer.RoutingLayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.RoutingLayerStyle) {
      self.routingLayerStyle = optStyle;
      style = function (feature, resolution) {
        return self.routingLayerStyle.styleFunction(feature, resolution);
      };
    } else {
      var strokeQueue;
      if (optStyle instanceof alk.style.StrokeQueue) {
        strokeQueue = /** @type {alk.style.StrokeQueue} */ (optStyle.style);
      } else if (optStyle instanceof ol.style.Stroke) {
        var stroke = /** @type {ol.style.Stroke} */ (optStyle);
        strokeQueue = new alk.style.StrokeQueue({strokes: [stroke]});
      } else if (typeof optStyle === 'string') {
        var color = /** @type {string} */ (optStyle);
        strokeQueue = new alk.style.StrokeQueue({colors: [color]});
      } else if (optStyle instanceof Array) {
        var array = /** @type {Array.<*>} */ (optStyle);
        if (array.length > 0 && array[0] instanceof ol.style.Stroke) {
          strokeQueue = new alk.style.StrokeQueue({
            strokes: /** @type {Array.<ol.style.Stroke>} */(array)
          });
        }
      }
      if (strokeQueue !== undefined) {
        this.routingLayerStyle = new alk.style.StopsRouteStyle({
          strokeQueue: strokeQueue
        });
        style = function (feature, resolution) {
          return self.routingLayerStyle.styleFunction(feature, resolution);
        };
      } else {
        // We just go with the supplied style.
        style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
      }
    }
  } else {
    if (this.routingLayerStyle === undefined) {
      this.routingLayerStyle = new alk.style.StopsRouteStyle();
    }
    style = function (feature, resolution) {
      return self.routingLayerStyle.styleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function sets the Style for this layer.
 * @override
 * @param {alk.style.RoutingLayerStyle|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @this {alk.layer.RoutingLayer}
 * @api
 */
alk.layer.RoutingLayer.prototype.setStyle = function (optStyle) {
  var style = this.processStyle(optStyle);
  alk.layer.RoutingLayer.base(this, 'setStyle', style);
};
goog.provide('alk.layer.SingleRoutingLayer');

goog.require('alk.layer.RoutingLayer');
goog.require('alk.source.Route');

goog.require('alkx.RoutingLayerOptions');
goog.require('alkx.RouteServiceResponse');

/**
 * @classdesc
 * An instance of this class is a layer that displays the route from a
 * {@link alk.source.SingleRoute} source.
 *
 * @description
 * This constructor creates a routing layer that handles and displays a single route
 * on the map.
 *
 * If no 'source' is provided in the options, then a new {@link alk.source.SingleRoute} source
 * is created with a new {@link alk.service.RouteService} service created with
 * the provided 'routeServiceOptions' in the options.
 *
 * This class has 'convenience' methods to manipulate the source.
 * See {@link alk.source.SingleRoute} for details.
 *
 * @param {alkx.RoutingLayerOptions=} opt_options
 * @constructor
 * @extends {alk.layer.RoutingLayer}
 * @api
 */
alk.layer.SingleRoutingLayer = function (opt_options) {
  alk.layer.SingleRoutingLayer.base(this, 'constructor', opt_options);
};
goog.inherits(alk.layer.SingleRoutingLayer, alk.layer.RoutingLayer);

/**
 * This method calls directly to the associated source's {@link alk.source.SingleRoute#setRoute} method.
 *
 * @param {{
 *  routeServiceOptions: (alkx.RouteServiceOptions)
 * }=} opt_options
 * @param {function((alk.layer.RoutingLayer|undefined), (alkx.RouteServiceResponse|undefined))=} success
 * @param {function((alk.layer.RoutingLayer|undefined), (alkx.RouteServiceResponse|undefined))=} failure
 * @this {alk.layer.SingleRoutingLayer}
 * @api
 */
alk.layer.SingleRoutingLayer.prototype.setRoute = function (opt_options, success, failure) {

  var self = this;

  /**
   * @param {alk.source.Route} source
   * @param {alkx.RouteServiceResponse|undefined} response
   */
  function pass(source, response) {
    success(self, response);
  }

  /**
   * @param {alk.source.Route} source
   * @param {alkx.RouteServiceResponse|undefined} response
   */
  function fail(source, response) {
    failure(self, response);
  }

  this.getSource().setRoute(opt_options,
      typeof success === 'function' ? pass : undefined,
      typeof failure === 'function' ? fail : undefined);
};

/**
 * This method directly calls the {@link alk.source.SingleRoute#getRoute} method.
 * @returns {alkx.RouteServiceResponse}
 * @this {alk.layer.SingleRoutingLayer}
 * @api
 */
alk.layer.SingleRoutingLayer.prototype.getRoute = function () {
  return this.getSource().getRoute();
};
goog.provide('alk.source.RouteSourceEditTrail');

goog.require('alk.source');

goog.require('alkx.RouteServiceResponse');

/**
 * @constructor
 */
alk.source.RouteSourceEditTrail = function() {
  this.reset();
};

/**
 * @type {Array.<alkx.RouteServiceResponse>}
 * @private
 */
alk.source.RouteSourceEditTrail.prototype.historyStack_;

/**
 * @type {Array.<alkx.RouteServiceResponse>}
 * @private
 */
alk.source.RouteSourceEditTrail.prototype.futureStack_;

/**
 * @returns {Array.<alkx.RouteServiceResponse>}
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.getHistory = function () {
  return this.historyStack_;
};

/**
 * @returns {Array.<alkx.RouteServiceResponse>}
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.getFuture = function () {
  return this.futureStack_;
};

/**
 * @returns {boolean}
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.hasHistory = function () {
  return this.historyStack_.length > 0;
};

/**
 * @returns {boolean}
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.hasFuture = function () {
  return this.futureStack_.length > 0;
};

/**
 * This method resets the edit trail to the beginning, keeping the
 * first one in the history, if it exists.
 * @return {alkx.RouteServiceResponse|undefined};
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.reset = function () {
  var first;
  if (this.historyStack_ && this.historyStack_.length > 0) {
    first = this.historyStack_[0];
  }
  this.historyStack_ = [];
  this.futureStack_ = [];
  if (first !== undefined) {
    this.historyStack_.push(first);
    return first;
  }
};

/**
 * @param {!alkx.RouteServiceResponse} routeServiceResponse
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.push = function (routeServiceResponse) {
  if (routeServiceResponse) {
    this.historyStack_.push(routeServiceResponse);
    this.futureStack_ = [];
  }
};

/**
 * This method takes the last off the history and puts it on the future.
 * If there is no more than one on the history, it is returned, but not
 * put on the future.
 * @returns {alkx.RouteServiceResponse|undefined}
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.prev = function () {
  var future;
  if (this.historyStack_) {
    if (this.historyStack_.length > 1) {
      future = this.historyStack_.pop();
    }
    if (future !== undefined) {
      this.futureStack_.push(future);
    }
    return this.peek();
  }
};

/**
 * @returns {alkx.RouteServiceResponse|undefined}
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.next = function () {
  if (this.futureStack_.length > 0) {
    var future = this.futureStack_.pop();
    this.historyStack_.push(future);
    return future;
  }
};

/**
 * @returns {alkx.RouteServiceResponse|undefined}
 * @this {alk.source.RouteSourceEditTrail}
 */
alk.source.RouteSourceEditTrail.prototype.peek = function () {
  if (this.historyStack_.length > 0) {
    return this.historyStack_[this.historyStack_.length - 1];
  }
};
goog.provide('alk.source.EditTrailRoute');

goog.require('alk.source.SingleRoute');
goog.require('alk.source.RouteSourceEditTrail');

goog.require('alkx.RouteSourceOptions');
goog.require('alkx.RouteServiceOptions');
goog.require('alkx.RouteServiceResponse');

/**
 * @classdesc
 * An instance of this class is a {@link alk.layer.SingleRoutingLayer}
 * with an edit trail that can move backward (prev), record (push), and next.
 *
 * @fires {'change:route'}  Fires the 'change:route' event when done processing the response.
 *
 * @description
 * This constructor creates a Source object that combines the functionality
 * of the ALK Routing engine with being able to edit the route and revert
 * to previous routes.
 * @param {alkx.RouteSourceOptions=} opt_options
 * @constructor
 * @extends {alk.source.SingleRoute}
 * @api
 */
alk.source.EditTrailRoute = function (opt_options) {
  alk.source.EditTrailRoute.base(this, 'constructor', opt_options);
  this.editTrail_ = new alk.source.RouteSourceEditTrail();
};
goog.inherits(alk.source.EditTrailRoute, alk.source.SingleRoute);

/**
 * @type {alk.source.RouteSourceEditTrail}
 */
alk.source.EditTrailRoute.prototype.editTrail_;

/**
 * This method combines the given options with the routeServiceOptions used to create
 * this layer before making a call to the underlying RouteService. The response
 * is taken from the RouteService call and handed off to {@link alk.layer.SingleRoutingLayer#processResponse}
 * before being given to the 'success' callback given here.
 * @param {{
 *  routeServiceOptions: (alkx.RouteServiceOptions)
 * }=} opt_options
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} success
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} failure
 * @fires {'change:route'}  Fires the 'change:route' event when done processing the response.
 * @this {alk.source.EditTrailRoute}
 * @api
 */
alk.source.EditTrailRoute.prototype.pushRoute = function (opt_options, success, failure) {
  this.setRoute(opt_options, success, failure);
};

/**
 * This method slides back into the history one position, while placing
 * the current route on the future queue.
 * @fires {changed:route} Fires the 'change:route' event if there is route in the history queue.
 * @this {alk.source.EditTrailRoute}
 * @api
 */
alk.source.EditTrailRoute.prototype.prevRoute = function () {
  this.set('updating', true);
  var response = this.editTrail_.prev();
  if (response) {
    this.handleRouteServiceResponse(response);
  }
  this.set('updating', false);
};

/**
 * This method slides next to the future and places that route there
 * if it exists.
 * @fires {changed:route} Fires the 'change:route' event if there is indeed a route in the future queue.
 * @this {alk.source.EditTrailRoute}
 * @api
 */
alk.source.EditTrailRoute.prototype.nextRoute = function () {
  this.set('updating', true);
  var response = this.editTrail_.next();
  if (response) {
    this.handleRouteServiceResponse(response);
  }
  this.set('updating', false);
};

/**
 * This method resets the edit trail and removes the route from the layer.
 * @fires {changed:route} Fires the 'change:route' event.
 * @this {alk.source.EditTrailRoute}
 * @api
 */
alk.source.EditTrailRoute.prototype.resetEditTrail = function () {
  this.set('updating', true);
  var first = this.editTrail_.reset();
  if (first) {
    this.handleRouteServiceResponse(first);
  } else {
    this.removeRoute();
  }
  this.set('updating', false);
};

/**
 * This method combines the given options with the routeServiceOptions used to create
 * this layer before making a call to the underlying RouteService. The response
 * is taken from the RouteService call and handed off to {@link alk.layer.SingleRoutingLayer#processResponse}
 * before being given to the 'success' callback given here.
 * @param {{
 *  routeServiceOptions: (alkx.RouteServiceOptions)
 * }=} opt_options
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} success
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} failure
 * @fires {'change:route'}  Fires the 'change:route' event when done processing the response.
 * @override
 * @this {alk.source.EditTrailRoute}
 * @api
 */
alk.source.EditTrailRoute.prototype.setRoute = function (opt_options, success, failure) {
  var self = this;
  /**
   * @param {alkx.RouteServiceResponse=} response
   */
  function ourSuccess(response) {
    if (response) {
      self.editTrail_.push(response);
    }
    if (typeof success === 'function') {
      success(response);
    }
  }

  /**
   * @param {alkx.RouteServiceResponse=} response
   */
  function ourFailure(response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  }

  alk.source.EditTrailRoute.base(this, 'setRoute', opt_options, ourSuccess, ourFailure);
};

/**
 * This method returns the routeServiceOptions that were used to make the last
 * successful call to {@link alk.layer.SingleRoutingLayer#setRoute}.
 * @returns {alkx.RouteServiceOptions|undefined}
 * @override
 * @this {alk.source.EditTrailRoute}
 * @api
 */
alk.source.EditTrailRoute.prototype.getRouteServiceOptions = function () {
  var response = this.editTrail_.peek();
  if (response) {
    return response.routeServiceOptions;
  }
};
goog.provide('alk.layer.EditTrailRoutingLayer');

goog.require('alk.layer.SingleRoutingLayer');
goog.require('alk.source.EditTrailRoute');

goog.require('alkx.RoutingLayerOptions');

/**
 * @classdesc
 * An instance of this class is a {@link alk.layer.SingleRoutingLayer}
 * with an edit trail that can move backward (prev), record (push), and next.
 *
 * @fires {'change:route'}  Fires the 'change:route' event when done processing the response.
 *
 * @description
 * This constructor cretes a layer for the using the Single Routing Layer with an
 * edit trail.
 *
 * If no 'source' is provided in the options, then a new {@link alk.source.EditTrailRoute} source
 * is created with a new {@link alk.service.RouteService} service created with
 * the provided 'routeServiceOptions' in the options.
 *
 * @example
 * var map = new ol.Map({
 *   layers: [ new alk.layer.BaseMapLayer() ]
 *   });
 * var routingLayer = new alk.layer.EditTrailRoutingLayer();
 * map.addLayer(routingLayer);
 * var routeOptions1 = {
 *    stops: [
 *      [-76.11735, 43.03343],
 *      [-75.1747547, 39.9673709],
 *      [-74.721516, 40.074719],
 *      [-74.6027002, 40.3611409]
 *    ],
 *    hubRouting: false,
 *    stopTypes: {0: alk.val.StopType.Origin,
 *                1: alk.val.StopType.WayPoint,
 *                2: alk.val.StopType.ViaPoint,
 *                3: alk.val.StopType.Destination }
 *  };
 * routingLayer.pushRoute(routeOptions1);
 *
 * @param {alkx.RoutingLayerOptions=} opt_options
 * @constructor
 * @extends {alk.layer.SingleRoutingLayer}
 * @api
 */
alk.layer.EditTrailRoutingLayer = function (opt_options) {
  /** @type {alkx.RoutingLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var source = options.source;

  if (source === undefined) {
    var routeServiceOptions = options.routeServiceOptions;
    source = new alk.source.EditTrailRoute({
      routeServiceOptions: routeServiceOptions
    });
  }

  var opts = {
    style: options.style,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting
  };

  alk.layer.EditTrailRoutingLayer.base(this, 'constructor', opts);
};
goog.inherits(alk.layer.EditTrailRoutingLayer, alk.layer.SingleRoutingLayer);

/**
 * This method calls directly to the associated source's {@link alk.source.EditTrailRoute#pushRoute} method.
 * @param {{
 *  routeServiceOptions: (alkx.RouteServiceOptions)
 * }=} opt_options
 * @param {function((alk.layer.RoutingLayer|undefined), (alkx.RouteServiceResponse|undefined))=} success
 * @param {function((alk.layer.RoutingLayer|undefined), (alkx.RouteServiceResponse|undefined))=} failure
 * @fires {'change:route'}  Fires the 'change:route' event when done processing the response.
 * @this {alk.layer.EditTrailRoutingLayer}
 * @api
 */
alk.layer.EditTrailRoutingLayer.prototype.pushRoute = function (opt_options, success, failure) {
  this.setRoute(opt_options, success, failure);
};

/**
 * This method calls directly to the associated source's {@link alk.source.EditTrailRoute#prevRoute} method.
 * @this {alk.layer.EditTrailRoutingLayer}
 * @api
 */
alk.layer.EditTrailRoutingLayer.prototype.prevRoute = function () {
  this.getSource().prevRoute();
};

/**
 * This method calls directly to the associated source's {@link alk.source.EditTrailRoute#nextRoute} method.
 * @this {alk.layer.EditTrailRoutingLayer}
 * @api
 */
alk.layer.EditTrailRoutingLayer.prototype.nextRoute = function () {
  this.getSource().nextRoute();
};

/**
 * This method calls directly to the associated source's {@link alk.source.EditTrailRoute#resetEditTrail} method.
 * @this {alk.layer.EditTrailRoutingLayer}
 * @api
 */
alk.layer.EditTrailRoutingLayer.prototype.resetEditTrail = function () {
  this.getSource().resetEditTrail();
};
goog.provide('alk.layer.MapLayer');

goog.require('alk.layer');
goog.require('alk.layer.BaseMapLayer');

goog.require('alkx.MapLayerOptions');

/**
 * @classdesc
 * An instance of this class is to be used for the map (i.e. lowest)
 * layer in an {@link ol.Map}. This layer gets provides base map
 * layers to ALK raster map tiles.
 *
 * @description
 * This constructor creates an Openlayers compatible {@link ol.Layer} for an
 * {ol.Map} that provides ALK raster map tiles specific to the supplied
 * ALK style option.
 *
 * Along with the <b>style</b>, <b>region</b>, <b>dataset</b>, and <b>apiKey</b>
 * options, which pertain to the particular ALK service {@link alk.service.MapTileService},
 * this constructor also takes options pertaining to OpenLayers ol.Layer, i.e.
 * {@link alkx.BaseMapLayerOptions}.
 *
 * @example
 * var map = new ol.Map();
 * var mapLayer = new alk.layer.MapLayer({
 *   style: alk.val.Style.Satellite,
 *   region: alk.val.Region.NA,
 *   dataset: alk.val.Dataset.NA,
 *   opacity: 0.8
 * })
 * map.addLayer(mapLayer);
 *
 * @param {alkx.MapLayerOptions=} opt_options
 * @extends {ol.layer.Group}
 * @constructor
 * @api
 */
alk.layer.MapLayer = function(opt_options) {
  /** @type {alkx.MapLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  // These options are the serviceOptions that take precedence over
  // options.sourceOptions.serviceOptions.
  var svcOptions = {
    apiKey: options.apiKey,
    style: options.style,
    region: options.region,
    dataset: options.dataset
  };

  // We assume for sub layers, that opacity is full and visible is on.
  var layerOptions = {
    sourceOptions: options.sourceOptions,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError
  };

  var layers = [];
  if (typeof options.style === "string") {
    switch(options.style.toLowerCase()) {
      case "default":
      case "classic":
      case "roadatlas":
          console.warn("The style '" + options.style + "' is deprecated. Please use the style alk.val.Style.Transportation.");
          svcOptions.style = alk.val.Style.Transportation;
          layers.push(this.getLayer(this.getOther(svcOptions), layerOptions));
          break;
      case "monchrome":
      case "lightness":
      case "smooth":
          console.warn("The style '" + options.style + "' is deprecated. Please use the style alk.val.Style.DataLight.");
          svcOptions.style = alk.val.Style.DataLight;
          layers.push(this.getLayer(this.getOther(svcOptions), layerOptions));
          break;
      case "contemporary":
      case "night":
          console.warn("The style '" + options.style + "' is deprecated. Please use the style alk.val.Style.DataDark.");
          svcOptions.style = alk.val.Style.DataDark;
          layers.push(this.getLayer(this.getOther(svcOptions), layerOptions));
          break;
      case alk.val.Style.Satellite.toLowerCase():
        layers.push(this.getLayer(this.getSatelliteBackground(svcOptions), layerOptions));
        layers.push(this.getLayer(this.getSatelliteForeground(svcOptions), layerOptions));
        break;
      default:
        layers.push(this.getLayer(this.getOther(svcOptions), layerOptions));
        break;
    }
  } else {
    console.warn("The style '" + options.style + "' is unknown. alk.val.Style.Transportation will be used.");
    svcOptions.style = alk.val.Style.Transportation;
    layers.push(this.getLayer(this.getOther(svcOptions), layerOptions));
  }

  alk.layer.MapLayer.base(this, 'constructor',  {
    opacity: options.opacity,
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    layers: layers
  });
};
goog.inherits(alk.layer.MapLayer, ol.layer.Group);


/**
 *
 * @param {alkx.ServiceOptions=} serviceOptions
 * @returns {alkx.ServiceOptions|undefined}
 */
alk.layer.MapLayer.prototype.getSatelliteBackground = function(serviceOptions) {
  return this.mergeOptions({
    style: alk.val.Style.Satellite,
    imgOption: alk.val.ImgOption.Background
  }, serviceOptions);
};

/**
 *
 * @param {alkx.ServiceOptions=} serviceOptions
 * @returns {alkx.ServiceOptions|undefined}
 */
alk.layer.MapLayer.prototype.getSatelliteForeground = function(serviceOptions) {
  return this.mergeOptions({
    style: alk.val.Style.Satellite,
    imgOption: alk.val.ImgOption.Foreground
  }, serviceOptions);
};
/**
 *
 * @param {alkx.ServiceOptions=} serviceOptions
 * @returns {alkx.ServiceOptions|undefined}
 */
alk.layer.MapLayer.prototype.getTerrainBackground = function(serviceOptions) {
  return this.mergeOptions({
    style: alk.val.Style.Terrain,
    imgOption: alk.val.ImgOption.Background
  }, serviceOptions);
};

/**
 *
 * @param {alkx.ServiceOptions=} serviceOptions
 * @returns {alkx.ServiceOptions|undefined}
 */
alk.layer.MapLayer.prototype.getTerrainForeground = function(serviceOptions) {
  return this.mergeOptions({
    style: alk.val.Style.Terrain,
    imgOption: alk.val.ImgOption.Foreground
  }, serviceOptions);
};

/**
 *
 * @param {alkx.ServiceOptions=} serviceOptions
 * @returns {alkx.ServiceOptions|undefined}
 */
alk.layer.MapLayer.prototype.getOther = function(serviceOptions) {
  return this.mergeOptions({}, serviceOptions);
};
/**
 * If both are undefined, the function "returns" undefined.
 *
 * @param {alkx.ServiceOptions|undefined} higher
 * @param {alkx.ServiceOptions|undefined} lower
 * @returns {alkx.ServiceOptions|undefined}
 */
alk.layer.MapLayer.prototype.mergeOptions = function (higher, lower) {
  if (higher !== undefined || lower !== undefined) {
    var low = lower || {};
    var high = higher || {};
    var result = {};
    Object.keys(low).forEach(function(k) {
      if (low.hasOwnProperty(k)) {
        if (low[k] !== undefined) {
          result[k] = low[k];
        }
      }
    });
    // Possible Overrides
    Object.keys(high).forEach(function(k) {
      if (high.hasOwnProperty(k)) {
        if (high[k] !== undefined) {
          result[k] = high[k];
        }
      }
    });
    return result;
  } else {
    return undefined;
  }
};

/**
 *
 * @param {alkx.ServiceOptions=} serviceOptions
 * @param {alkx.BaseMapLayerOptions=} layerOptions
 * @returns {alk.layer.BaseMapLayer}
 */
alk.layer.MapLayer.prototype.getLayer = function(serviceOptions, layerOptions) {
  var layerOpts = this.mergeOptions({
    sourceOptions: this.mergeOptions( {
      serviceOptions: this.mergeOptions(serviceOptions,
        (layerOptions.sourceOptions || {}).serviceOptions)
    }, layerOptions.sourceOptions)
  }, layerOptions);
  return new alk.layer.BaseMapLayer(layerOpts);
};
goog.provide('alk.source.MultiRoute');

goog.require('alk');
goog.require('alk.source');
goog.require('alk.source.Route');
goog.require('alk.val.SRS');

goog.require('alkx.RouteSourceOptions');
goog.require('alkx.RouteServiceResponse');

/**
 * @classdesc
 * An instance of this class provides a source that may lookup routes between two or more
 * stops.
 *
 * @fires {change:route} This event is fired when the route is changed.
 * @fires {change:addRoute} This event is fired when a route is added.
 * @fires {change:removeRoute} This event is fired when a route is removed.
 *
 * @description
 * This constructor creates a Source object that accesses the ALK Routing engine and the
 * capability to handle multiple routes.
 *
 * If the 'hubRouting' option is 'true', then
 * the first stop is considered the 'hub' and the last stop is represented as a numbered circle in
 * the ordered chain of stops.
 *
 * A Stop is represented as a generic {@link ol.Feature} with a {@link ol.geom.Point} geometry.
 * The route between Stops is represented by a @{link ol.Feature} with a {@link ol.geom.LineString} or
 * {@link ol.geom.MultiLineString} geometry. All features that belong to a particular route get
 * tagged with the 'routeId' attribute. All stops are tagged with the 'stop' attribute, which contains
 * the original coordinates given to the {@link alk.source.MultiRoute#addRoute} function. All stops
 * are also tagged with a "stopIndex" attribute indicating the ordinal index in the given stop list, i.e.
 * start stop is '0'. Stops are also tagged with a 'stopType' attribute, designating {@link alk.val.StopType.Origin}
 * for the first (start) stop, {@link alk.val.StopType.Destination} for the last stop, and
 * //TODO: what are the other stops designated as?
 * If the 'hubRouting' option is true, all features, including lines are tagged with the 'hubRouting' attribute,
 * and the last stop does not carry the 'Destination' type.
 *
 * @param {alkx.RouteSourceOptions=} opt_options
 * @constructor
 * @extends {alk.source.Route}
 * @api
 */
alk.source.MultiRoute = function (opt_options) {
  alk.source.MultiRoute.base(this, 'constructor', opt_options);

  this.lineFeaturesMap_ = {};
  this.stopFeaturesMap_ = {};
  this.routeServiceOptionsMap_ = {};
  this.routeServiceResponseMap_ = {};
};
goog.inherits(alk.source.MultiRoute, alk.source.Route);

/**
 * @type {!Object.<string,Array.<ol.Feature>>}
 * @private
 */
alk.source.MultiRoute.prototype.lineFeaturesMap_;

/**
 * @type {!Object.<string,Array.<ol.Feature>>}
 * @private
 */
alk.source.MultiRoute.prototype.stopFeaturesMap_;

/**
 * @type {!Object.<string,alkx.RouteServiceOptions>}
 * @private
 */
alk.source.MultiRoute.prototype.routeServiceOptionsMap_;

/**
 * @type {!Object.<string, alkx.RouteServiceResponse>}
 * @private
 */
alk.source.MultiRoute.prototype.routeServiceResponseMap_;

/**
 * This function returns the response structure that includes the request options
 * and the GeoJSON response from the ALK Route Service.
 *
 * @param {string} routeId
 * @returns {alkx.RouteServiceResponse|undefined}
 * @this {alk.source.MultiRoute}
 * @api
 */
alk.source.MultiRoute.prototype.getRouteServiceResponse = function (routeId) {
  return this.routeServiceResponseMap_[routeId];
};

/**
 *
 * @param {{
 *  routeId: (string),
 *  routeServiceOptions: (alkx.RouteServiceOptions),
 *  routeReportOptions: (Object|undefined)
 * }=} opt_options
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} success
 * @param {function((alkx.RouteServiceResponse|undefined)=)=} failure
 * @this {alk.source.MultiRoute}
 * @api
 */
alk.source.MultiRoute.prototype.addRoute = function (opt_options, success, failure) {
  var options = opt_options !== undefined ? opt_options : {};

  if (options.routeId !== undefined) {
    var routeId = options.routeId;
    var self = this;
    var callOptions = options.routeServiceOptions;
    this.set('updating', true);
    this.getRouteService().get(callOptions, function (response) {
      self.set('updating', false);
      if (response) {
        var processedResponse = /** @type {alkx.RouteServiceResponse!} */(self.processResponse(response));
        self.handleRouteServiceResponse(routeId, processedResponse, success, failure);
      }  else {
        if (typeof failure === 'function') {
          failure();
        }
      }
    });
  }
};

/**
 * @param {string} routeId
 * @param {alkx.RouteServiceResponse} response
 * @param {function((alkx.RouteServiceResponse|undefined))=} success
 * @param {function((alkx.RouteServiceResponse|undefined))=} failure
 * @this {alk.source.MultiRoute}
 * @return {*}
 * @private
 */
alk.source.MultiRoute.prototype.handleRouteServiceResponse = function (routeId, response, success, failure) {
  if (response.geoJSON !== undefined) {
    var allFeatures = (new ol.format.GeoJSON()).readFeatures(response.geoJSON, {
      featureProjection: alk.val.SRS.EPSG3857
    });
    if (allFeatures !== undefined) {
      var lineFeatures = this.flattenMultiLineFeatures(allFeatures);
      var stopFeatures = this.collectStopFeatures(allFeatures);
      // Connect the stops to the line ends.
      var hubRouting = !!response.routeServiceOptions.hubRouting;
      this.connectFeatures(hubRouting, stopFeatures, lineFeatures);

      // Add them to the layer.
      this.addRouteFeatures_(routeId, response.routeServiceOptions, lineFeatures, stopFeatures);

      // Notify everybody
      this.set('route', {
        routeId: routeId,
        routeServiceOptions: response.routeServiceOptions,
        geoJSON: response.geoJSON,
        distance: response.distance,
        minutes: response.minutes
      });
      this.set('addRoute', {
        routeId: routeId,
        routeServiceOptions: response.routeServiceOptions,
        geoJSON: response.geoJSON,
        distance: response.distance,
        minutes: response.minutes
      });
      if (typeof success === 'function') {
        return success(/** @type {alkx.RouteServiceResponse} */(this.get('route')));
      }
    }
  } else {
    this.set('route', {
      routeId: routeId,
      routeServiceOptions: response.routeServiceOptions
    });
    if (typeof failure === 'function') {
      return failure(/** @type {alkx.RouteServiceResponse} */(this.get('route')));
    }
  }
};

/**
 *
 * @param {string} routeId
 * @param {alkx.RouteServiceOptions} routeServiceOptions
 * @param {Array.<ol.Feature>} lineFeatures
 * @param {Array.<ol.Feature>} stopFeatures
 * @this {alk.source.MultiRoute}
 * @private
 */
alk.source.MultiRoute.prototype.addRouteFeatures_ = function (routeId, routeServiceOptions, lineFeatures, stopFeatures) {
  this.removeRouteFeatures_(routeId);
  this.routeServiceOptionsMap_[routeId] = routeServiceOptions;
  this.lineFeaturesMap_[routeId] = lineFeatures;
  this.stopFeaturesMap_[routeId] = stopFeatures;
  var self = this;
  lineFeatures.forEach(function (feature) {
    feature.set('routeId', routeId);
    self.addFeature(feature);
  });
  stopFeatures.forEach(function(feature) {
    feature.set('routeId', routeId);
    self.addFeature(feature);
  });
};

/**
 * @param {string} routeId
 * @returns {Array.<ol.Feature> | undefined}
 * @this {alk.source.MultiRoute}
 * @api
 */
alk.source.MultiRoute.prototype.getRouteFeatures = function (routeId) {
  return this.stopFeaturesMap_[routeId];
};

/**
 * @param {string} routeId
 * @returns {Array.<ol.Feature>|undefined}
 * @this {alk.source.MultiRoute}
 * @api
 */
alk.source.MultiRoute.prototype.getLineFeatures = function (routeId) {
  return this.lineFeaturesMap_[routeId];
};

/**
 * This function returns all the routeIds that were given to {@link alk.source.MultiRoute#addRoute}.
 *
 * @returns {Array.<string>}
 * @this {alk.source.MultiRoute}
 * @api
 */
alk.source.MultiRoute.prototype.getRouteIds = function () {
  return Object.keys(this.routeServiceOptionsMap_);
};

/**
 * @param {string} routeId
 * @returns {alkx.RouteServiceOptions|undefined}
 * @this {alk.source.MultiRoute}
 * @api
 */
alk.source.MultiRoute.prototype.getRouteServiceOptions = function (routeId) {
  return this.routeServiceOptionsMap_[routeId];
};

/**
 * @param {string} routeId
 * @this {alk.source.MultiRoute}
 * @api
 */
alk.source.MultiRoute.prototype.removeRoute = function (routeId) {
  this.removeRouteFeatures_(routeId);
  delete this.lineFeaturesMap_[routeId];
  delete this.routeServiceOptionsMap_[routeId];
  delete this.stopFeaturesMap_[routeId];
  delete this.routeServiceResponseMap_[routeId];
  this.set('removeRoute', {
    routeId: routeId
  });
};

/**
 *
 * @param {string} routeId
 * @this {alk.source.MultiRoute}
 * @private
 */
alk.source.MultiRoute.prototype.removeRouteFeatures_ = function (routeId) {
  this.removeFeatures_(this.lineFeaturesMap_[routeId]);
  this.removeFeatures_(this.stopFeaturesMap_[routeId]);
};

/**
 * @param {Array.<ol.Feature>|undefined} features
 * @this {alk.source.MultiRoute}
 * @private
 */
alk.source.MultiRoute.prototype.removeFeatures_ = function (features) {
  if (features !== undefined) {
    var self = this;
    features.forEach(function (feature) {
      self.removeFeature(feature);
    });
  }
};
goog.provide('alk.layer.MultiRoutingLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.layer.RoutingLayer');
goog.require('alk.source.MultiRoute');

goog.require('alkx.RoutingLayerOptions');
goog.require('alkx.RouteServiceResponse');

/**
 * @classdesc
 * An instance of this class is a layer that displays the route from a
 * {@link alk.source.MultiRoute} source.
 *
 * @description
 * This constructor creates a layer that handles routing of multiple routes.
 *
 * If no 'source' is provided in the options, then a new {@link alk.source.MultiRoute} source
 * is created with a new {@link alk.service.RouteService} service created with
 * the provided 'routeServiceOptions' in the options.
 *
 * All visual representation is handled by the
 * 'style' option. As a default, the {@link alk.style.StopsRouteStyle} is used, which
 * draws stops as cardinally numbered circles, save for the first and last stop, which are drawn with
 * non-numbered circles, green and red, respectively. The numbered circles retain the color of the
 * route line.
 *
 * If the 'hubRouting' option is 'true', then
 * the first stop is considered the 'hub' and the last stop is represented as a numbered circle in
 * the ordered chain of stops.
 *
 * If there is more than one route, a round robin selection of colors
 * is used for each route, which will be selected by the associated
 * {@link alk.style.StopsRouteStyle}. Once a color has been selected for a 'routeId' it persists
 * for the life of the layer. If the route is added again, it will be updated, but retain the
 * same stroke color. If a route is removed by its 'routeId' then the color
 * associated with that routeId will be relinquished.
 *
 * Should you need specific colors, please see {@link alk.style.RoutingLayerStyle}
 * as a base object to implement from, and other classes such as {@link alk.style.LineRouteStyle}, etc.
 * The {@link alk.style.StopsRouteStyle} has some options governing width of the line. If you need
 * specific styling, look to the '*RouteStyle' objects in alk.style.
 *
 * All stops are {@link ol.Feature} tagged with the 'stop' attribute, which contains
 * the original coordinates given to the {@link alk.layer.RoutingLayer#setRoute} function. All stops
 * are tagged with a "stopIndex" attribute indicating the ordinal index in the given stop list, i.e.
 * start stop is '0'. Stops are also tagged with a 'stopType' attribute, designating {@link alk.val.StopType.Origin}
 * for the first (start) stop, {@link alk.val.StopType.Destination} for the last stop.
 * If the 'hubRouting' option is true, all features, including lines are tagged with the 'hubRouting' attribute,
 * and the last stop does not carry the 'Destination' type, unless overridden by the 'stopTypes' option
 * in the call. All stops are tagged with a 'logicalStopIndex' attribute
 * which labels the stop in its ordinal position in the stops list, while ignoring stops with the 'stopType'
 * of {@link alk.val.StopType.ViaPoint}.
 *
 * @param {alkx.RoutingLayerOptions=} opt_options
 * @constructor
 * @extends {alk.layer.RoutingLayer}
 * @api
 */
alk.layer.MultiRoutingLayer = function (opt_options) {
  /** @type {alkx.RoutingLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var source = options.source;

  if (source === undefined) {
    var routeServiceOptions = options.routeServiceOptions;
    source = new alk.source.MultiRoute({
      routeServiceOptions: routeServiceOptions
    });
  }

  var opts = {
    style: options.style,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting
  };

  alk.layer.MultiRoutingLayer.base(this, 'constructor', opts);

  var self = this;
  if (source !== undefined) {
    source.on('change:removeRoute', function (event) {
      self.handleRemoveRoute_(event);
    });
    this.on('change:source', function (event) {
      source.on('change:removeRoute', function (event) {
        self.handleRemoveRoute_(event);
      });
    });
  }
};
goog.inherits(alk.layer.MultiRoutingLayer, alk.layer.RoutingLayer);

/**
 * This method calls directly to the associated source's {@link alk.source.MultiRoute#addRoute} method.
 *
 * @param {{
 *  routeId: (string),
 *  routeServiceOptions: (alkx.RouteServiceOptions),
 *  routeReportOptions: (Object|undefined)
 * }=} opt_options
 * @param {function((alk.layer.RoutingLayer|undefined), (alkx.RouteServiceResponse|undefined))=} success
 * @param {function((alk.layer.RoutingLayer|undefined), (alkx.RouteServiceResponse|undefined))=} failure
 * @this {alk.layer.MultiRoutingLayer}
 * @api
 */
alk.layer.MultiRoutingLayer.prototype.addRoute = function (opt_options, success, failure) {
  var self = this;

  /**
   * @param {alk.source.Route} source
   * @param {alkx.RouteServiceResponse|undefined} response
   */
  function pass(source, response) {
    success(self, response);
  }

  /**
   * @param {alk.source.Route} source
   * @param {alkx.RouteServiceResponse|undefined} response
   */
  function fail(source, response) {
    failure(self, response);
  }

  this.getSource().setRoute(opt_options,
    typeof success === 'function' ? pass : undefined,
    typeof failure === 'function' ? fail : undefined);
};

/**
 * This method calls directly to the associated source's {@link alk.source.MultiRoute#removeRoute} source.
 *
 * @param {string} routeId
 * @this {alk.layer.MultiRoutingLayer}
 * @api
 */
alk.layer.MultiRoutingLayer.prototype.removeRoute = function (routeId) {
  this.getSource().removeRoute(routeId);
};

/**
 * This method handles the removeRoute event from the source. The color
 * that was associated with the routeId is relinquished.
 *
 * @param {ol.events.Event} event
 * @this {alk.layer.MultiRoutingLayer}
 * @private
 */
alk.layer.MultiRoutingLayer.prototype.handleRemoveRoute_ = function (event) {
  var obj = /** @type {{routeId: (string)}} */ (this.getSource().get('removeRoute'));
  var routeId = obj.routeId;
  var style = this.getRoutingLayerStyle();
  if (style instanceof alk.style.QueuedLineRouteStyle) {
    style.clearStrokeForRouteId(routeId);
  }
};
goog.provide('alk.style.POILayerStyle');

goog.require('alk.style');

/**
 * @classdesc
 * This is the base class that provides a styling function for the POILayer.
 * @description
 * This constructor creates a Style Function for styling the POI Layer with
 * POI Icons.
 * @constructor
 * @extends {ol.Object}
 * @abstract
 * @api
 */
alk.style.POILayerStyle = function () {
  alk.style.POILayerStyle.base(this, 'constructor');
};
goog.inherits(alk.style.POILayerStyle, ol.Object);

/**
 * @type {ol.layer.Vector}
 * @api
 */
alk.style.POILayerStyle.prototype.layer;

/**
 * This method is called by the POILayer when installed. This
 * method also registers for the 'updating' property change on the
 * layer and calls {@link alk.style.POILayerStyle#setUpdating}.
 *
 * @param {ol.layer.Vector} layer
 * @this {alk.style.POILayerStyle}
 * @api
 */
alk.style.POILayerStyle.prototype.setLayer = function (layer) {
  var self = this;
  this.set('layer', this.layer = layer);
  if (this.layer) {
    this.layer.on('change:updating', function (event) {
      var updating = /** @type {boolean} */ (self.layer.get('updating'));
      self.setUpdating(updating);
    });
  }
};

/**
 * This method is called when the 'updating' property of {@link alk.layer.POILayer} is
 * changed. This call gives the style the ability to style things differently when being updated.
 * @param {boolean} value
 * @api
 */
alk.style.POILayerStyle.prototype.setUpdating = function (value) {
};

/**
 * This function provides the styleFunction for the Routing Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @abstract
 * @api
 */
alk.style.POILayerStyle.prototype.styleFunction = function(feature, resolution) {};
goog.provide('pcmws.api.POIService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Center');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.NameFilter');
goog.require('pcmws.api.POICategories');
goog.require('pcmws.api.POIServiceOptions');
goog.require('pcmws.api.POIURL');
goog.require('pcmws.api.Radius');
goog.require('pcmws.api.RadiusUnits');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.StaticService');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.POIServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.POIService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region],
    ['radius', pcmws.api.Radius],
    ['radiusUnits', pcmws.api.RadiusUnits],
    ['poiCategories', pcmws.api.POICategories],
    ['nameFilter', pcmws.api.NameFilter],
    ['center', pcmws.api.Center]
  ];
  pcmws.api.POIService.base(this, 'constructor', specs, opt_options);
  /** @type {pcmws.api.POIServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.POIURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.POIService, pcmws.api.StaticService);

/**
 * @override
 * @returns {pcmws.api.POIService}
 * @this {pcmws.api.POIService}
 */
pcmws.api.POIService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.POIServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.POIService(opts);
};

/**
 *
 * @param {Object} obj
 * @return {Array}
 * @override
 *
 */
pcmws.api.POIService.prototype.processResponse = function (obj) {
  // Make sure the distance units and region are our literals
  var result = [];
  if (obj) {
    result = (obj instanceof Array) ? obj : [obj];
    for(var i = 0; i < result.length; i++) {
      var poi = result[i];
      if (poi.DistanceFromCenter && poi.DistanceFromCenter.DistanceUnits) {
        var val = /** @type {number|string} */(poi.DistanceFromCenter.DistanceUnits);
        poi.DistanceFromCenter.DistanceUnits = new pcmws.api.DistanceUnits(val).getCheckedValue();
      }
      if (poi.POILocation && poi.POILocation.Region) {
        var region = /** @type {number|string} */(poi.POILocation.Region);
        poi.POILocation.Region = new pcmws.api.Region(region).getCheckedValue();
      }
    }
  }
  return result;
};
goog.provide('alk.service.POIService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.POIService');

goog.require('alkx.POIServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK POI Service.
 * @description
 * This constructor creates a Service object to access the ALK POI Service.
 * @param {alkx.POIServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.POIService = function (opt_options) {
  alk.service.POIService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.poiService = this.pcmws = new pcmws.api.POIService(this.pcmServiceOptions);
};
goog.inherits(alk.service.POIService, alk.service.Service);

/**
 * @description
 * The ALK POI Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.POIService} object.
 *
 * @type {pcmws.api.POIService}
 */
alk.service.POIService.prototype.poiService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from the POI Service returns a JSON object
 * containing a Array.<pcmws.poi.POIObject>.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.POIService}.
 * @param {Object} obj The JSON response from the {@link alk.service.POIService}.
 * @returns {Object} Containing the poiServiceOptions and if a successful call
 *  also contains a JSON object containing the points of interest requested.
 * @override
 * @api
 */
alk.service.POIService.prototype.processResponse = function (options, obj) {
  return {
    poiServiceOptions: options,
    result: obj
  };
};

/**
 * @description
 * This method performs a call to the POI Service.
 * @param {(alkx.POIServiceOptions|null|function(alkx.POIServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.POIServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.POIService}
 * @api
 */
alk.service.POIService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.POIServiceOptions} */
  var options = {};
  /** function(alkx.POIServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.POIServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.POIService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.source.LoadStrategy');

goog.require('alk.source');

goog.require('alkx.LoadStrategyOptions');

/**
 * @classdesc
 * An instance of this class is made to be used with some ALK vector sources.
 * It is used to specify the extents to be loaded. It governs what should be
 * loaded if the {@link alk.source.LoadStrategy#loadStrategy} method returns
 * an array containing extents.
 *
 * @description
 * This constructor creates a Load Strategy object that governs the loaded
 * content of certain sources.
 *
 * At its base it may be used to load selectively based on min and max
 * resolution.
 *
 * @param {alkx.LoadStrategyOptions=} opt_options
 * @constructor
 * @api
 */
alk.source.LoadStrategy = function (opt_options) {
  /** @type {alkx.LoadStrategyOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.minResolution_ = options.minResolution;
  this.maxResolution_ = options.maxResolution;
};

/**
 * This property specifies the minimum resolution at which to
 * specify extents for loading. This number is meters per pixel.
 *
 * @type {number|undefined}
 * @private
 */
alk.source.LoadStrategy.prototype.minResolution_;

/**
 * This property specifies the maximum resolution at which to
 * specify extents for loading. This number is meters per pixel.
 *
 * @type {number|undefined}
 * @private
 */
alk.source.LoadStrategy.prototype.maxResolution_;

/**
 * This function returns the minimum resolution.
 * @returns {number|undefined}
 * @this {alk.source.LoadStrategy}
 * @api
 */
alk.source.LoadStrategy.prototype.getMinResolution = function () {
  return this.minResolution_;
};

/**
 * This method sets the minimum resolution.
 * @param {number} resolution
 * @this {alk.source.LoadStrategy}
 * @protected
 */
alk.source.LoadStrategy.prototype.setMinResolution = function (resolution) {
  this.minResolution_ = resolution;
};

/**
 * This function returns the maximum resolution.
 * @returns {number|undefined}
 * @this {alk.source.LoadStrategy}
 * @api
 */
alk.source.LoadStrategy.prototype.getMaxResolution = function () {
  return this.maxResolution_;
};

/**
 * This method sets the maximum resolution.
 * @param {number} resolution
 * @this {alk.source.LoadStrategy}
 * @protected
 */
alk.source.LoadStrategy.prototype.setMaxResolution = function (resolution) {
  this.maxResolution_ = resolution;
};
/**
 * This method is called by the a configured vector source to specify
 * extents to give to the vector source loader.
 *
 * This implementation returns the array containing the extent if the
 * resolution is designated between the set limits.
 *
 * @param {ol.Extent} extent
 * @param {number} resolution
 * @this {alk.source.LoadStrategy}
 * @returns {Array.<ol.Extent>}
 */
alk.source.LoadStrategy.prototype.loadStrategy = function (extent, resolution) {
  if ((this.minResolution_ === undefined || this.minResolution_ <= resolution) &&
        (this.maxResolution_ === undefined || resolution <= this.maxResolution_)) {
    return [extent];
  }
  return [];
};
goog.provide('alk.structs');

goog.require('alk');
alk.structs = {};
goog.provide('alk.structs.RBush');

goog.require('alk');
goog.require('alk.structs');
goog.require('alk.ext.rbush');

goog.require('alkx.RBushEntry');

/**
 * @fileoverview
 * @suppress {suspiciousCode, accessControls, ambiguousFunctionDecl, checkDebuggerStatement, checkRegExp, checkTypes, checkVars, const, constantProperty, deprecated, duplicate, es5Strict, fileoverviewTags, missingProperties, nonStandardJsDocs, strictModuleDepCheck, suspiciousCode, undefinedNames, undefinedVars, unknownDefines, unusedLocalVariables, uselessCode, visibility}
 */

/**
 * Wrapper around the RBush by Vladimir Agafonkin.
 *
 * @constructor
 * @param {number=} opt_maxEntries Max entries.
 * @see https://github.com/mourner/rbush
 * @struct
 * @template T
 */
alk.structs.RBush = function(opt_maxEntries) {

  /**
   * @private
   */
  this.rbush_ = alk.ext.rbush(opt_maxEntries);

  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object.<number, alkx.RBushEntry>}
   */
  this.items_ = {};

};


/**
 * Insert a value into the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.insert = function(extent, value) {
  /** @type {alkx.RBushEntry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: /** @type {T} */(value)
  };

  this.rbush_.insert(item);
  this.items_[alk.getUid(value)] = item;
};


/**
 * Bulk-insert values into the RBush.
 * @param {Array.<ol.Extent>} extents Extents.
 * @param {Array.<T>} values Values.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.load = function(extents, values) {
  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];

    /** @type {alkx.RBushEntry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this.items_[alk.getUid(value)] = item;
  }
  this.rbush_.load(items);
};


/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.remove = function(value) {
  var uid = alk.getUid(value);

  // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};


/**
 * Update the extent of a value in the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.update = function(extent, value) {
  var item = this.items_[alk.getUid(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!ol.extent.equals(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};


/**
 * Return all values in the RBush.
 * @return {Array.<T>} All.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.getAll = function() {
  var items = this.rbush_.all();
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Return all values in the given extent.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<T>} All in extent.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.getInExtent = function(extent) {
  /** @type {alkx.RBushEntry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.forEach = function(callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};


/**
 * Calls a callback function with each value in the provided extent.
 * @param {ol.Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.forEachInExtent = function(extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};


/**
 * @param {Array.<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.forEach_ = function(values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};


/**
 * @this {alk.structs.RBush}
 * @return {boolean} Is empty.
 */
alk.structs.RBush.prototype.isEmpty = function() {
  var property;
  // noinspection LoopStatementThatDoesntLoopJS
  for (property in this.items_) {
    return false;
  }
  return !property;
};


/**
 * Remove all values from the RBush.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.clear = function() {
  this.rbush_.clear();
  this.items_ = {};
};


/**
 * @param {ol.Extent=} opt_extent Extent.
 * @return {!ol.Extent} Extent.
 * @this {alk.structs.RBush}
 */
alk.structs.RBush.prototype.getExtent = function(opt_extent) {
  // FIXME add getExtent() to rbush
  var data = this.rbush_.data;
  return ol.extent.createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};
goog.provide('alk.source.SubtractionLoadStrategy');

goog.require('alk.source');
goog.require('alk.source.LoadStrategy');
goog.require('alk.structs.RBush');

goog.require('alkx.SubtractionLoadStrategyOptions');

/**
 * @classdesc
 * An instance of this class provides a loadStrategy function for
 * an ALK vector Source optioned to use it.
 * @description
 * This constructor creates a Load Strategy for a vector source that
 * is able to subtract extents.
 *
 * Given an extent it provides the extents (possibly
 * 8 of them) as a result of subtracting any extents previously
 * given.
 *
 * @param {alkx.SubtractionLoadStrategyOptions=} opt_options
 * @constructor
 * @extends {alk.source.LoadStrategy}
 * @api
 */
alk.source.SubtractionLoadStrategy = function (opt_options) {
  /** @type {alkx.SubtractionLoadStrategyOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var opts = {
    minResolution: options.minResolution,
    maxResolution: options.maxResolution
  };
  alk.source.SubtractionLoadStrategy.base(this, 'constructor', opts);
  this.loadedExtents_ = new alk.structs.RBush();
};
goog.inherits(alk.source.SubtractionLoadStrategy, alk.source.LoadStrategy);

/**
 * Experimental.
 * @type {alk.structs.RBush}
 * @private
 */
alk.source.SubtractionLoadStrategy.prototype.loadedExtents_;

/**
 * This function returns an array of extents that are the result of subtracting
 * the second extent from the first.
 *
 * @param {ol.Extent} e1 The first extent.
 * @param {ol.Extent} e2 The second extent.
 * @returns {Array.<ol.Extent>}
 */
alk.source.SubtractionLoadStrategy.prototype.subtract = function (e1, e2) {
  var b1 = ol.extent.boundingExtent([ol.extent.getTopLeft(e1), ol.extent.getTopLeft(e2)]);
  var b2 = ol.extent.boundingExtent([ol.extent.getBottomLeft(b1), ol.extent.getBottomLeft(e2)]);
  var b3 = ol.extent.boundingExtent([ol.extent.getBottomLeft(e1), ol.extent.getBottomLeft(e2)]);
  var b4 = ol.extent.boundingExtent([ol.extent.getBottomLeft(b3), ol.extent.getBottomRight(e2)]);
  var b5 = ol.extent.boundingExtent([ol.extent.getBottomRight(e1), ol.extent.getBottomRight(e2)]);
  var b6 = ol.extent.boundingExtent([ol.extent.getBottomRight(b5), ol.extent.getTopRight(e2)]);
  var b7 = ol.extent.boundingExtent([ol.extent.getTopRight(e1), ol.extent.getTopRight(e2)]);
  var b8 = ol.extent.boundingExtent([ol.extent.getTopLeft(e1), ol.extent.getTopLeft(b7)]);
  var results = [];
  if (ol.extent.containsCoordinate(e1, ol.extent.getTopLeft(e2))) {
    results.push(b1, b2, b3);
  }
  if (ol.extent.containsCoordinate(e1, ol.extent.getTopRight(e2))) {
    results.push(b8, b7,b6);
  }
  if (ol.extent.containsCoordinate(e1, ol.extent.getBottomRight(e2))) {
    results.push(b6, b5, b4);
  }
  if (ol.extent.containsCoordinate(e1, ol.extent.getBottomLeft(e2))) {
    results.push(b2, b3, b4);
  }
  function getArea(extent) {
    var area = 0;
    if (!ol.extent.isEmpty(extent)) {
      area = ol.extent.getWidth(extent) * ol.extent.getHeight(extent);
    }
    return area;
  }
  // Get rid of the duplicates and the ones with no discernible area.
  return results.filter(function(a,i,arr) {return arr.indexOf(a) === i && getArea(a) > 0;});
};

/**
 * The loading strategy. We assume that the extent presented is what we are going to load.
 * We subtract from it what we have already loaded, and we return those extents.
 *
 * @param {ol.Extent} extent
 * @param {number} resolution
 * @returns {Array.<ol.Extent>}
 * @this {alk.source.SubtractionLoadStrategy}
 * @override
 */
alk.source.SubtractionLoadStrategy.prototype.loadStrategy = function (extent, resolution) {
  // We let our super class take care of the resolution check.
  var extents = alk.source.SubtractionLoadStrategy.base(this, 'loadStrategy', extent, resolution);
  if (extents.length === 0) {
    return [];
  }
  var self = this;

  var results = [];
  // We will collect extents that are fully contained by other extents.
  var remove = [];
  var alreadyLoaded = this.loadedExtents_.forEachInExtent(extent, function (object) {
    if (ol.extent.containsExtent(object.extent, extent)) {
      // This extent is already loaded. Stop here.
      results = [];
      return true;
    } else {
      // If there is an intersection, there is a difference.
      if (ol.extent.intersects(extent, object.extent)) {
        // Get the difference.
        var rs = self.subtract(extent, object.extent);
        // Since we will be loading extent then we don't need the sub object.
        // However, if it still has a piece we still need it. It may get removed
        // later.
        if (ol.extent.containsExtent(extent, object.extent)) {
          remove.push(object.extent);
        }
        results = results.concat(rs);
      }
    }
  });
  if (alreadyLoaded) {
    // Remove any that we have collected so far.
    remove.forEach(function(r) { self.loadedExtents_.remove(r); });
    return [];
  }
  if (results.length === 0) {
    // There was no break up of the extent, so record it and return it.
    self.loadedExtents_.insert(extent, {extent: extent.slice()});
    return [extent];
  } else {
    self.loadedExtents_.insert(extent, {extent: extent.slice()});
    remove.forEach(function(r) { self.loadedExtents_.remove(r); });
    return results;
  }
};
goog.provide('alk.val.DistanceUnits');

goog.require('alk.val');
goog.require('pcmws.val.DistanceUnits');
/**
 * @description
 * This object contains the definitive values for the DistanceUnits parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.DistanceUnits = {
  /** @api */
  Miles: pcmws.val.DistanceUnits.Miles,
  /** @api */
  Kilometers: pcmws.val.DistanceUnits.Kilometers
};
goog.provide('alk.source.POISource');

goog.require('alk');
goog.require('alk.format.POIJSON');
goog.require('alk.service.POIService');
goog.require('alk.source');
goog.require('alk.source.SubtractionLoadStrategy');
goog.require('alk.val.DistanceUnits');
goog.require('alk.val.SRS');

goog.require('alkx.POISourceOptions');
goog.require('alkx.POIServiceOptions');
goog.require('alkx.POIServiceResponse');

/**
 * @classdesc
 * An instance of this class accesses the ALK Points of Interest Service.
 * @fires {'change:updating'}  Fires the 'change:updating' event when done processing the response.
 * @fires {'change:poi'}  Fires the 'change:poi' event when done processing the response.
 *
 * @description
 * This constructor creates a Source object that accesses the
 * ALK Points of Interest Service.
 *
 * @param {alkx.POISourceOptions=} opt_options
 * @constructor
 * @extends {ol.source.Vector}
 * @api
 */
alk.source.POISource = function (opt_options) {
  /** @type {alkx.POISourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  var self = this;

  var optStrategy = options.strategy;
  var strategy;
  if (optStrategy !== undefined) {
    if (optStrategy instanceof alk.source.LoadStrategy) {
      this.loadStrategy_ = optStrategy;
    } else {
      strategy = optStrategy;
    }
  } else {
    this.loadStrategy_ = new alk.source.SubtractionLoadStrategy({
      minResolution: 1,
      maxResolution: 1000
    });
  }
  if (strategy === undefined && this.loadStrategy_ !== undefined) {
    strategy =
      /**
       *
       * @param {ol.Extent} extent
       * @param {number} resolution
       * @returns {Array<ol.Extent>}
       */
      function (extent, resolution) {
      return self.loadStrategy_.loadStrategy(extent, resolution);
    };
  }
  /** @type {olx.source.VectorOptions} */
  var opts = {
    url:
      /**
       *
       * @param {ol.Extent} extent
       * @param {number} resolution
       * @param {ol.proj.Projection} projection
       * @returns {string}
       */
      function (extent, resolution, projection) {
      return self.featureLoadURLFunction(extent, resolution, projection);
    },
    strategy: strategy != null ? strategy : undefined,
    format: new alk.format.POIJSON({
      defaultProjection: alk.val.SRS.EPSG4326
    }),
    wrapX: options.wrapX
  };

  alk.source.POISource.base(this, 'constructor', opts);

  this.poiService_ = new alk.service.POIService(options.poiServiceOptions);

  this.baseOptions_ = {
    // This is a secret option for adding Features that color the radius and extents
    debugRadius: options.debugRadius,
    poiServiceOptions: options.poiServiceOptions
  };

};
goog.inherits(alk.source.POISource, ol.source.Vector);

/**
 * @type {alk.service.POIService}
 * @private
 */
alk.source.POISource.prototype.poiService_;

/**
 * @returns {alk.service.POIService}
 * @this {alk.source.POISource}
 * @api
 */
alk.source.POISource.prototype.getPOIService = function () {
  return this.poiService_;
};

/**
 * @param {alk.service.POIService} service
 * @this {alk.source.POISource}
 * @api
 */
alk.source.POISource.prototype.setPOIService = function (service) {
  this.poiService_ = service;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 * @this {alk.source.POISource}
 * @return {string}
 */
alk.source.POISource.prototype.featureLoadURLFunction = function (extent, resolution, projection) {
  var center = ol.extent.getCenter(extent);
  var height = ol.extent.getHeight(extent);
  var width = ol.extent.getWidth(extent);
  var radius =  (Math.sqrt(height*height+width*width)/2.0);
  var url = this.getPOIService().getURL({
    center: ol.proj.transform(center, alk.val.SRS.EPSG3857, alk.val.SRS.EPSG4326),
    radius: radius / 1000,
    radiusUnits: alk.val.DistanceUnits.Kilometers
  });

  if (this.baseOptions_.debugRadius) {
    // This is experimental. We style these features in order to get a handle on what the calls are covering.
    var callF = new ol.Feature(new ol.geom.Point(center));
    callF.set('radius', radius);
    var extentF = new ol.Feature(new ol.geom.Polygon([
        [ol.extent.getTopRight(extent),
          ol.extent.getBottomRight(extent),
          ol.extent.getBottomLeft(extent),
          ol.extent.getTopLeft(extent),
          ol.extent.getTopRight(extent)]
      ]
    ));
    extentF.set('extent', true);
    this.addFeature(callF);
    this.addFeature(extentF);
  }


  return url;
};

/**
 * This attribute contains the options with which the POISource was created.
 * @type {Object.<string,*>}
 * @private
 */
alk.source.POISource.prototype.baseOptions_;

/**
 * This method processes clones the POIServiceOptions including a deep copy of the
 * 'poiCategories'properties.
 *
 * @param {alkx.POIServiceOptions} options The POIServiceOptions to clone.
 * @returns {alkx.POIServiceOptions} The cloned object.
 * @api
 */
alk.source.POISource.prototype.clonePOIServiceOptions = function (options) {
  var poiCategories;
  if (options.poiCategories) {
    if (options.poiCategories instanceof Array) {
      poiCategories = options.poiCategories.map(function (a) {
        return a;
      });
    } else {
      poiCategories = options.poiCategories.split(',');
    }
  }
  return {
    apiKey: options.apiKey,
    region: options.region,
    dataset: options.dataset,
    radius: options.radius,
    radiusUnits: options.radiusUnits,
    poiCategories: poiCategories,
    nameFilter: options.nameFilter
  };
};

/**
 * This method processes the response from the POIService before it is handled by the
 * POISource. It returns the POIServiceOptions that were made to make the request
 * and the result.
 *
 * @param {alkx.POIServiceResponse} response The response from the POIService.
 * @returns {Object} The response pass through.
 * @api
 */
alk.source.POISource.prototype.processResponse = function (response) {
  // The service responds with the original routeServiceOptions, so we should be safe
  // and clone it here.
  var poiServiceOptions = this.clonePOIServiceOptions(response.poiServiceOptions);
  return {
    poiServiceOptions: poiServiceOptions,
    result: response.result
  };
};

/**
 * This method combines the given options with the base options used to create
 * this source before making a call to the underlying POIService. The response
 * is taken from the POIService call and handed off to {@link alk.source.POISource#processResponse}
 * before being given to the 'success' callback given here. The loadStrategy and wrapX options are
 * ignored here.
 * @param {alkx.POISourceOptions=} opt_options
 * @param {function((alk.source.POISource|undefined), (alkx.POIServiceResponse|undefined))=} success
 * @param {function((alk.source.POISource|undefined), (alkx.POIServiceResponse|undefined))=} failure
 * @fires {'change:updating'}  Fires the 'change:updating' event when done processing the response.
 * @this {alk.source.POISource}
 * @api
 */
alk.source.POISource.prototype.search = function (opt_options, success, failure) {
  var options = opt_options !== undefined ? opt_options : {};

  var self = this;
  var callOptions = options.poiServiceOptions;
  this.set('updating', true);
  this.getPOIService().get(callOptions, function (response) {
    self.set('updating', false);
    var processedResponse = /** @type {alkx.POIServiceResponse} */(self.processResponse(response));
    self.handlePOIServiceResponse(processedResponse, success, failure);
  });
};

/**
 * @param {alkx.POIServiceResponse} response
 * @param {function((alk.source.POISource|undefined), (alkx.POIServiceResponse|undefined))=} success
 * @param {function((alk.source.POISource|undefined), (alkx.POIServiceResponse|undefined))=} failure
 * @this {alk.source.POISource}
 * @fires {'change:poi'}  Fires the 'change:poi' event when done processing the response.
 * @protected
 */
alk.source.POISource.prototype.handlePOIServiceResponse = function (response, success, failure) {
  this.removeAllFeatures(this.poiFeatures_);
  var features = this.poiFeatures_ = [];
  var pois = response.result;
  if (pois !== undefined) {
    for (var i = 0; i < pois.length; i++) {
      var poi = /** @type {pcmws.poi.POIObject} */(pois[i]);
      if (poi.POILocation && poi.POILocation.Coords) {
        var lon = parseFloat(poi.POILocation.Coords.Lon);
        var lat = parseFloat(poi.POILocation.Coords.Lat);
        if (typeof lon === 'number' && typeof lat === 'number') {
          var geom = new ol.geom.Point([lon, lat]);
          var feature = new ol.Feature(geom);
          feature.set('poi', poi);
          features.push(feature);
          this.addFeature(feature);
        }
      }
    }
  }
};

/**
 *
 * @param {Array.<ol.Feature>} features
 * @this {alk.source.POISource}
 */
alk.source.POISource.prototype.removeAllFeatures = function (features) {
  for(var i = 0; i < features.length; i++) {
    this.removeFeature(features[i]);
  }
};
goog.provide('alk.style.POIIconFactory');

/**
 * @classdesc
 * An instance of this class creates Icons for POI Objects.
 * @description
 * This constructor creates a Factory object that creates Icons styles
 * for POI Objects based on their category.
 *
 * @param {{
 * base: (string|undefined),
 * default: (string|undefined)
 * }=} opt_options
 * @constructor
 * @api
 */
alk.style.POIIconFactory = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  this.base_ = options.base || alk.img.POI;
  this.defaultURL_ = options.default || this.base_['Other'];
};

/**
 * @type {string}
 */
alk.style.POIIconFactory.prototype.defaultURL_;

/**
 *
 * @param {string} category
 * @return {ol.style.Icon}
 * @this {alk.style.POIIconFactory}
 */
alk.style.POIIconFactory.prototype.getIconForCategory = function (category) {
  var url;
  if (category === 'Gas') {
    url = this.base_['Fuel'];
  } else if (category === 'Automotive') {
    url = this.base_['AutoRepair'];
  }

  url = url || this.base_[category] || this.defaultURL_;

  var icon = new ol.style.Icon({
    src: url
  });
  return icon;
};

goog.provide('alk.style.IconPOILayerStyle');

goog.require('alk.style.POILayerStyle');
goog.require('alk.style.POIIconFactory');

/**
 * @classdesc
 * An instance of this class provides a {@link ol.style.StyleFunction} for
 * the {@link alk.layer.POILayer} that only draws icons from a set of icons
 * organized by POI Category.
 * @description
 * This constructor creates a Style Function to style the POI Layer.
 *
 * @param {{
 *  iconFactory: (alk.style.POIIconFactory|undefined),
 *  defaultIcon: (ol.style.Icon|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.POILayerStyle}
 * @api
 */
alk.style.IconPOILayerStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  this.iconFactory_ = options.iconFactory || new alk.style.POIIconFactory();
  this.defaultIcon_ = options.defaultIcon || new ol.style.Icon({src: alk.img.POI.Other});

  alk.style.IconPOILayerStyle.base(this, 'constructor');
};
goog.inherits(alk.style.IconPOILayerStyle, alk.style.POILayerStyle);

/**
 * @type {alk.style.POIIconFactory}
 * @private
 */
alk.style.IconPOILayerStyle.prototype.iconFactory_;

/**
 * @type {ol.style.Icon}
 * @private
 */
alk.style.IconPOILayerStyle.prototype.defaultIcon_;

/**
 * @type {boolean}
 */
alk.style.IconPOILayerStyle.prototype.updateInProgress_;

/**
 * This function returns whether the style is in between 'beginUpdate' and
 * 'endUpdate' calls from the {@link alk.layer.RoutingLayer}.
 *
 * @returns {boolean}
 * @this {alk.style.IconPOILayerStyle}
 */
alk.style.IconPOILayerStyle.prototype.isUpdateInProgress = function () {
  return this.updateInProgress_;
};

/**
 * This method is called when the 'updating' property of the
 * associated {@link alk.layer.RoutingLayer} is changed.
 *
 * @param {!boolean} value
 * @this {alk.style.IconPOILayerStyle}
 * @override
 */
alk.style.IconPOILayerStyle.prototype.setUpdating = function (value) {
  this.updateInProgress_ = value;
  if (value) {
    if (this.layer) {
      var features = this.layer.getSource().getFeatures();
      features.forEach(function(s) {s.changed();});
    }
  }
};

/**
 *
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {ol.style.Icon}
 * @this {alk.style.IconPOILayerStyle}
 * @protected
 */
alk.style.IconPOILayerStyle.prototype.getIconStyle = function (feature, resolution) {
  var poi = /** @type {pcmws.poi.POIObject} */ (feature.get('poi'));
  if (poi) {
    var category = poi.POICategory;
    var icon = this.iconFactory_.getIconForCategory(category);
    if (icon == null) {
      icon = this.defaultIcon_;
    }
    return icon;
  }
  return null;
};

/**
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @override
 * @this {alk.style.IconPOILayerStyle}
 * @api
 */
alk.style.IconPOILayerStyle.prototype.styleFunction = function(feature, resolution) {
  var icon = this.getIconStyle(feature, resolution);
  if (icon) {
    var style = new ol.style.Style({
      image: icon
    });
    return [style];
  } else {
    // This is experimental. I added a point feature for the POI radius call, and a
    // polygon (square) for the extent being requested.
    var radius = /** @type {number} */ (feature.get('radius'));
    if (radius) {
      var style = new ol.style.Style({
        image: new ol.style.Circle({
          radius: radius/resolution,
          fill: new ol.style.Fill({color: "rgba(069,013,189,0.1)"})
        })
      });
      return [style];
    } else {
      var extent = feature.get('extent');
      if (extent) {
        var style = new ol.style.Style({
          fill: new ol.style.Fill({
            color: "rgba(184,074,000,0.1)"
          }),
          stroke: new ol.style.Stroke({
            color: "white",
            width: 2
          })
        });
        return [style];
      }
    }
  }
  return [];
};
goog.provide('alk.layer.POILayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.style.POILayerStyle');
goog.require('alk.source.POISource');
goog.require('alk.style.IconPOILayerStyle');

goog.require('alkx.POILayerOptions');

/**
 * @classdesc
 * An instance of this class provides a layer that may lookup a points of interest within
 * the radius of a point, using the ALK POI Service, and display them.
 *
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @description
 * This constructor creates an ALK Points of Interest layer.
 * All visual representation is handled by the 'style' option.
 * As a default, the {@link alk.style.POILayerStyle} is used, which
 * as a default draws POIs according to their category.
 *
 * @param {alkx.POILayerOptions=} opt_options
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.POILayer = function (opt_options) {
  /** @type {alkx.POILayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var style = this.processStyle(options.style);

  var source = options.source;

  if (source === undefined) {
    source = new alk.source.POISource({
      poiServiceOptions: options.poiServiceOptions
    });
  }
  // We save these on the object so we can have them for changeStyle.
  this.layerOptions_ = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting,
    zIndex: options.zIndex
  };
  alk.layer.POILayer.base(this, 'constructor', this.layerOptions_);

  this.poiLayerStyle.setLayer(this);
};
goog.inherits(alk.layer.POILayer, ol.layer.Vector);

/**
 * This attribute contains the POILayerStyle that was either assigned
 * or created for this POILayer.
 * @type {alk.style.POILayerStyle}
 * @private
 */
alk.layer.POILayer.prototype.poiLayerStyle;

/**
 * This function returns the POILayerStyle that was either assigned or
 * created for this POILayer.
 * @returns {alk.style.POILayerStyle|undefined}
 * @this {alk.layer.POILayer}
 * @api
 */
alk.layer.POILayer.prototype.getPOILayerStyle = function () {
  return this.poiLayerStyle;
};

/**
 * This function assigns or creates the POILayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.POILayerStyle|alk.style.StrokeQueue|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.POILayer}
 * @protected
 */
alk.layer.POILayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.POILayerStyle) {
      self.poiLayerStyle = optStyle;
      style = function (feature, resolution) {
        return self.poiLayerStyle.styleFunction(feature, resolution);
      };
    } else {
      // We just go with the supplied style.
      style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
    }
  } else {
    if (this.poiLayerStyle === undefined) {
      this.poiLayerStyle = new alk.style.IconPOILayerStyle();
    }
    style = function (feature, resolution) {
      return self.poiLayerStyle.styleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function sets the Style for this layer.
 * @override
 * @param {alk.style.POILayerStyle|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @this {alk.layer.POILayer}
 * @api
 */
alk.layer.POILayer.prototype.setStyle = function (optStyle) {
  var style = this.processStyle(optStyle);
  alk.layer.POILayer.base(this, 'setStyle', style);
};
goog.provide('pcmws.api.RoadSurfaceRouteService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.HourOffset');
goog.require('pcmws.api.Provider');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.RoadSurfaceRouteServiceOptions');
goog.require('pcmws.api.RoadSurfaceRouteURL');
goog.require('pcmws.api.RouteDuration');
goog.require('pcmws.api.RoutePath');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');


/**
 * The Road Surface Route service.
 *
 * This service reports back with an array of integers
 * corresponding to the segment of the given path.
 * Each integer indicates the condition of the road between
 * its n and n+1 point on the route path..
 *
 * @param {pcmws.api.RoadSurfaceRouteServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.RoadSurfaceRouteService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['hourOffset', pcmws.api.HourOffset],
    ['routeDuration', pcmws.api.RouteDuration],
    ['routePath', pcmws.api.RoutePath],
    ['provider', pcmws.api.Provider]
  ];
  pcmws.api.RoadSurfaceRouteService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.RoadSurfaceRouteServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.RoadSurfaceRouteURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.RoadSurfaceRouteService, pcmws.api.StaticService);

/**
 * @override
 * @this {pcmws.api.RoadSurfaceRouteService}
 * @returns {pcmws.api.RoadSurfaceRouteService}
 */
pcmws.api.RoadSurfaceRouteService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.RoadSurfaceRouteServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.RoadSurfaceRouteService(opts);
};

/**
 * @description
 * This method will get the parse the JSON from an HTTP response from this configured
 * service using the URL that is generated by {@link getURL}.
 *
 * @param {(Object|function(Object))=} opts_or_callback
 * @param {function(Object)=} responseSuccessErrorCallback
 * @param {function(Object)=} responseErrorCallback
 * @override
 * @this {pcmws.api.RoadSurfaceRouteService}
 */
pcmws.api.RoadSurfaceRouteService.prototype.get = function (opts_or_callback, responseSuccessErrorCallback, responseErrorCallback) {
  var self = this;
  /** @type {pcmws.api.RoadSurfaceRouteServiceOptions} */
  var options = {};
  var success;
  var failure;
  if (typeof opts_or_callback === 'function') {
    success = /** @type {Function} */(opts_or_callback);
    failure = responseSuccessErrorCallback;
  } else {
    options = /** @type {pcmws.api.RoadSurfaceRouteServiceOptions} */(opts_or_callback);
    success = responseSuccessErrorCallback;
    failure = responseErrorCallback;
  }
  if (failure === undefined) {
    failure = success;
  }
  var headers = {
    'Content-Type' : 'application/json'
  };
  var params = this.getParamsArray(options);
  var payload = {};
  var queryParams = [];
  params.forEach(function (param) {
    var pair = param.getDataPair();
    if (pair) {
      if (pair[0] === "authToken") {
        headers['Authorization'] = pair[1];
      } else if (pair[0] === 'provider') {
        queryParams.push(param);
      } else {
        // POST Data
        payload[pair[0]] = pair[1];
      }
    }
  });
  var data = JSON.stringify(payload);
  var serviceURL = this.getServiceURL();
  var url = this.constructURL(serviceURL.hostURL, serviceURL.path, params);
  function pass(resp) {if (typeof success === 'function') success(self.processResponse(resp));}
  function fail(resp) {if (typeof failure === 'function') failure(self.processErrorResponse(resp));}
  this.xhrInvoke(url, 'POST', 'json', headers, data, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'object') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
goog.provide('alk.service.RoadSurfaceRouteService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.RoadSurfaceRouteService');

goog.require('alkx.RoadSurfaceRouteServiceOptions');
goog.require('alkx.RoadSurfaceRouteServiceResponse');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Road Surface Route Service.
 *
 * @description
 * This constructor creates a Service object that accesses the ALK
 * Road Surface Route Service.
 *
 * The response to the request on this object contains a list of ol.Feature objects.
 *
 * @param {alkx.RoadSurfaceRouteServiceOptions=} opt_options If defined, these options are used to make
 *        the base Road Surface Route Service object.
 *        Calls to {@link alk.service.RoadSurfaceRouteService#get} and
 *        {@link alk.service.RoadSurfaceRouteService#getServiceOptions} on this object will take options
 *        and override and extend what is set here.
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.RoadSurfaceRouteService = function (opt_options) {
  alk.service.RoadSurfaceRouteService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.roadSurfaceRouteService = this.pcmws = new pcmws.api.RoadSurfaceRouteService(this.pcmServiceOptions);
};
goog.inherits(alk.service.RoadSurfaceRouteService, alk.service.Service);

/**
 * @description
 * The ALK Road Surface Route Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.RoadSurfaceRouteService} object.
 *
 * @type {pcmws.api.RoadSurfaceRouteService}
 */
alk.service.RoadSurfaceRouteService.prototype.roadSurfaceRouteService;


/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from the Road Surface Route Service returns an
 * array of ol.Feature objects each containing a single LineString, which is a portion
 * of the supplied 'routePath' option in the call.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.RoadSurfaceRouteService}.
 * @param {Object} obj The Array.<number> response from the {@link alk.service.RoadSurfaceRouteService}.
 * @returns {Object} Containing the RoadSurfaceRouteServiceOptions and if a successful call
 *  also contains a FeatureCollection containing the line strings making up the collection.
 * @override
 * @this {alk.service.RoadSurfaceRouteService}
 * @api
 */
alk.service.RoadSurfaceRouteService.prototype.processResponse = function (options, obj) {
  var opts = /** @type {alkx.RoadSurfaceRouteServiceOptions} */(options);
  var result;
  if (obj) {
    // We are going to add the stops an their types and index.
    // The routePath is provided in EPSG:4326
    var routePath = opts.routePath || [];
    var features = [];
    var conditions = /** @type {Array.<number>} */(obj);
    var previousCondition = conditions[0];
    var currentSegmentPoints = [];
    routePath.forEach(function (point, i) {
      point = ol.proj.fromLonLat(point);
      var currentCondition = conditions[i];
      if (currentCondition === previousCondition) {
        currentSegmentPoints.push([point[0], point[1]]);
      } else {
        var geometry = new ol.geom.LineString(currentSegmentPoints);
        var feature = new ol.Feature(geometry);
        feature.set('roadSurfaceCondition', previousCondition);
        feature.set('segmentIndex', features.length);
        features.push(feature);
        previousCondition = currentCondition;
        currentSegmentPoints = [[point[0], point[1]]];
      }
    });
    if (currentSegmentPoints.length > 0) {
      var geometry = new ol.geom.LineString(currentSegmentPoints);
      var feature = new ol.Feature(geometry);
      feature.set('roadSurfaceCondition', previousCondition);
      feature.set('segmentIndex', features.length);
      features.push(feature);
    }
    result = {
      roadSurfaceRouteServiceOptions: opts,
      featureCollection: /** @type {ol.Collection<ol.Feature>} */(new ol.Collection(features))
    };
  } else {
    result = {
      roadSurfaceRouteServiceOptions: opts,
      featureCollection: null
    };
  }
  return result;
};

/**
 * @description
 * This method performs a call to the Road Surface Route Service to return a route.
 * @param {(alkx.RoadSurfaceRouteServiceOptions|null|function(alkx.RoadSurfaceRouteServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.RoadSurfaceRouteServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.RoadSurfaceRouteService}
 * @api
 */
alk.service.RoadSurfaceRouteService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.RoadSurfaceRouteServiceOptions} */
  var options = {};
  /** function(alkx.RoadSurfaceRouteServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.RoadSurfaceRouteServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.RoadSurfaceRouteService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.source.RoadSurfaceRoute');

goog.require('alk.source');
goog.require('alk.service.RoadSurfaceRouteService');

goog.require('alkx.RoadSurfaceRouteSourceOptions');

/**
 * @classdesc
 * An instance of this class sources Road Surface Features from the
 * ALK Road Surface Service.
 * @description
 * This constructor creates a Source object with which to source
 * features from the ALK Road Surface Service.
 *
 * @param {alkx.RoadSurfaceRouteSourceOptions=} opt_options
 * @constructor
 * @extends {ol.source.Vector}
 * @api
 */
alk.source.RoadSurfaceRoute = function (opt_options) {
  /** @type {alkx.RoadSurfaceRouteSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.service_ = new alk.service.RoadSurfaceRouteService(options.routeServiceOptions);

  this.baseOptions_ = {
    roadSurfaceRouteServiceOptions: options.roadSurfaceRouteServiceOptions
  };

  var opts = {
    wrapX: options.wrapX
  };
  alk.source.RoadSurfaceRoute.base(this, 'constructor', opts);
};
goog.inherits(alk.source.RoadSurfaceRoute, ol.source.Vector);

/**
 * @type {alk.service.RoadSurfaceRouteService}
 * @private
 */
alk.source.RoadSurfaceRoute.prototype.service_;

/**
 * @returns {alk.service.RoadSurfaceRouteService}
 * @this {alk.source.RoadSurfaceRoute}
 * @api
 */
alk.source.RoadSurfaceRoute.prototype.getRoadSurfaceRouteService = function () {
  return this.service_;
};

/**
 * @param {alk.service.RoadSurfaceRouteService} service
 * @this {alk.source.RoadSurfaceRoute}
 * @api
 */
alk.source.RoadSurfaceRoute.prototype.setRoadSurfaceRouteService = function (service) {
  this.service_ = service;
};

/**
 * This attribute contains the options with which the Route source was created.
 * @type {Object.<string,*>}
 * @private
 */
alk.source.RoadSurfaceRoute.prototype.baseOptions_;

/**
 * This method processes clones the RoadSurfaceRouteServiceOptions including a deep copy of the
 * of the 'routePath' property.
 *
 * @param {alkx.RoadSurfaceRouteServiceOptions} options The RoadSurfaceRouteServiceOptions to clone.
 * @returns {alkx.RoadSurfaceRouteServiceOptions} The cloned object.
 * @api
 */
alk.source.RoadSurfaceRoute.prototype.cloneRoadSurfaceRouteServiceOptions = function (options) {
  var routePath = options.routePath.map(function (p) {return p;});

  return {
    routePath: routePath,
    apiKey: options.apiKey,
    hostURL: options.hostURL,
    path: options.path,
    provider: options.provider
  };
};

/**
 * This method processes the response from the RoadSurfaceRouteService before it is handled by the
 * Road Surface Source. The default behavior is to pass it through.
 *
 * @param {alkx.RoadSurfaceRouteServiceResponse} response The response from the RouteService.
 * @returns {Object} The response pass through.
 * @this {alk.source.RoadSurfaceRoute}
 * @protected
 */
alk.source.RoadSurfaceRoute.prototype.processResponse = function (response) {
  // The service responds with the original routeServiceOptions, so we should be safe
  // and clone it here.
  var routeServiceOptions;
  if (response.roadSurfaceRouteServiceOptions) {
    routeServiceOptions = this.cloneRoadSurfaceRouteServiceOptions(response.roadSurfaceRouteServiceOptions);
  }
  return {
    roadSurfaceRouteServiceOptions: routeServiceOptions,
    featureCollection: response.featureCollection
  };
};
goog.provide('alk.service.MultipleServiceRequestEngine');

goog.require('alk.service.Service');

goog.require('alkx.ServiceOptions');

/**
 * @classdesc
 * This class provides a means to make multiple requests as a
 * block and signal the completion of all requests in the block.
 * @description
 * This constructor creates an object that has the function of making
 * multiple asychronous requests and singling back when all are done.
 * This functionality is useful for getting information for Weather Alerts,
 * etc.
 *
 *
 * @param {alkx.MultipleServiceRequestEngineOptions=} opt_options
 * @constructor
 * @api
 */
alk.service.MultipleServiceRequestEngine = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  this.service_ = options.service;
  this.requests_ = {};
  this.requestIds_ = 0;
};

/**
 * @type {alk.service.Service}
 * @private
 */
alk.service.MultipleServiceRequestEngine.prototype.service_;

/**
 * This property holds the codes to request and is mapped to a future.
 * @type {Object.<string, Array.<alkx.RoadSurfaceRouteServiceOptions|function(Object)>>}
 * @private
 */
alk.service.MultipleServiceRequestEngine.prototype.requests_;

/**
 * This property is the request id generator. It is an
 * increment counter.
 * @type {number}
 * @private
 */
alk.service.MultipleServiceRequestEngine.prototype.requestIds_;

/**
 * @returns {alk.service.Service}
 * @this {alk.service.MultipleServiceRequestEngine}
 */
alk.service.MultipleServiceRequestEngine.prototype.getService = function () {
  return this.service_;
};

/**
 * @description
 * This method queues the future to be executed when a response for the
 * requestId is returned.
 *
 * @param {alkx.ServiceOptions} options The options of the request to be given to the service.
 * @param {function(Object)} future Function to be called when code is loaded.
 * @this {alk.service.MultipleServiceRequestEngine}
 * @api
 */
alk.service.MultipleServiceRequestEngine.prototype.queueRequest = function (options, future) {
  var requestId = ''+this.requestIds_++;
  this.requests_[requestId] = [options, future];
};

/**
 * This method makes requests queued up since
 * the last call to this method.
 *
 * When each response is received, its associated future is called.
 *
 * @param {function(Array.<Object|undefined>)=} complete Function is called to notify when all codes have been loaded.
 * @this {alk.service.MultipleServiceRequestEngine}
 * @api
 */
alk.service.MultipleServiceRequestEngine.prototype.processQueue = function (complete) {
  var self = this;
  var requestsNeeded = Object.keys(/** @type{Object!} */
                       (this.requests_)).filter(function(k){return self.requests_.hasOwnProperty(k);});
  var requestMap = this.requests_;
  this.requests_ = {};

  var requests = {
    startTime: performance.now(),
    complete: complete,
    requestIds: {},
    responses: []
  };

  // EMCA5 way to tell if an object is empty.
  function isEmpty(obj) {
    // noinspection LoopStatementThatDoesntLoopJS
    for(var i in obj) {return false;}
    return true;
  }

  // This function gets called at the response to each call in the
  // set of calls made. If we got the last one, we make the call
  // to complete.
  /**
   *
   * @param {string} requestId
   * @param {Object|undefined} response
   */
  function allComplete (requestId, response) {
    requests.responses.push(response);
    delete requests.requestIds[requestId];
    if (isEmpty(requests.requestIds)) {
      var endTime = performance.now();
      console.log("All requests have been retrieved in " + (endTime - requests.startTime) + "ms");
      requests.complete(requests.responses);
    }
  }

  // We will use this apparatus if we are given a complete function.
  /** @type {function(string,Object)} */
  var completeCallback = typeof complete === 'function' ? allComplete : function(ri,o){};


  requestsNeeded.forEach(function (requestId) {
    requests.requestIds[requestId] = requestId;
    var options = /** @type {alkx.RoadSurfaceRouteServiceOptions} */ (requestMap[requestId][0]);
    var future = /** @type {function(Object)} */(requestMap[requestId][1]);
    self.getService().get(options, function(response) {
      self.storeAndRespond_(requestId, future, response || null, completeCallback);
    });
  });
};

/**
 * @param {string} requestId
 * @param {function(Object)} future
 * @param {Object} response
 * @param {function(string,Object)} complete
 * @private
 */
alk.service.MultipleServiceRequestEngine.prototype.storeAndRespond_ = function (requestId, future, response, complete) {
  if (response) {
    if (future) {
      future(response);
    }
  }
  complete(requestId, response);
};

/**
 * This method takes an array of options, making a block of requests on each.
 * The future will be called at the return of each request, and the complete
 * call back will be called when all requests are complete.
 *
 * @param {Array.<alkx.ServiceOptions>} optionsArray
 * @param {function(Object)} future
 * @param {function(Array.<Object>)} complete
 * @this {alk.service.MultipleServiceRequestEngine}
 */
alk.service.MultipleServiceRequestEngine.prototype.makeRequests = function (optionsArray, future, complete) {
  var self = this;
  optionsArray.forEach(function (options) {
    self.queueRequest(options, future);
  });
  this.processQueue(complete);
};
goog.provide('alk.source.SingleRoadSurfaceRoute');

goog.require('alk.source.RoadSurfaceRoute');
goog.require('alk.service.MultipleServiceRequestEngine');

goog.require('alkx.MultipleServiceRequestEngineOptions');
goog.require('alkx.RoadSurfaceRouteSourceOptions');
goog.require('alkx.RoadSurfaceRouteServiceOptions');
goog.require('alkx.RoadSurfaceRouteServiceResponse');

/**
 * @classdesc
 * An instance of this class provides a ol.source.Vector source for the
 * {@link alk.layer.RoadSurfaceRouteLayer}.
 * @fires {'change:request'}  Fires the 'change:request' event when done processing the response.
 * @fires {'change:updating'} Fires the 'change:updating' event on the begin and end of updating.
 *
 * @description
 * This constructor creates a Vector Source for the ALK Road Surface Route
 * Layer.
 * @param {alkx.RoadSurfaceRouteSourceOptions=} opt_options
 * @constructor
 * @extends {alk.source.RoadSurfaceRoute}
 * @api
 */
alk.source.SingleRoadSurfaceRoute = function (opt_options) {
  alk.source.SingleRoadSurfaceRoute.base(this, 'constructor', opt_options);
};
goog.inherits(alk.source.SingleRoadSurfaceRoute, alk.source.RoadSurfaceRoute);

/**
 * This method uses the given options to make the call to the underlying RoadSurfaceRouteService.
 * The response is taken from the RoadSurfaceRouteService call and handed off to
 * {@link alk.source.SingleRoadSurfaceRoute#processResponse}
 * before being given to the 'complete' callback given here.
 *
 * One may give this method an Array of RoadSurfaceRouteService parameter specifications.
 * Separate requests to the underlying RoadSurfaceRouteService will be made.
 * This situation may be used to map disconnected routePaths. Also, for a hub routing
 * situation where each leg is treated as a route up to a stop and back to the hub is
 * a prime use of using an array.
 *
 * Giving only one route specification object is equivalent to giving a one element array.
 * The complete call back will always be given an array of responses, and the 'request'
 * attribute will contain an array as well.
 *
 * After each response is returned from the server and given to processResponse, its feature
 * collection is added to the source.
 *
 * If multiple requests are made, the complete callback is called only after they all return,
 * whether it is an error or not.
 *
 * @param {Array.<alkx.RoadSurfaceRouteServiceOptions>|alkx.RoadSurfaceRouteServiceOptions} options
 * @param {function((alk.source.SingleRoadSurfaceRoute|undefined), (Array.<alkx.RoadSurfaceRouteServiceResponse>|undefined))=} complete
 * @fires {'change:request'}  Fires the 'change:request' event when done processing the response.
 * @fires {'change:updating'} Fires the 'change:updating' event on the begin and end of updating.
 * @this {alk.source.SingleRoadSurfaceRoute}
 * @api
 */
alk.source.SingleRoadSurfaceRoute.prototype.setRoute = function (options, complete) {
  /** @type {Array.<alkx.RoadSurfaceRouteSourceOptions>} */
  var optionsA = options instanceof Array ? options : [options];
  var self = this;
  /** @type {alkx.MultipleServiceRequestEngineOptions} */
  var engineOptions = {
    service: /** @type {alk.service.Service} */ (this.getRoadSurfaceRouteService())
  };
  var cache = new alk.service.MultipleServiceRequestEngine(engineOptions);
  var responses = [];
  this.set('updating', true);
  cache.makeRequests(optionsA, function(response) {
    var processedResponse = self.handleResponse(
      /** @type {alkx.RoadSurfaceRouteServiceResponse} */(response));
    responses.push(processedResponse);
  }, function () {
    self.set('updating', false);
    self.notifyComplete(responses, complete);
  });
};

/**
 * This method is an internal method that adds the features to this source, should
 * the process response return a featureCollection.
 *
 * @param {alkx.RoadSurfaceRouteServiceResponse} response
 * @this {alk.source.SingleRoadSurfaceRoute}
 * @returns {alkx.RoadSurfaceRouteServiceResponse}
 */
alk.source.SingleRoadSurfaceRoute.prototype.handleResponse = function (response) {
  var processedResponse = /** @type {alkx.RoadSurfaceRouteServiceResponse} */(this.processResponse(response));
  if (processedResponse.featureCollection) {
    var self = this;
    processedResponse.featureCollection.getArray().forEach(function (feature) {
      self.addFeature(feature);
    });
  }
  return processedResponse;
};

/**
 * This method notifies the complete callback after all the requests have been handled.
 *
 * @param {Array.<alkx.RoadSurfaceRouteSourceOptions>} response
 * @param {function((alk.source.SingleRoadSurfaceRoute|undefined), (Array.<alkx.RoadSurfaceRouteServiceResponse>|undefined))=} complete
 * @this {alk.source.SingleRoadSurfaceRoute}
 * @fires {'change:request'}  Fires the 'change:request' event when done processing the response.
 * @protected
 */
alk.source.SingleRoadSurfaceRoute.prototype.notifyComplete = function (response, complete) {
  // Notify everybody.
  // If you are wondering why we clone the response object here, it is because
  // we always want the change:request to fire regardless if response is the same.
  this.set('request', response.map(function(r){return r;}));
  if (complete && typeof complete === 'function') {
    complete(this, /** @type {Array.<alkx.RoadSurfaceRouteServiceOptions>} */(this.get('request')));
  }
};

/**
 * This method removes all the features from the source.
 * @override
 * @this {alk.source.SingleRoadSurfaceRoute}
 * @api
 */
alk.source.SingleRoadSurfaceRoute.prototype.clear = function () {
  this.unset('request');
  alk.source.SingleRoadSurfaceRoute.base(this, 'clear');
};
goog.provide('alk.style.RoadSurfaceStyle');

goog.require('alk.style');

/**
 * @classdesc
 * An instance of this class provides a styling function for the Road Surface Layer.
 * @description
 * This constructor creates a Style Function for styling Road Surfaces Layer.
 * @constructor
 * @extends {ol.Object}
 * @api
 */
alk.style.RoadSurfaceStyle = function () {
  alk.style.RoadSurfaceStyle.base(this, 'constructor');
};
goog.inherits(alk.style.RoadSurfaceStyle, ol.Object);

/**
 * @type {ol.layer.Vector}
 * @api
 */
alk.style.RoadSurfaceStyle.prototype.layer;

/**
 * This method is called by the Vector Style when installed. This
 * method also registers for the 'updating' property change on the
 * layer and calls 'beginUpdate' and 'endUpdate' for the values of
 * true and false respectively.
 *
 * @param {ol.layer.Vector} layer
 * @this {alk.style.RoadSurfaceStyle}
 */
alk.style.RoadSurfaceStyle.prototype.setLayer = function (layer) {
  var self = this;
  this.set('layer', this.layer = layer);
  var source;
  if (this.layer && (source = this.layer.getSource())) {
    source.on('change:updating', function (event) {
      var source = /** @type {ol.source.Vector} */(event.target);
      var updating = /** @type {boolean} */ (source.get('updating'));
      self.setUpdating(updating);
    });
    // In case the source is changed.
    this.layer.on('change:source', function (event) {
      var source = /** @type {ol.layer.Vector} */(event.target).getSource();
      source.on('change:updating', function (event) {
        var updating = /** @type {boolean} */ (source.get('updating'));
        self.setUpdating(updating);
      });
    });
  }
};

/**
 * This method is called when the 'updating' property of {@link alk.layer.RoadSurfaceTileLayer} is
 * changed. This call gives the style the ability to style things differently when being updated.
 * @param {boolean} value
 * @this {alk.style.RoadSurfaceStyle}
 * @api
 */
alk.style.RoadSurfaceStyle.prototype.setUpdating = function (value) {
};

/**
 * This function provides the styleFunction for the Road Surface Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @this {alk.style.RoadSurfaceStyle}
 * @api
 */
alk.style.RoadSurfaceStyle.prototype.styleFunction = function(feature, resolution) {
  var condition = /** @type {number} */(feature.get('roadSurfaceCondition'));
  condition = 0 <= condition && condition < this.conditions.length ? condition : 0;
  var spec = this.conditions[condition];
  var width;
  if (resolution < 1000) {
    // 4 + zoom level
    width = 4 + Math.log(resolution);
  } else {
    width = 2 * Math.log(resolution);
  }
  return [
    new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: spec.color,
        width: width
      })
    })
  ];
};


/**
 * These objects are the style specifications for the road surface conditions.
 * @type {Array.<Object>}
 */
alk.style.RoadSurfaceStyle.prototype.conditions = function () {
  return [
    {color:"#000000", id: 99, label: "Not in range"},
    {color:"#777777", id: 1, label: "Dry road"},
    {color:"#00ff00", id: 2, label: "Wet road"},
    {color:"#ff0000", id: 3, label: "Ice/snow"},
    {color:"#0000ff", id: 4, label: "Mix water/snow"},
    {color:"#777777", id: 5, label: "Dew"},
    {color:"#00ff00", id: 6, label: "Melting snow"},
    {color:"#ff0000", id: 7, label: "Frost"},
    {color:"#ff0000", id: 8, label: "Icing rain"}
  ];
}();
goog.provide('alk.layer.RoadSurfaceRouteLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.source.SingleRoadSurfaceRoute');
goog.require('alk.style.RoadSurfaceStyle');

goog.require('alkx.RoadSurfaceRouteLayerOptions');

/**
 * @classdesc
 * An instance of this class provides a display layer for a {@link alk.source.RoadSurfaceRoute} source, in which
 * depending its type will display routes according to the associated style. If no source is supplied,
 * the default is the {@link alk.source.RoadSurfaceRoute} source with the given
 * 'roadSurfaceRouteServiceOptions' option, if supplied.
 *
 * This class may be sub-classed to provide for different functionality.
 *
 * @description
 * This constructor creates an layer that gets ALK Road Surface tiles for particular routes.
 *
 * If no 'source' is provided in the options, then a new {@link alk.source.RoadSurfaceRoute} source
 * is created with a new {@link alk.service.RoadSurfaceRouteService} service created with
 * the provided 'roadSurfaceRouteServiceOptions' in the options.
 *
 * All visual representation is handled by the 'style' option.
 * As a default, the {@link alk.style.RoadSurfaceStyle} is used.
 *
 * Should you need a specific styling, please see {@link alk.style.RoadSurfaceStyle}
 * as a base object from which to implement.
 *
 * @param {alkx.RoadSurfaceRouteLayerOptions=} opt_options
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.RoadSurfaceRouteLayer = function (opt_options) {
  /** @type {alkx.RoadSurfaceRouteLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var style = this.processStyle(options.style);

  this.baseOptions_ = {
    roadServiceRouteServiceOptions: options.roadSurfaceRouteServiceOptions
  };

  var source = options.source;
  if (source === undefined) {
    source = new alk.source.SingleRoadSurfaceRoute({
      roadServiceRouteServiceOptions: options.roadSurfaceRouteServiceOptions
    });
  }

  // We save these on the object so we can have them for changeStyle.
  this.layerOptions_ = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting,
    zIndex: options.zIndex
  };
  alk.layer.RoadSurfaceRouteLayer.base(this, 'constructor', this.layerOptions_);


  this.roadSurfaceStyle.setLayer(this);
};
goog.inherits(alk.layer.RoadSurfaceRouteLayer, ol.layer.Vector);

/**
 * This attribute contains the RoadSurfaceStyle that was either assigned
 * or created for this RoadSurfaceRouteLayer.
 * @type {alk.style.RoadSurfaceStyle}
 * @private
 */
alk.layer.RoadSurfaceRouteLayer.prototype.roadSurfaceStyle;

/**
 * This function returns the RoadSurfaceStyle that was either assigned or
 * created for this RoadSurfaceRouteLayer.
 * @returns {alk.style.RoadSurfaceStyle|undefined}
 * @this {alk.layer.RoadSurfaceRouteLayer}
 * @api
 */
alk.layer.RoadSurfaceRouteLayer.prototype.getRoadSurfaceStyle = function () {
  return this.roadSurfaceStyle;
};

/**
 * This function assigns or creates the RoadSurfaceStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.RoadSurfaceStyle|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.RoadSurfaceRouteLayer}
 * @protected
 */
alk.layer.RoadSurfaceRouteLayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.RoadSurfaceStyle) {
      self.roadSurfaceStyle = optStyle;
      style = function (feature, resolution) {
        return self.roadSurfaceStyle.styleFunction(feature, resolution);
      };
    } else {
      style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
    }
  } else {
    if (this.roadSurfaceStyle === undefined) {
      this.roadSurfaceStyle = new alk.style.RoadSurfaceStyle();
    }
    style = function (feature, resolution) {
      return self.roadSurfaceStyle.styleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function sets the Style for this layer.
 * @override
 * @param {alk.style.RoadSurfaceStyle|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @this {alk.layer.RoadSurfaceRouteLayer}
 * @api
 */
alk.layer.RoadSurfaceRouteLayer.prototype.setStyle = function (optStyle) {
  var style = this.processStyle(optStyle);
  alk.layer.RoadSurfaceRouteLayer.base(this, 'setStyle', style);
};
goog.provide('pcmws.api.RoadSurfaceTileService');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.HourOffset');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.Provider');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.RoadSurfaceTileServiceOptions');
goog.require('pcmws.api.RoadSurfaceTileURL');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.Width');
goog.require('pcmws.api.X');
goog.require('pcmws.api.Y');
goog.require('pcmws.api.Z');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the OpenLayers XYZ source layer for
 * PCMiler Maptile service.
 * @param {pcmws.api.RoadSurfaceTileServiceOptions=} opt_options Options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.RoadSurfaceTileService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['drawerGroups', pcmws.api.DrawerGroups],
    ['format', pcmws.api.Format],
    ['imgOption', pcmws.api.ImgOption],
    ['imgSrc', pcmws.api.ImgSrc],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['style', pcmws.api.Style],
    ['width', pcmws.api.Width],
    ['height', pcmws.api.Height],
    ['hourOffset', pcmws.api.HourOffset],
    ['provider', pcmws.api.Provider],
    ['x', pcmws.api.X, '{x}'],
    ['y', pcmws.api.Y, '{y}'],
    ['z', pcmws.api.Z, '{z}']
  ];
  pcmws.api.RoadSurfaceTileService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.RoadSurfaceTileServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.RoadSurfaceTileURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.RoadSurfaceTileService, pcmws.api.StaticService);

/**
 * @override
 * @this {pcmws.api.RoadSurfaceTileService}
 * @returns {pcmws.api.RoadSurfaceTileService}
 */
pcmws.api.RoadSurfaceTileService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.RoadSurfaceTileServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.RoadSurfaceTileService(opts);
};

/**
 * @inheritDoc
 * @this {pcmws.api.RoadSurfaceTileService}
 */
pcmws.api.RoadSurfaceTileService.prototype.getAttribution = function(opts_or_callback, responseCallback) {
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    callback = responseCallback;
  }
  callback.call(this, {
    text: "Copyright &copy; " + new Date().getFullYear() + " ALK Technologies Inc. ",
    url: 'http://alkmaps.com',
    image: pcmws.ALK_LOGO_URL
  });
};
goog.provide('alk.service.RoadSurfaceTileService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.RoadSurfaceTileService');

goog.require('alkx.RoadSurfaceTileServiceOptions');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults, generates a URL for the
 * ALK Road Surface Tile Web Service.
 * @description
 * This constructor creates a Service object that accesses the ALK Road Surface Tile
 * Web Service. It is meant to merely be a URL generator for a tile source.
 * @param {alkx.RoadSurfaceTileServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.RoadSurfaceTileService = function (opt_options) {
  alk.service.RoadSurfaceTileService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.roadSurfaceTileService = this.pcmws = new pcmws.api.RoadSurfaceTileService(this.pcmServiceOptions);
};
goog.inherits(alk.service.RoadSurfaceTileService, alk.service.Service);

/**
 * @description
 * The ALK Traffic Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.RoadSurfaceTileService} object.
 *
 * @type {pcmws.api.RoadSurfaceTileService}
 */
alk.service.RoadSurfaceTileService.prototype.roadSurfaceTileService;
goog.provide('alk.val.Provider');

goog.require('alk.val');
/**
 * @description
 * This object contains the definitive values for the Provider option;
 *
 * @enum {string}
 * @api
 */
alk.val.Provider = {
  /** @api */
 Default: 'Default',
  /** @api */
 RC1: 'RC1'
};
goog.provide('alk.source.RoadSurfaceTileSource');

goog.require('alk.ATTRIBUTION');
goog.require('alk.source.ImageTileSource');
goog.require('alk.service.RoadSurfaceTileService');
goog.require('alk.val.Provider');

goog.require('alkx.RoadSurfaceTileSourceOptions');
goog.require('alkx.RoadSurfaceTileServiceOptions');

/**
 * @classdesc
 * An instance of this class holds the source for an ALK RoadSurface Source that is used
 * in the {@link alk.layer.RoadSurfaceTileLayer}.
 * @description
 * This constructor creates a Source object to retrieve Road Surface Tiles from the
 * ALK Road Surface Tile Service.
 *
 * It is an {@link ol.source.Tile} source that uses the ALK RoadSurface Service.
 *
 * @param {alkx.RoadSurfaceTileSourceOptions=} opt_options
 * @extends {alk.source.ImageTileSource}
 * @constructor
 * @api
 */
alk.source.RoadSurfaceTileSource = function (opt_options) {
  /** @type {alkx.RoadSurfaceTileSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.RoadSurfaceTileServiceOptions} */
  var serviceOptions = options.serviceOptions !== undefined ? options.serviceOptions : {};

  // Apparently, this service needs a provider of RC1, and the hourOffset at least to be zero to
  // get a good response from the server.
  /** @type {alkx.RoadSurfaceTileServiceOptions} */
  var serviceOpts = {
    hourOffset: serviceOptions.hourOffset ? serviceOptions.hourOffset : 0,
    provider: serviceOptions.provider ? serviceOptions.provider : alk.val.Provider.RC1
  };
  var service = new alk.service.RoadSurfaceTileService(serviceOpts);

  var attributions;
  if (options.attributions !== undefined) {
    attributions = options.attributions;
  }

  alk.source.RoadSurfaceTileSource.base(this, 'constructor', {
    attributions: attributions,
    service: service,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    //logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileSize: options.tileSize,
    tileUrlFunction: options.tileUrlFunction,
    wrapX: options.wrapX,
    transition: options.transition
  });

  this.roadSurfaceTileService_ = service;
};
goog.inherits(alk.source.RoadSurfaceTileSource, alk.source.ImageTileSource);

/**
 * @type {alk.service.RoadSurfaceTileService}
 * @private
 */
alk.source.RoadSurfaceTileSource.prototype.roadSurfaceTileService_;


/**
 * @returns {alk.service.RoadSurfaceTileService}
 * @api
 * @this {alk.source.RoadSurfaceTileSource}
 */
alk.source.RoadSurfaceTileSource.prototype.getRoadSurfaceTileService = function () {
  return this.roadSurfaceTileService_;
};

/**
 * @param {alk.service.RoadSurfaceTileService} service
 * @this {alk.source.RoadSurfaceTileSource}
 * @api
 */
alk.source.RoadSurfaceTileSource.prototype.setRoadSurfaceTileService = function (service) {
  this.roadSurfaceTileService_ = service;
  this.setService(service);
};

/**
 * This method causes an entire refresh of this source. It does this by creating
 * a new RoadSurfaceTileService from the old one with the extended options.
 * @param {alkx.RoadSurfaceTileServiceOptions=} options
 * @this {alk.source.RoadSurfaceTileSource}
 * @api
 */
alk.source.RoadSurfaceTileSource.prototype.changeRoadSurfaceTileService = function (options) {
  var service = this.roadSurfaceTileService_;
  var opts = service.getServiceOptions(options);
  this.setRoadSurfaceTileService(new alk.service.RoadSurfaceTileService(opts));
};
/**
 * @override
 * @param {alkx.AttributionJSON=} attributionJSON
 * @this {alk.source.RoadSurfaceTileSource}
 */
alk.source.RoadSurfaceTileSource.prototype.processAttributionResponse = function(attributionJSON) {
  /** @type {ol.AttributionLike} */
  var attribution;
  if (attributionJSON) {
    var url = attributionJSON.url;
    var image = attributionJSON.image;
    attribution = 'RoadSurface from <a href="'+url+'" target="_blank"><img src="'+image+'"></a>';
  } else {
    attribution = alk.ATTRIBUTION;
  }
  this.setAttributions([attribution]);
};
goog.provide('alk.layer.RoadSurfaceTileLayer');

goog.require('alk.layer');
goog.require('alk.source.RoadSurfaceTileSource');
goog.require('alk.layer.ImageTileLayer');

goog.require('alkx.RoadSurfaceLayerOptions');
goog.require('alkx.RoadSurfaceTileSourceOptions');

/**
 * @classdesc
 * An instance of this class is to be used for the RoadSurface
 * layer in an {@link ol.Map}, which is normally placed above a
 * base map layer.
 *
 * @description
 * This constructor creates an ALK Layer that displays road surface
 * tiles which is meant to be placed over a base map layer.
 *
 * It uses a {@link alk.source.RoadSurfaceTileSource} source that is
 * specific to the ALK RoadSurface Tile Service.
 *
 * @example
 * var map = new ol.Map({
 *   layers: [
 *     new alk.layer.BaseMapLayer(),
 *     new alk.layer.RoadSurfaceTileLayer()
 *     ]
 * });
 *
 * @param {alkx.RoadSurfaceLayerOptions=} opt_options
 * @extends {alk.layer.ImageTileLayer}
 * @constructor
 * @api
 */
alk.layer.RoadSurfaceTileLayer = function(opt_options) {
  /** @type {alkx.RoadSurfaceLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.RoadSurfaceTileSourceOptions} */
  var sourceOptions = options.sourceOptions !== undefined ? options.sourceOptions : {};

  var source = new alk.source.RoadSurfaceTileSource({
    serviceOptions: sourceOptions.serviceOptions,
    cacheSize: sourceOptions.cacheSize,
    crossOrigin: sourceOptions.crossOrigin,
    opaque: sourceOptions.opaque,
    projection: sourceOptions.projection,
    reprojectionErrorThreshold: sourceOptions.reprojectionErrorThreshold,
    maxZoom: sourceOptions.maxZoom,
    minZoom: sourceOptions.minZoom,
    tileGrid: sourceOptions.tileGrid,
    tileLoadFunction: sourceOptions.tileLoadFunction,
    tilePixelRatio: sourceOptions.tilePixelRatio,
    tileSize: sourceOptions.tileSize,
    tileUrlFunction: sourceOptions.tileUrlFunction,
    wrapX: sourceOptions.wrapX,
    transition: sourceOptions.transition
  });

  alk.layer.RoadSurfaceTileLayer.base(this, 'constructor',  {
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError
  });
};
goog.inherits(alk.layer.RoadSurfaceTileLayer, alk.layer.ImageTileLayer);
goog.provide('pcmws.api.POICategoriesSingleSearch');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.MultivalueParam');

/**
 * @classdesc
 * An instance of this class represents the POICategoriesSingleSearch parameter for a Single Search service.
 *
 * This parameter gives the ordered list of pOICategoriesSingleSearch for the single search.
 *
 * @param {Array<string>|string=} values The value.
 * @constructor
 * @extends {pcmws.api.MultivalueParam}
 *
 */
pcmws.api.POICategoriesSingleSearch = function (values) {
  pcmws.api.POICategoriesSingleSearch.base(this, 'constructor', 'poiCategories', values, ',');
};
goog.inherits(pcmws.api.POICategoriesSingleSearch, pcmws.api.MultivalueParam);
goog.provide('pcmws.api.SearchSingleSearchService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Coords');
goog.require('pcmws.api.Countries');
goog.require('pcmws.api.CountryType');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.ExcludeSearchTypes');
goog.require('pcmws.api.MaxResults');
goog.require('pcmws.api.POICategoriesSingleSearch');
goog.require('pcmws.api.Query');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SearchSingleSearchServiceOptions');
goog.require('pcmws.api.SearchSingleSearchURL');
goog.require('pcmws.api.States');
goog.require('pcmws.api.StaticService');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for the Single Search Search service.
 *
 * @param {pcmws.api.SearchSingleSearchServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.SearchSingleSearchService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region],
    ["countries", pcmws.api.Countries],
    ["countryType", pcmws.api.CountryType],
    ['poiCategories', pcmws.api.POICategoriesSingleSearch],
    ['excludeSearchTypes', pcmws.api.ExcludeSearchTypes],
    ['states', pcmws.api.States],
    ['maxResults', pcmws.api.MaxResults],
    ['coords', pcmws.api.Coords],
    ['query', pcmws.api.Query]
  ];
  pcmws.api.SearchSingleSearchService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.SearchSingleSearchServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.SearchSingleSearchURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.SearchSingleSearchService, pcmws.api.StaticService);

/**
 * @override
 * @this {pcmws.api.SearchSingleSearchService}
 * @returns {pcmws.api.SearchSingleSearchService}
 */
pcmws.api.SearchSingleSearchService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.SearchSingleSearchServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.SearchSingleSearchService(opts);
};

/**
 * @inheritDoc
 * @this {pcmws.api.SearchSingleSearchService}
 */
pcmws.api.SearchSingleSearchService.prototype.getURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};

/**
 * @inheritDoc
 * @this {pcmws.api.SearchSingleSearchService}
 */
pcmws.api.SearchSingleSearchService.prototype.getAttributionURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceAttributionURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};
goog.provide('alk.service.SearchSingleSearchService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.SearchSingleSearchService');

goog.require('alkx.SearchSingleSearchServiceOptions');
goog.require('alkx.SearchSingleSearchServiceResponse');
goog.require('alkx.SingleSearchResult');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Search Single Search Service.
 * @description
 * This constructor creates a Service object to perform searches on the
 * ALK Single Search Service.
 * @param {alkx.SearchSingleSearchServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.SearchSingleSearchService = function (opt_options) {
  alk.service.SearchSingleSearchService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.searchSingleSearchService = this.pcmws = new pcmws.api.SearchSingleSearchService(this.pcmServiceOptions);
};
goog.inherits(alk.service.SearchSingleSearchService, alk.service.Service);

/**
 * @description
 * The ALK Search Single Search Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.SearchSingleSearchService} object.
 *
 * @type {pcmws.api.SearchSingleSearchService}
 */
alk.service.SearchSingleSearchService.prototype.searchSingleSearchService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from Search Single Search Service returns a JSON object
 * containing a single {@link alkx.SingleSearchResult}.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.SearchSingleSearchService}.
 * @param {Object} obj The JSON response from the {@link alk.service.SearchSingleSearchService}.
 * @returns {Object} Containing the searchSingleSearchServiceOptions and if a successful call
 *  also contains a JSON object containing the points of interest requested.
 * @override
 * @api
 */
alk.service.SearchSingleSearchService.prototype.processResponse = function (options, obj) {
  return {
    searchSingleSearchServiceOptions: /** @type {alkx.SearchSingleSearchServiceOptions} */ (options),
    result: /** @type {alkx.SingleSearchResult} */ (obj)
  };
};

/**
 * @description
 * This method performs a call to the Search Single Search Service.
 * @param {(alkx.SearchSingleSearchServiceOptions|null|function(alkx.SearchSingleSearchServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.SearchSingleSearchServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.SearchSingleSearchService}
 * @api
 */
alk.service.SearchSingleSearchService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.SearchSingleSearchServiceOptions} */
  var options = {};
  /** function(alkx.SearchSingleSearchServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.SearchSingleSearchServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.SearchSingleSearchService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.source.SingleSearch');

goog.require('alk.source');
goog.require('alk.service.SearchSingleSearchService');

goog.require('alkx.SingleSearchSourceOptions');
goog.require('alkx.SearchSingleSearchServiceOptions');
goog.require('alkx.SearchSingleSearchServiceResponse');

/**
 * @classdesc
 * An instance of this class provides a vector source for a vector
 * layer. It is used in conjunction with the {@link alk.layer.SingleSearchLayer}.
 * @fires {'change:searchResult'} This event is fired when a search result is retrieved.
 *
 * @description
 * This constructor creates a Vector Source object that responds to the
 * ALK Single Search Service.
 *
 * @param {alkx.SingleSearchSourceOptions=} opt_options
 * @extends {ol.source.Vector}
 * @constructor
 * @api
 */
alk.source.SingleSearch = function (opt_options) {
  /** @type {alkx.SingleSearchSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  if (options.searchSingleSearchService !== undefined) {
    this.searchSingleSearchService_ = options.searchSingleSearchService;
  }
  if (this.searchSingleSearchService_ == null) {
    if (options.searchSingleSearchServiceOptions !== undefined) {
      this.searchSingleSearchService_ =
        new alk.service.SearchSingleSearchService(options.searchSingleSearchServiceOptions);
    }
  }
  if (this.searchSingleSearchService_ == null) {
    this.searchSingleSearchService_ =
      new alk.service.SearchSingleSearchService();
  }
  /** @type {olx.source.VectorOptions} */
  var opts = {
    wrapX: options.wrapX
  };
  alk.source.SingleSearch.base(this, 'constructor', opts);
  this.setSearchResult(null);
};
goog.inherits(alk.source.SingleSearch, ol.source.Vector);

/**
 * @returns {alk.service.SearchSingleSearchService}
 * @this {alk.source.SingleSearch}
 * @api
 */
alk.source.SingleSearch.prototype.getSearchSingleSearchService = function () {
  return this.searchSingleSearchService_;
};


/**
 *
 * @param {alkx.SearchSingleSearchServiceOptions} options
 * @param {function(ol.source.Source, alkx.SearchSingleSearchServiceResponse)} complete
 * @this {alk.source.SingleSearch}
 * @api
 */
alk.source.SingleSearch.prototype.search = function (options, complete) {
  var self = this;
  this.clear();
  this.setSearchResult(null);

  /** @type {alkx.SearchSingleSearchServiceOptions} */
  var searchOptions = this.searchSingleSearchService_.getServiceOptions(options);
  this.searchSingleSearchService_.get(options, function (response) {
    self.handleResult(response.result || null);
    self.setSearchResult(response.result || null);
    if (typeof complete === 'function') {
      /** @type {alkx.SearchSingleSearchServiceResponse!} */
      var res = {
        searchSingleSearchServiceOptions: searchOptions,
        result: /** @type {alkx.SingleSearchResult|null} */(response.result || null)
      };
      complete(self, res);
    }
  });
};

/**
 * @type {alkx.SingleSearchResult|null}
 * @api
 */
alk.source.SingleSearch.prototype.searchResult;

/**
 * @returns {alkx.SingleSearchResult|null}
 * @this {alk.source.SingleSearch}
 * @api
 */
alk.source.SingleSearch.prototype.getSearchResult = function () {
  return /** @type {alkx.SingleSearchResult} */(this.get('searchResult'));
};

/**
 * This sets the SearchResult. It is used internally.
 * @param {alkx.SingleSearchResult|null} result
 * @this {alk.source.SingleSearch}
 * @protected
 */
alk.source.SingleSearch.prototype.setSearchResult = function (result) {
  this.set('searchResult', this.searchResult = result);
};

/**
 *
 * @param {alkx.SingleSearchResult|null} result
 * @protected
 * @this {alk.source.SingleSearch}
 */
alk.source.SingleSearch.prototype.handleResult = function (result) {
  if (result) {
    var self = this;
    var locations = result.Locations;
    if (locations && locations instanceof Array && locations.length > 0) {
      locations.forEach(function (location) {
        if (location.Coords && location.Coords.Lat && location.Coords.Lon) {
          var lon = parseFloat(location.Coords.Lon);
          var lat = parseFloat(location.Coords.Lat);
          if (typeof lon === 'number' && typeof lat === 'number') {
            var geom = new ol.geom.Point(ol.proj.fromLonLat([lon, lat]));
            var feature = new ol.Feature(geom);
            feature.set('location', location);
            self.addFeature(feature);
          }
        }
      });
    }
  }
};
goog.provide('alk.style.SingleSearchStyle');

goog.require('alk.style');
goog.require('alk.style.Shadow');

/**
 * @classdesc
 * This is the base class that provides a styling function for the SingleSearch.
 * @description
 * This constructor is the base constructor for creating a style function
 * for Single Search results.
 *
 * @constructor
 * @extends {ol.Object}
 * @api
 */
alk.style.SingleSearchStyle = function () {
  alk.style.SingleSearchStyle.base(this, 'constructor');
};
goog.inherits(alk.style.SingleSearchStyle, ol.Object);

/**
 * @type {ol.layer.Vector}
 * @api
 */
alk.style.SingleSearchStyle.prototype.layer;

/**
 * This method is called by the SingleSearch when installed. This
 * method also registers for the 'updating' property change on the
 * layer and calls {@link alk.style.SingleSearchStyle#setUpdating}.
 *
 * @param {ol.layer.Vector} layer
 * @this {alk.style.SingleSearchStyle}
 * @api
 */
alk.style.SingleSearchStyle.prototype.setLayer = function (layer) {
  var self = this;
  this.set('layer', this.layer = layer);
  if (this.layer) {
    this.layer.on('change:updating', function (event) {
      var updating = /** @type {boolean} */ (self.layer.get('updating'));
      self.setUpdating(updating);
    });
  }
};

/**
 * This method is called when the 'updating' property of {@link alk.layer.SingleSearch} is
 * changed. This call gives the style the ability to style things differently when being updated.
 * @param {boolean} value
 * @this {alk.style.SingleSearchStyle}
 * @api
 */
alk.style.SingleSearchStyle.prototype.setUpdating = function (value) {
  this.set('updating', value);
};

/**
 * This function returns the style for the given feature at the specified resolution.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {ol.style.Style|undefined}
 * @this {alk.style.SingleSearchStyle}
 */
alk.style.SingleSearchStyle.prototype.getFeatureStyle = function (feature, resolution) {

  var location = /** @type {alkx.SingleSearchLocation} */(feature.get('location'));
  if (location) {
    return new ol.style.Style({
      image: new ol.style.Icon({src: alk.img.POI.Other})
    });
  }
};

/**
 * This function provides the styleFunction for the Routing Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @this {alk.style.SingleSearchStyle}
 * @api
 */
alk.style.SingleSearchStyle.prototype.styleFunction = function(feature, resolution) {
  var styles = [];
  if (feature.get('location')) {
    var style = this.getFeatureStyle(feature, resolution);
    if (style) {
      var image = style.getImage();
      var shadow;
      if (image instanceof ol.style.Circle) {
        var radius = image.getRadius();
        radius += image.getStroke().getWidth() / 2;
        radius += 1;
        var size = radius * 2 + 8;
        // We can only use our shadow if we are using ol-debug.js to get access to ol.style.Image
        if (typeof ol.style.Image.prototype.getImageState === 'function') {
          shadow = new alk.style.Shadow({size: [size, size], radius: radius, offset: [1, 0]});
        } else {
          // doesn't currently work
          shadow = new alk.style.ShadowedCircle({size: [size, size], radius: radius, offset: [1, 0]});
        }
      } else {
        if (typeof image.getImageSize === 'function') {
          var size = image.getImageSize();
          // We can only use our shadow if we are using ol-debug.js to get access to ol.style.Image
          if (typeof ol.style.Image.prototype.getImageState === 'function') {
            shadow = new alk.style.Shadow({size: [size, size], offset: [4, 2]});
          } else {
            // doesn't currently work
            shadow = new alk.style.ShadowedCircle({radius: size/2, offset: [4, 2]});
          }
        }
      }
      if (shadow) {
        var shadowStyle = new ol.style.Style({image: shadow});
        styles.push(shadowStyle);
      }
      styles.push(style);
    }
  }
  return styles;
};
goog.provide('alk.layer.SingleSearchLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.source.SingleSearch');
goog.require('alk.style.SingleSearchStyle');

goog.require('alkx.SingleSearchLayerOptions');

/**
 * @classdesc
 * An instance of this class provides a display layer for a {@link alk.source.SingleSearch} source, in which
 * depending its type will display items according to the associated style. If no source is supplied,
 * the default is the {@link alk.source.SingleSearch} source with the given
 * 'searchSingleSearchServiceOptions' option.
 *
 * This class may be sub-classed to provide for different functionality.
 *
 * @description
 * This constructor creates a layer that displays data for an ALK single search.
 *
 * If no 'source' is provided in the options, then a new {@link alk.source.SingleSearch} source
 * is created with a new {@link alk.service.SearchSingleSearchService} service created with
 * the provided 'searchSingleSearchServiceOptions' in the options.
 *
 * All visual representation is handled by the 'style' option.
 * As a default, the {@link alk.style.SingleSearchStyle} is used.
 *
 * Should you need a specific styling, please see {@link alk.style.SingleSearchStyle}
 * as a base object from which to implement.
 *
 * @param {alkx.SingleSearchLayerOptions=} opt_options
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.SingleSearchLayer = function (opt_options) {
  /** @type {alkx.SingleSearchLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var style = this.processStyle(options.style);

  var source = options.source;
  if (source === undefined) {
    /** @type {alkx.SingleSearchSourceOptions|undefined} */
    var sourceOptions = options.searchSingleSearchSourceOptions;
    source = new alk.source.SingleSearch(sourceOptions);
  }

  // TODO: Make this work.
  this.frameSearchResults = options.frameSearchResults || false;

  // We save these on the object so we can have them for changeStyle.
  /** @type {olx.layer.VectorOptions} */
  this.layerOptions_ = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting,
    zIndex: options.zIndex
  };
  alk.layer.SingleSearchLayer.base(this, 'constructor', this.layerOptions_);


  if (this.singleSearchStyle) {
    this.singleSearchStyle.setLayer(this);
  }
};
goog.inherits(alk.layer.SingleSearchLayer, ol.layer.Vector);

/**
 * This attribute contains the SingleSearchStyle that was either assigned
 * or created for this SingleSearchLayer.
 * @type {alk.style.SingleSearchStyle}
 * @private
 */
alk.layer.SingleSearchLayer.prototype.singleSearchStyle;

/**
 * This property states when the search result complete, that the
 * map will zoom into the extent containing the features;
 *
 * @type {boolean}
 */
alk.layer.SingleSearchLayer.prototype.frameSearchResults;

/**
 * This function returns the Single Search Style that was either assigned or
 * created for this SingleSearchLayer.
 * @returns {alk.style.SingleSearchStyle|undefined}
 * @this {alk.layer.SingleSearchLayer}
 * @api
 */
alk.layer.SingleSearchLayer.prototype.getSingleSearchStyle = function () {
  return this.singleSearchStyle;
};

/**
 * This function assigns or creates the SingleSearchStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.SingleSearchStyle|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.SingleSearchLayer}
 * @protected
 */
alk.layer.SingleSearchLayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.SingleSearchStyle) {
      self.singleSearchStyle = optStyle;
      style = function (feature, resolution) {
        return self.singleSearchStyle.styleFunction(feature, resolution);
      };
    } else {
      style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
    }
  } else {
    if (this.singleSearchStyle === undefined) {
      this.singleSearchStyle = new alk.style.SingleSearchStyle();
    }
    style = function (feature, resolution) {
      return self.singleSearchStyle.styleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function sets the Style for this layer.
 * @override
 * @param {alk.style.SingleSearchStyle|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @this {alk.layer.SingleSearchLayer}
 * @api
 */
alk.layer.SingleSearchLayer.prototype.setStyle = function (optStyle) {
  var style = this.processStyle(optStyle);
  alk.layer.SingleSearchLayer.base(this, 'setStyle', style);
};
goog.provide('alk.style.TrafficCamerasLayerStyle');

goog.require('alk.style');

/**
 * @classdesc
 * An instance of this class provides a styling function for the Traffic Cameras Layer.
 * @description
 * This constructor creates a Style Function for stying cameras in the Traffic Cameras Layers.
 *
 * It shall provide a styleFunction and has a settable property of 'layer'.
 * @constructor
 * @extends {ol.Object}
 * @api
 */
alk.style.TrafficCamerasLayerStyle = function () {
  alk.style.TrafficCamerasLayerStyle.base(this, 'constructor');
};
goog.inherits(alk.style.TrafficCamerasLayerStyle, ol.Object);

/**
 * @type {string}
 * @api
 */
alk.style.TrafficCamerasLayerStyle.prototype.defaultIconURL;

/**
 * This function returns the URL to be used for the traffic camera of the given feature.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {string}
 */
alk.style.TrafficCamerasLayerStyle.prototype.getIconURL = function (feature, resolution) {
  // TODO: Generalize this icon location.
  return "http://maps.alk.com/api/1.2/img/safety_camera.png";
};

/**
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @return {ol.style.Style}
 * @protected
 * @this {alk.style.TrafficCamerasLayerStyle}
 */
alk.style.TrafficCamerasLayerStyle.prototype.getIconStyle = function (feature, resolution) {
  var url;

  if (feature.get('trafficCamera')) {
    url = this.getIconURL(feature, resolution) || this.defaultURL_;
    return new ol.style.Style({
      image: new ol.style.Icon({
        src: url
      })
    });
  }

  // We may be clustering.
  /** @type {Array.<ol.Feature>} */
  var features = /** @type {Array.<ol.Feature>} */(feature.get('features'));
  if (features) {
    if (features.length === 1) {
      if (features[0].get('trafficCamera')) {
        url = this.getIconURL(features[0], resolution) || this.defaultURL_;
        return new ol.style.Style({
          image: new ol.style.Icon({
            src: url
          })
        });
      }
    } else {
      var text = '' + features.length;
      var textStyle = new ol.style.Text({
        font: '11px',
        text: text,
        textAlign: 'center',
        fill: new ol.style.Fill({
          color: 'black'
        })
      });
      var circle = new ol.style.Circle({
        radius: 11,
        fill: new ol.style.Fill({
          color: 'white',
          opacity: 1.0
        }),
        stroke: new ol.style.Stroke({
          color: 'red',
          width: 3
        })
      });
      return new ol.style.Style({
        image: circle,
        text: textStyle
      });
    }
  }
  return null;
};

/**
 * This function provides the styleFunction for the Traffic Cameras Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @this {alk.style.TrafficCamerasLayerStyle}
 * @api
 */
alk.style.TrafficCamerasLayerStyle.prototype.styleFunction = function(feature, resolution) {
  var style = this.getIconStyle(feature, resolution);
  if (style) {
    return [style];
  } else {
    var extent = feature.get('extent');
    if (extent) {
      var styleE = new ol.style.Style({
        fill: new ol.style.Fill({
          color: "rgba(184,074,000,0.1)"
        }),
        stroke: new ol.style.Stroke({
          color: "white",
          width: 2
        })
      });
      return [styleE];
    }
  }
  return [];
};
goog.provide('pcmws.api.TrafficCamerasService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.BoundingBox');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.TrafficCamerasServiceOptions');
goog.require('pcmws.api.TrafficCamerasURL');

/**
 * @param {pcmws.api.TrafficCamerasServiceOptions=} opt_options Options
 * @constructor
 * @extends {pcmws.api.StaticService}
 *
 */
pcmws.api.TrafficCamerasService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['boundingBox', pcmws.api.BoundingBox]
  ];
  pcmws.api.TrafficCamerasService.base(this, 'constructor', specs, opt_options);

  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.TrafficCamerasURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.TrafficCamerasService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.TrafficCamerasService}
 * @returns {pcmws.api.TrafficCamerasService}
 */
pcmws.api.TrafficCamerasService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.TrafficCamerasServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.TrafficCamerasService(opts);
};
goog.provide('alk.service.TrafficCamerasService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.TrafficCamerasService');

goog.require('alkx.TrafficCamerasServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Traffic Camera Service.
 * @description
 * This constructor creates a Service object to access the ALK Traffic Camera Service.
 *
 * @param {alkx.TrafficCamerasServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.TrafficCamerasService = function (opt_options) {
  alk.service.TrafficCamerasService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.trafficCameraService = this.pcmws = new pcmws.api.TrafficCamerasService(this.pcmServiceOptions);
};
goog.inherits(alk.service.TrafficCamerasService, alk.service.Service);

/**
 * @description
 * The ALK Traffic Camera Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.TrafficCamerasService} object.
 *
 * @type {pcmws.api.TrafficCamerasService}
 */
alk.service.TrafficCamerasService.prototype.trafficCameraService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from Traffic Cameras Service returns a JSON object
 * containing a single {@link alkx.TrafficCameraSpec}.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.TrafficCamerasService}.
 * @param {Object=} obj The JSON response from the {@link alk.service.TrafficCamerasService}.
 * @returns {Object} Containing the TrafficCamerasServiceOptions and if a successful call
 *  also contains a JSON object containing the traffic cameras requested.
 * @override
 * @api
 */
alk.service.TrafficCamerasService.prototype.processResponse = function (options, obj) {
  return {
    TrafficCamerasServiceOptions: options,
    result: obj
  };
};

/**
 * @description
 * This method performs a call to the Traffic Camera Service to return a route.
 * @param {(alkx.TrafficCamerasServiceOptions|null|function(alkx.TrafficCamerasServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.TrafficCamerasServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.TrafficCamerasService}
 * @api
 */
alk.service.TrafficCamerasService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.TrafficCamerasServiceOptions} */
  var options = {};
  /** function(alkx.TrafficCamerasServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.TrafficCamerasServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.TrafficCamerasService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.source.TrafficCamerasSource');

goog.require('alk');
goog.require('alk.format.TrafficCamerasJSON');
goog.require('alk.service.TrafficCamerasService');
goog.require('alk.source');
goog.require('alk.source.SubtractionLoadStrategy');
goog.require('alk.val.SRS');

goog.require('alkx.TrafficCamerasSourceOptions');

/**
 * @classdesc
 * An instance of this class provides a 'source' for the {@link alk.layer.TrafficCamerasLayer}.
 * @description
 * This constructor creates a Source object that collects traffic cameras from the supplied or created
 * {@link alk.service.TrafficCamerasService}.
 *
 * @param {alkx.TrafficCamerasSourceOptions=} opt_options
 * @constructor
 * @extends {ol.source.Vector}
 * @api
 */
alk.source.TrafficCamerasSource = function (opt_options) {
  /** @type {alkx.TrafficCamerasSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  var self = this;

  var optStrategy = options.strategy;
  var strategy;
  if (optStrategy !== undefined) {
    if (optStrategy instanceof alk.source.LoadStrategy) {
      this.loadStrategy_ = optStrategy;
    } else {
      strategy = optStrategy;
    }
  } else {
    this.loadStrategy_ = new alk.source.SubtractionLoadStrategy();
  }
  if (strategy === undefined && this.loadStrategy_ !== undefined) {
    strategy = function (extent, resolution) {
      return self.loadStrategy_.loadStrategy(extent, resolution);
    };
  }

  /** @type {olx.source.VectorOptions} */
  var opts = {
    url: function (extent, resolution, projection) {
      return self.featureLoadURLFunction(extent, resolution, projection);
    },
    strategy: strategy,
    format: new alk.format.TrafficCamerasJSON(),
    wrapX: options.wrapX
  };

  alk.source.TrafficCamerasSource.base(this, 'constructor', opts);

  if (options.trafficCamerasService !== undefined) {
    this.trafficCamerasService_ = /** @type {alk.service.TrafficCamerasService} */(options.trafficCamerasService);
  }
  if (this.trafficCamerasService_ == null) {
    this.trafficCamerasService_ = new alk.service.TrafficCamerasService(options.trafficCamerasServiceOptions);
  }

  this.baseOptions_ = {
    trafficCameraService: options.trafficCamerasService,
    TrafficCamerasServiceOptions: options.trafficCamerasServiceOptions
  };

};
goog.inherits(alk.source.TrafficCamerasSource, ol.source.Vector);

/**
 * @type {alk.service.TrafficCamerasService}
 * @private
 */
alk.source.TrafficCamerasSource.prototype.trafficCamerasService_;

/**
 * @returns {alk.service.TrafficCamerasService}
 * @this {alk.source.TrafficCamerasSource}
 * @api
 */
alk.source.TrafficCamerasSource.prototype.getTrafficCamerasService = function () {
  return this.trafficCamerasService_;
};

/**
 * @param {alk.service.TrafficCamerasService} service
 * @this {alk.source.TrafficCamerasSource}
 * @api
 */
alk.source.TrafficCamerasSource.prototype.setTrafficCamerasService = function (service) {
  this.trafficCamerasService_ = service;
  this.refresh();
};

/**
 * This method causes an entire refresh of this source. It does this by creating
 * a new TrafficCamerasService from the old one with the extended options.
 * @param {alkx.TrafficCamerasServiceOptions=} options
 * @this {alk.source.TrafficCamerasSource}
 * @api
 */
alk.source.TrafficCamerasSource.prototype.changeTrafficCamerasService = function (options) {
  var service = this.trafficCamerasService_;
  var opts = service.getServiceOptions(options);
  this.baseOptions_.trafficCamerasServiceOptions = opts;
  delete this.baseOptions_.trafficCamerasService;
  this.trafficCamerasService_ = new alk.service.TrafficCamerasService(opts);
  this.refresh();
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 * @this {alk.source.TrafficCamerasSource}
 * @return {string}
 */
alk.source.TrafficCamerasSource.prototype.featureLoadURLFunction = function (extent, resolution, projection) {
  var bl = ol.proj.toLonLat(ol.extent.getBottomLeft(extent));
  var tr = ol.proj.toLonLat(ol.extent.getTopRight(extent));
  var bbox = [].concat(bl).concat(tr);
  // The service doesn't work with EPSG:3857
  var url = this.getTrafficCamerasService().getURL({
    boundingBox: bbox,
    srs: alk.val.SRS.EPSG4326
  });
  return url;
};

/**
 * This attribute contains the options with which the TrafficCamerasSource was created.
 * @type {Object.<string,*>}
 * @private
 */
alk.source.TrafficCamerasSource.prototype.baseOptions_;

/**
 * This method removes all features from this source.
 *
 * @param {Array.<ol.Feature>} features
 * @this {alk.source.TrafficCamerasSource}
 * @api
 */
alk.source.TrafficCamerasSource.prototype.removeAllFeatures = function (features) {
  for(var i = 0; i < features.length; i++) {
    this.removeFeature(features[i]);
  }
};

/**
 * @override
 * @this {alk.source.TrafficCamerasSource}
 */
alk.source.TrafficCamerasSource.prototype.refresh = function () {
  // If we are going to refresh, we need a new strategy, because it's keeping
  // track of what we've loaded.
  if (this.loadStrategy_ instanceof alk.source.SubtractionLoadStrategy) {
    this.loadStrategy_ = new alk.source.SubtractionLoadStrategy();
  }
  this.clear();
};

/**
 * This function returns the current state of traffic cameras received by this source.
 * This function just returns the associated traffic camera with each feature
 * currently residing in this source.
 *
 * ### NOTE ###
 *
 * This returns the immediate current state of the source. If the source is in the
 * process of updating, which could be from user interaction, such as a zoom in or out,
 * the result may not be stable.
 *
 * One may wait until the source's state, i.e. ``getState``, is in the ol.source.State.READY
 * state, as opposed to ol.source.State.LOADING. However, that condition is not really
 * guaranteed at any given point in time, unless other precautions are taken.
 *
 * If one desires a more stable result, use the {@link alk.service.TrafficCamerasService#get}
 * call with a specific pt1 and pt2 parameters defining the desired extent.
 *
 * @return {Array.<alkx.TrafficCameraSpec>}
 * @this {alk.source.TrafficCamerasSource}
 * @api
 */
alk.source.TrafficCamerasSource.prototype.getTrafficCameras = function () {
  var results = [];
  this.getFeatures().forEach(function(feature) {
    var trafficCamera = feature.get('trafficCamera');
    if (trafficCamera) {
      results.push(trafficCamera);
    }
  });
  return results;
};
goog.provide('alk.layer.TrafficCamerasLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.style.TrafficCamerasLayerStyle');
goog.require('alk.source.TrafficCamerasSource');

goog.require('alkx.TrafficCamerasLayerOptions');

/**
 * @classdesc
 * An instance of this class provides a layer that may lookup a traffic cameras within
 * the given extent, using the ALK TrafficCameras Service, and display them.
 *
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @description
 * This constructor creates a layer that gets data from ALK Traffic Cameras Service
 * and displays them with markers and popups on the map.
 *
 * All visual representation is handled by the 'style' option.
 * As a default, the {@link alk.style.TrafficCamerasLayerStyle} is used, which
 * as a default draws TrafficCameras according to their category.
 *
 * @param {alkx.TrafficCamerasLayerOptions=} opt_options
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.TrafficCamerasLayer = function (opt_options) {
  /** @type {alkx.TrafficCamerasLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var style = this.processStyle(options.style);

  var source = options.source;

  if (source === undefined) {
    source = new alk.source.TrafficCamerasSource({
      trafficCamerasServiceOptions: options.trafficCamerasServiceOptions
    });
  }
  // We save these on the object so we can have them for changeStyle.
  this.layerOptions_ = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting
  };
  alk.layer.TrafficCamerasLayer.base(this, 'constructor', this.layerOptions_);
};
goog.inherits(alk.layer.TrafficCamerasLayer, ol.layer.Vector);

/**
 * This attribute contains the TrafficCameraLayerStyle that was either assigned
 * or created for this TrafficCamerasLayer.
 * @type {alk.style.TrafficCamerasLayerStyle}
 * @private
 */
alk.layer.TrafficCamerasLayer.prototype.trafficCamerasLayerStyle;

/**
 * This function returns the TrafficCameraLayerStyle that was either assigned or
 * created for this TrafficCamerasLayer.
 * @returns {alk.style.TrafficCamerasLayerStyle|undefined}
 * @this {alk.layer.TrafficCamerasLayer}
 * @api
 */
alk.layer.TrafficCamerasLayer.prototype.getTrafficCameraLayerStyle = function () {
  return this.trafficCamerasLayerStyle;
};

/**
 * This function assigns or creates the TrafficCameraLayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.TrafficCamerasLayerStyle|alk.style.StrokeQueue|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.TrafficCamerasLayer}
 * @protected
 */
alk.layer.TrafficCamerasLayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.TrafficCamerasLayerStyle) {
      self.trafficCamerasLayerStyle = optStyle;
      style = function (feature, resolution) {
        return self.trafficCamerasLayerStyle.styleFunction(feature, resolution);
      };
    } else {
      // We just go with the supplied style.
      style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
    }
  } else {
    if (this.trafficCamerasLayerStyle === undefined) {
      this.trafficCamerasLayerStyle = new alk.style.TrafficCamerasLayerStyle();
    }
    style = function (feature, resolution) {
      return self.trafficCamerasLayerStyle.styleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function sets the Style for this layer.
 * @override
 * @param {alk.style.TrafficCamerasLayerStyle|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @this {alk.layer.TrafficCamerasLayer}
 * @api
 */
alk.layer.TrafficCamerasLayer.prototype.setStyle = function (optStyle) {
  var style = this.processStyle(optStyle);
  alk.layer.TrafficCamerasLayer.base(this, 'setStyle', style);
};
goog.provide('alk.style.TrafficIncidentsLayerStyle');

goog.require('alk.style');

/**
 * @classdesc
 * An instance of this class provides a styling function for the Traffic Incidents Layer.
 * @description
 * This constructor creates a Style Function for stying incidents in the Traffic Incidents Layers.
 * @constructor
 * @extends {ol.Object}
 * @api
 */
alk.style.TrafficIncidentsLayerStyle = function () {
  alk.style.TrafficIncidentsLayerStyle.base(this, 'constructor');
};
goog.inherits(alk.style.TrafficIncidentsLayerStyle, ol.Object);

/**
 * @type {string}
 * @api
 */
alk.style.TrafficIncidentsLayerStyle.prototype.defaultIconURL;

/**
 * This function returns the URL to be used for the traffic incident of the given feature.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {string}
 */
alk.style.TrafficIncidentsLayerStyle.prototype.getIconURL = function (feature, resolution) {
  // TODO: Generalize these icon locations.
  var trafficIncident = /** @type {alkx.TrafficIncidentSpec} */(feature.get('trafficIncident'));
  var category = trafficIncident.EventCategory;
  switch(category){
    case 'Traffic':
      return 'http://maps.alk.com/api/1.2/img/traffic_map_trafficjam.png';
    case 'Accident':
      return 'http://maps.alk.com/api/1.2/img/traffic_map_accident.png';
    case 'Weather':
      return 'http://maps.alk.com/api/1.2/img/traffic_map_weather.png';
    case 'Roadworks':
      return 'http://maps.alk.com/api/1.2/img/traffic_map_construction.png';
    case 'Default':
      return 'http://maps.alk.com/api/1.2/img/traffic_map_incident.png';
    default:
      return 'http://maps.alk.com/api/1.2/img/traffic_map_incident.png';
  }
};

/**
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @return {ol.style.Style}
 * @protected
 * @this {alk.style.TrafficIncidentsLayerStyle}
 */
alk.style.TrafficIncidentsLayerStyle.prototype.getIconStyle = function (feature, resolution) {
  var url;

  if (feature.get('trafficIncident')) {
    url = this.getIconURL(feature, resolution) || this.defaultURL_;
    return new ol.style.Style({
      image: new ol.style.Icon({
        src: url
      })
    });
  }

  // We may be clustering.
  /** @type {Array.<ol.Feature>} */
  var features = /** @type {Array.<ol.Feature>} */(feature.get('features'));
  if (features) {
    if (features.length === 1) {
      if (features[0].get('trafficIncident')) {
        url = this.getIconURL(features[0], resolution) || this.defaultURL_;
        return new ol.style.Style({
          image: new ol.style.Icon({
            src: url
          })
        });
      }
    } else {
      var text = '' + features.length;
      var textStyle = new ol.style.Text({
        font: '11px',
        text: text,
        textAlign: 'center',
        fill: new ol.style.Fill({
          color: 'black'
        })
      });
      var circle = new ol.style.Circle({
        radius: 11,
        fill: new ol.style.Fill({
          color: 'white',
          opacity: 1.0
        }),
        stroke: new ol.style.Stroke({
          color: 'orange',
          width: 3
        })
      });
      return new ol.style.Style({
        image: circle,
        text: textStyle
      });
    }
  }
  return null;
};

/**
 * This function provides the styleFunction for the Traffic Incidents Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @this {alk.style.TrafficIncidentsLayerStyle}
 * @api
 */
alk.style.TrafficIncidentsLayerStyle.prototype.styleFunction = function(feature, resolution) {
  var style = this.getIconStyle(feature, resolution);
  if (style) {
    return [style];
  } else {
    var extent = feature.get('extent');
    if (extent) {
      var styleE = new ol.style.Style({
        fill: new ol.style.Fill({
          color: "rgba(184,074,000,0.1)"
        }),
        stroke: new ol.style.Stroke({
          color: "white",
          width: 2
        })
      });
      return [styleE];
    }
  }
  return [];
};
goog.provide('pcmws.api.TrafficIncidentsService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.BoundingBox');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.Language');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.TrafficIncidentsServiceOptions');
goog.require('pcmws.api.TrafficIncidentsURL');


/**
 * @param {pcmws.api.TrafficIncidentsServiceOptions=} opt_options Options
 * @constructor
 * @extends {pcmws.api.StaticService}
 *
 */
pcmws.api.TrafficIncidentsService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['language', pcmws.api.Language],
    ['boundingBox', pcmws.api.BoundingBox]
  ];
  pcmws.api.TrafficIncidentsService.base(this, 'constructor', specs, opt_options);

  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.TrafficIncidentsURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.TrafficIncidentsService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.TrafficIncidentsService}
 * @returns {pcmws.api.TrafficIncidentsService}
 */
pcmws.api.TrafficIncidentsService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.TrafficIncidentsServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.TrafficIncidentsService(opts);
};
goog.provide('alk.service.TrafficIncidentsService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.TrafficIncidentsService');

goog.require('alkx.TrafficIncidentsServiceOptions');
goog.require('alkx.TrafficIncidentsServiceResponse');
goog.require('alkx.TrafficIncidentSpec');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Traffic Incidents Service.
 * @description
 * This constructor creates a Service object with which to access the ALK
 * Traffic Incidents Service.
 *
 * @param {alkx.TrafficIncidentsServiceOptions=} opt_options If defined, these options are used to make
 *        the base Traffic Incidents Service object. Calls to {@link alk.service.TrafficIncidentsService#get} and
 *        {@link alk.service.TrafficIncidentsService#getServiceOptions} on this object will take options
 *        and override and extend what is set here.
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.TrafficIncidentsService = function (opt_options) {
  alk.service.TrafficIncidentsService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.trafficIncidentService = this.pcmws = new pcmws.api.TrafficIncidentsService(this.pcmServiceOptions);
};
goog.inherits(alk.service.TrafficIncidentsService, alk.service.Service);

/**
 * @description
 * The ALK Traffic Incidents Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.TrafficIncidentsService} object.
 *
 * @type {pcmws.api.TrafficIncidentsService}
 */
alk.service.TrafficIncidentsService.prototype.trafficIncidentService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from Traffic Incidents Service returns a JSON object
 * containing a single {@link alkx.TrafficIncidentSpec}.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.TrafficIncidentsService}.
 * @param {Object} obj The JSON response from the {@link alk.service.TrafficIncidentsService}.
 * @returns {Object} Containing the TrafficIncidentsServiceOptions and if a successful call
 *  also contains a JSON object containing the incidents requested.
 * @override
 * @api
 */
alk.service.TrafficIncidentsService.prototype.processResponse = function (options, obj) {
  return {
    trafficIncidentsServiceOptions: /** @type {alkx.TrafficIncidentsServiceOptions} */(options),
    result: /** @type {Array.<alkx.TrafficIncidentSpec>} */(obj)
  };
};

/**
 * @description
 * This method performs a call to the Traffic Incidents Service to return incidents.
 * @param {(alkx.TrafficIncidentsServiceOptions|null|function(alkx.TrafficIncidentsServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.TrafficIncidentsServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.TrafficIncidentsService}
 * @api
 */
alk.service.TrafficIncidentsService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.TrafficIncidentsServiceOptions} */
  var options = {};
  /** function(alkx.TrafficIncidentsServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.TrafficIncidentsServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.TrafficIncidentsService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.source.TrafficIncidentsSource');

goog.require('alk');
goog.require('alk.format.TrafficIncidentsJSON');
goog.require('alk.service.TrafficIncidentsService');
goog.require('alk.source');
goog.require('alk.source.SubtractionLoadStrategy');
goog.require('alk.val.SRS');

goog.require('alkx.TrafficIncidentsSourceOptions');

/**
 * @classdesc
 * An instance of this class provides a 'source' for the {@link alk.layer.TrafficIncidentsLayer}.
 * @description
 * This constructor creates a Source object that collects traffic incidents from the supplied or created
 * {@link alk.service.TrafficIncidentsService}.
 *
 * @param {alkx.TrafficIncidentsSourceOptions=} opt_options
 * @constructor
 * @extends {ol.source.Vector}
 * @api
 */
alk.source.TrafficIncidentsSource = function (opt_options) {
  /** @type {alkx.TrafficIncidentsSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  var self = this;

  var optStrategy = options.strategy;
  var strategy;
  if (optStrategy !== undefined) {
    if (optStrategy instanceof alk.source.LoadStrategy) {
      this.loadStrategy_ = optStrategy;
    } else {
      strategy = optStrategy;
    }
  } else {
    this.loadStrategy_ = new alk.source.SubtractionLoadStrategy();
  }
  if (strategy === undefined && this.loadStrategy_ !== undefined) {
    strategy = function (extent, resolution) {
      return self.loadStrategy_.loadStrategy(extent, resolution);
    };
  }

  /** @type {olx.source.VectorOptions} */
  var opts = {
    url: function (extent, resolution, projection) {
      return self.featureLoadURLFunction(extent, resolution, projection);
    },
    strategy: strategy,
    format: new alk.format.TrafficIncidentsJSON(),
    wrapX: options.wrapX
  };

  alk.source.TrafficIncidentsSource.base(this, 'constructor', opts);

  if (options.trafficIncidentsService !== undefined) {
    this.trafficIncidentsService_ = /** @type {alk.service.TrafficIncidentsService} */(options.trafficIncidentsService);
  }
  if (this.trafficIncidentsService_ == null) {
    this.trafficIncidentsService_ = new alk.service.TrafficIncidentsService(options.trafficIncidentsServiceOptions);
  }

  this.baseOptions_ = {
    trafficIncidentService: options.trafficIncidentsService,
    TrafficIncidentsServiceOptions: options.trafficIncidentsServiceOptions
  };

};
goog.inherits(alk.source.TrafficIncidentsSource, ol.source.Vector);

/**
 * @type {alk.service.TrafficIncidentsService}
 * @private
 */
alk.source.TrafficIncidentsSource.prototype.trafficIncidentsService_;

/**
 * @returns {alk.service.TrafficIncidentsService}
 * @this {alk.source.TrafficIncidentsSource}
 * @api
 */
alk.source.TrafficIncidentsSource.prototype.getTrafficIncidentsService = function () {
  return this.trafficIncidentsService_;
};

/**
 * @param {alk.service.TrafficIncidentsService} service
 * @this {alk.source.TrafficIncidentsSource}
 * @api
 */
alk.source.TrafficIncidentsSource.prototype.setTrafficIncidentsService = function (service) {
  this.trafficIncidentsService_ = service;
  this.refresh();
};

/**
 * This method causes an entire refresh of this source. It does this by creating
 * a new TrafficIncidentsService from the old one with the extended options.
 * @param {alkx.TrafficIncidentsServiceOptions=} options
 * @this {alk.source.TrafficIncidentsSource}
 * @api
 */
alk.source.TrafficIncidentsSource.prototype.changeTrafficIncidentsService = function (options) {
  var service = this.trafficIncidentsService_;
  var opts = service.getServiceOptions(options);
  this.baseOptions_.trafficIncidentsServiceOptions = opts;
  delete this.baseOptions_.trafficIncidentsService;
  this.trafficIncidentsService_ = new alk.service.TrafficIncidentsService(opts);
  this.refresh();
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 * @this {alk.source.TrafficIncidentsSource}
 * @return {string}
 */
alk.source.TrafficIncidentsSource.prototype.featureLoadURLFunction = function (extent, resolution, projection) {
  var bl = ol.proj.toLonLat(ol.extent.getBottomLeft(extent));
  var tr = ol.proj.toLonLat(ol.extent.getTopRight(extent));
  var bbox = [].concat(bl).concat(tr);
  // The service doesn't work with EPSG:3857
  var url = this.getTrafficIncidentsService().getURL({
    boundingBox: bbox,
    srs: alk.val.SRS.EPSG4326
  });
  return url;
};

/**
 * This attribute contains the options with which the TrafficIncidentsSource was created.
 * @type {Object.<string,*>}
 * @private
 */
alk.source.TrafficIncidentsSource.prototype.baseOptions_;

/**
 * This method removes all features from this source.
 *
 * @param {Array.<ol.Feature>} features
 * @this {alk.source.TrafficIncidentsSource}
 * @api
 */
alk.source.TrafficIncidentsSource.prototype.removeAllFeatures = function (features) {
  for(var i = 0; i < features.length; i++) {
    this.removeFeature(features[i]);
  }
};

/**
 * @override
 * @this {alk.source.TrafficIncidentsSource}
 */
alk.source.TrafficIncidentsSource.prototype.refresh = function () {
  // If we are going to refresh, we need a new strategy, because it's keeping
  // track of what we've loaded.
  if (this.loadStrategy_ instanceof alk.source.SubtractionLoadStrategy) {
    this.loadStrategy_ = new alk.source.SubtractionLoadStrategy();
  }
  this.clear();
};

/**
 * This function returns the current state of traffic incidents received by this source.
 * This function just returns the associated traffic incident with each feature
 * currently residing in this source.
 *
 * ### NOTE ###
 *
 * This returns the immediate current state of the source. If the source is in the
 * process of updating, which could be from user interaction, such as a zoom in or out,
 * the result may not be stable.
 *
 * One may wait until the source's state, i.e. ``getState``, is in the ol.source.State.READY
 * state, as opposed to ol.source.State.LOADING. However, that condition is not really
 * guaranteed at any given point in time, unless other precautions are taken.
 *
 * If one desires a more stable result, use the {@link alk.service.TrafficIncidentsService#get}
 * call with a specific pt1 and pt2 parameters defining the desired extent.
 *
 * @return {Array.<alkx.TrafficIncidentSpec>}
 * @this {alk.source.TrafficIncidentsSource}
 * @api
 */
alk.source.TrafficIncidentsSource.prototype.getTrafficIncidents = function () {
  var results = [];
  this.getFeatures().forEach(function(feature) {
    var trafficIncident = feature.get('trafficIncident');
    if (trafficIncident) {
      results.push(trafficIncident);
    }
  });
  return results;
};
goog.provide('alk.layer.TrafficIncidentsLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.style.TrafficIncidentsLayerStyle');
goog.require('alk.source.TrafficIncidentsSource');

goog.require('alkx.TrafficIncidentsLayerOptions');

/**
 * @classdesc
 * An instance of this class provides a layer that may lookup a traffic incidents within
 * the given extent, using the ALK TrafficIncidents Service, and display them.
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @description
 * This constructor creates a layer that gets data from ALK Traffic Incident Service
 * and displays them with markers and popups on the map.
 *
 * All visual representation is handled by the 'style' option.
 * As a default, the {@link alk.style.TrafficIncidentsLayerStyle} is used, which
 * as a default draws TrafficIncidents according to their category.
 *
 * @param {alkx.TrafficIncidentsLayerOptions=} opt_options
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.TrafficIncidentsLayer = function (opt_options) {
  /** @type {alkx.TrafficIncidentsLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var style = this.processStyle(options.style);

  var source = options.source;

  if (source === undefined) {
    source = new alk.source.TrafficIncidentsSource({
      trafficIncidentsServiceOptions: options.trafficIncidentsServiceOptions
    });
  }
  // We save these on the object so we can have them for changeStyle.
  this.layerOptions_ = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting,
    zIndex: options.zIndex
  };
  alk.layer.TrafficIncidentsLayer.base(this, 'constructor', this.layerOptions_);
};
goog.inherits(alk.layer.TrafficIncidentsLayer, ol.layer.Vector);

/**
 * This attribute contains the TrafficIncidentLayerStyle that was either assigned
 * or created for this TrafficIncidentsLayer.
 * @type {alk.style.TrafficIncidentsLayerStyle}
 * @private
 */
alk.layer.TrafficIncidentsLayer.prototype.trafficIncidentsLayerStyle;

/**
 * This function returns the TrafficIncidentLayerStyle that was either assigned or
 * created for this TrafficIncidentsLayer.
 * @returns {alk.style.TrafficIncidentsLayerStyle|undefined}
 * @this {alk.layer.TrafficIncidentsLayer}
 * @api
 */
alk.layer.TrafficIncidentsLayer.prototype.getTrafficIncidentLayerStyle = function () {
  return this.trafficIncidentsLayerStyle;
};

/**
 * This function assigns or creates the TrafficIncidentLayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.TrafficIncidentsLayerStyle|alk.style.StrokeQueue|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.TrafficIncidentsLayer}
 * @protected
 */
alk.layer.TrafficIncidentsLayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.TrafficIncidentsLayerStyle) {
      self.trafficIncidentsLayerStyle = optStyle;
      style = function (feature, resolution) {
        return self.trafficIncidentsLayerStyle.styleFunction(feature, resolution);
      };
    } else {
      // We just go with the supplied style.
      style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
    }
  } else {
    if (this.trafficIncidentsLayerStyle === undefined) {
      this.trafficIncidentsLayerStyle = new alk.style.TrafficIncidentsLayerStyle();
    }
    style = function (feature, resolution) {
      return self.trafficIncidentsLayerStyle.styleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function sets the Style for this layer.
 * @override
 * @param {alk.style.TrafficIncidentsLayerStyle|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @this {alk.layer.TrafficIncidentsLayer}
 * @api
 */
alk.layer.TrafficIncidentsLayer.prototype.setStyle = function (optStyle) {
  var style = this.processStyle(optStyle);
  alk.layer.TrafficIncidentsLayer.base(this, 'setStyle', style);
};
goog.provide('pcmws.api.TrafficTileService');


goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.HistDay');
goog.require('pcmws.api.HistTimeBin');
goog.require('pcmws.api.HistTimeZone');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.NATrafficTileURL');
goog.require('pcmws.api.PenWidth');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.StrokeWidth');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.TrafficTileServiceOptions');
goog.require('pcmws.api.TrafficTileURL');
goog.require('pcmws.api.Width');
goog.require('pcmws.api.X');
goog.require('pcmws.api.Y');
goog.require('pcmws.api.Z');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the OpenLayers XYZ source layer for
 * PCMiler Traffic Tile service.
 * @param {pcmws.api.TrafficTileServiceOptions=} opt_options Options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.TrafficTileService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['drawerGroups', pcmws.api.DrawerGroups],
    ['format', pcmws.api.Format],
    ['imgOption', pcmws.api.ImgOption],
    ['imgSrc', pcmws.api.ImgSrc],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['style', pcmws.api.Style],
    ['width', pcmws.api.Width],
    ['height', pcmws.api.Height],
    ['histDay', pcmws.api.HistDay],
    ['histTimeBin', pcmws.api.HistTimeBin],
    ['histTimeZone', pcmws.api.HistTimeZone],
    ['strokeWidth', pcmws.api.StrokeWidth],
    ['penWidth', pcmws.api.PenWidth],
    ['x', pcmws.api.X, '{x}'],
    ['y', pcmws.api.Y, '{y}'],
    ['z', pcmws.api.Z, '{z}']
  ];
  pcmws.api.TrafficTileService.base(this, 'constructor', specs, opt_options);
  /** @type {pcmws.api.TrafficTileServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.TrafficTileURL(options.hostURL, options.path);
  // We get traffic data from different places based on Region.
  if (!this.region || this.region.getValue() === pcmws.val.Region.NA) {
    this.serviceURL_ = new pcmws.api.NATrafficTileURL(options.hostURL, options.path);
  }
};
goog.inherits(pcmws.api.TrafficTileService, pcmws.api.StaticService);

/**
 * @override
 * @this {pcmws.api.TrafficTileService}
 * @returns {pcmws.api.TrafficTileService}
 */
pcmws.api.TrafficTileService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.TrafficTileServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.TrafficTileService(opts);
};

/**
 * @inheritDoc
 * @this {pcmws.api.TrafficTileService}
 */
pcmws.api.TrafficTileService.prototype.getAttribution = function(opts_or_callback, responseCallback) {
  var options = {};
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    options = opts_or_callback;
    callback = responseCallback;
  }
  this.processOptions(options);
  var result;
  if (!this.region || this.region.getValue() === pcmws.val.Region.NA) {
    result = {
      text: "Traffic by ",
      image: 'https://maps.alk.com/api/1.2/img/inrix-logo.png'
    };
  } else {
    result = {
      text: 'Traffic Data: $copy; 2017',
      url: 'https://maps.alk.com/Account/TrafficDatadisclaimer/'
    };
  }
  callback.call(this, result);
};
goog.provide('alk.service.TrafficTileService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.TrafficTileService');

goog.require('alkx.ServiceOptions');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults, generates a URL for the
 * ALK Traffic Tile Web Service.
 * @description
 * This constructor creates a Service object with which to access the ALK Traffic Tiles
 * Web Service. It is used in generating the URL according to is given options.
 *
 * @param {alkx.ServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.TrafficTileService = function (opt_options) {
  alk.service.TrafficTileService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.trafficTileService = this.pcmws = new pcmws.api.TrafficTileService(this.pcmServiceOptions);
};
goog.inherits(alk.service.TrafficTileService, alk.service.Service);

/**
 * @description
 * The ALK Traffic Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.TrafficTileService} object.
 *
 * @type {pcmws.api.TrafficTileService}
 */
alk.service.TrafficTileService.prototype.trafficTileService;
goog.provide('alk.source.TrafficSource');

goog.require('alk.ATTRIBUTION');
goog.require('alk.service.TrafficTileService');
goog.require('alk.source.ImageTileSource');

goog.require('alkx.TrafficSourceOptions');
goog.require('alkx.TrafficServiceOptions');

/**
 * @classdesc
 * An instance of this class holds the source for an ALK Traffic Source that is used
 * in the {@link alk.layer.TrafficLayer}.
 * @description
 * This constructor creates a Source object for retrieving data from the ALK
 * Traffic Service.
 *
 * It is an {@link ol.source.Tile} source that uses the ALK Traffic Service.
 *
 * @param {alkx.TrafficSourceOptions=} opt_options
 * @extends {alk.source.ImageTileSource}
 * @constructor
 * @api
 */
alk.source.TrafficSource = function (opt_options) {
  /** @type {alkx.TrafficSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.TrafficServiceOptions} */
  var serviceOptions = options.serviceOptions !== undefined ? options.serviceOptions : {};

  var service = new alk.service.TrafficTileService(serviceOptions);

  var attributions;
  if (options.attributions !== undefined) {
    attributions = options.attributions;
  }

  alk.source.TrafficSource.base(this, 'constructor', {
    attributions: attributions,
    service: service,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    //logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileSize: options.tileSize,
    tileUrlFunction: options.tileUrlFunction,
    wrapX: options.wrapX,
    transition: options.transition
  });
};
goog.inherits(alk.source.TrafficSource, alk.source.ImageTileSource);

/**
 * @override
 * @param {alkx.AttributionJSON=} attributionJSON
 * @this {alk.source.TrafficSource}
 */
alk.source.TrafficSource.prototype.processAttributionResponse = function(attributionJSON) {
  /** @type {ol.AttributionLike} */
  var attribution;
  if (attributionJSON) {
    var url = attributionJSON.url;
    var image = attributionJSON.image;
    attribution = 'Traffic from <a href="'+url+'" target="_blank"><img src="'+image+'"></a>';
  } else {
    attribution = alk.ATTRIBUTION;
  }
  this.setAttributions([attribution]);
};
goog.provide('alk.layer.TrafficLayer');

goog.require('alk.layer');
goog.require('alk.source.TrafficSource');
goog.require('alk.layer.ImageTileLayer');

goog.require('alkx.TrafficLayerOptions');
goog.require('alkx.TrafficSourceOptions');

/**
 * @classdesc
 * An instance of this class is to be used for the traffic
 * layer in an {@link ol.Map}, which is normally placed above a
 * base map layer.It uses a {@link ol.source.Tile} source that is
 * specific to the ALK Traffic Tile Service.
 *
 * @description
 * This constructor creates a layer that gets data from the ALK Traffic
 * Tile Service.
 *
 * @param {alkx.TrafficLayerOptions=} opt_options
 * @extends {alk.layer.ImageTileLayer}
 * @constructor
 * @api
 */
alk.layer.TrafficLayer = function(opt_options) {
  /** @type {alkx.TrafficLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.TrafficSourceOptions} */
  var sourceOptions = options.sourceOptions !== undefined ? options.sourceOptions : {};

  var source = new alk.source.TrafficSource({
    serviceOptions: sourceOptions.serviceOptions,
    cacheSize: sourceOptions.cacheSize,
    crossOrigin: sourceOptions.crossOrigin,
    opaque: sourceOptions.opaque,
    projection: sourceOptions.projection,
    reprojectionErrorThreshold: sourceOptions.reprojectionErrorThreshold,
    maxZoom: sourceOptions.maxZoom,
    minZoom: sourceOptions.minZoom,
    tileGrid: sourceOptions.tileGrid,
    tileLoadFunction: sourceOptions.tileLoadFunction,
    tilePixelRatio: sourceOptions.tilePixelRatio,
    tileSize: sourceOptions.tileSize,
    tileUrlFunction: sourceOptions.tileUrlFunction,
    wrapX: sourceOptions.wrapX,
    transition: sourceOptions.transition
  });

  alk.layer.TrafficLayer.base(this, 'constructor',  {
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError
  });
};
goog.inherits(alk.layer.TrafficLayer, alk.layer.ImageTileLayer);
goog.provide('pcmws.api.PolygonsCountyService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.CountyCodes');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.PolygonsCountyServiceOptions');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.StaticService');


/**
 * The PolygonsCounty service, which retrieves polygons for FIPS codes.
 * @param {pcmws.api.PolygonsCountyServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.PolygonsCountyService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region],
    ['codes', pcmws.api.CountyCodes]
  ];
  pcmws.api.PolygonsCountyService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.PolygonsCountyServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.PolygonsCountyURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.PolygonsCountyService, pcmws.api.StaticService);

/**
 * @override
 * @returns {pcmws.api.PolygonsCountyService}
 * @this {pcmws.api.PolygonsCountyService}
 */
pcmws.api.PolygonsCountyService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.PolygonsCountyServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.PolygonsCountyService(opts);
};
goog.provide('alk.service.PolygonsCountyService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.PolygonsCountyService');

goog.require('alkx.PolygonsCountyServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the PCM PolygonsCountyService.
 * @description
 * This constructor creates a Service object to access the ALK PC Miler
 * Polygons County Service.
 * @param {alkx.PolygonsCountyServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.PolygonsCountyService = function (opt_options) {
  alk.service.PolygonsCountyService.base(this, 'constructor', opt_options);
  this.pcmServiceOptions = this.getPCMServiceOptions(opt_options);
  this.polygonsCountyService = this.pcmws = new pcmws.api.PolygonsCountyService(this.pcmServiceOptions);
};
goog.inherits(alk.service.PolygonsCountyService, alk.service.Service);

/**
 * @description
 * The ALK Polygons County Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.PolygonsCountyService} object.
 *
 * @type {pcmws.api.PolygonsCountyService}
 */
alk.service.PolygonsCountyService.prototype.polygonsCountyService;

/**
 * @description
 * This function performs a request for a {@link alkx.PolygonsCountyServiceResponse} from
 * the options and defaults set on this {@link alk.service.PolygonsCountyService} object.
 *
 * The response is handled by a asynchronous callback.
 *
 * @param {(alkx.PolygonsCountyServiceOptions|null|
 *     function(alkx.PolygonsCountyServiceResponse))=} opts_or_callback
 *     Options override, if not the callback.
 * @param {function(alkx.PolygonsCountyServiceResponse)=} responseCallback
 *     The callback that handles the response.
 * @override
 * @this {alk.service.PolygonsCountyService}
 * @api
 */
alk.service.PolygonsCountyService.prototype.get = function(opts_or_callback, responseCallback) {
  /** @type {alkx.PolygonsCountyServiceOptions} */
  var options = {};
  /** function(alkx.PolygonsCountyServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.PolygonsCountyServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.PolygonsCountyService.base(this, 'get', downcastOptions, downcastCallback);
};



/**
 * @inheritDoc
 */
alk.service.PolygonsCountyService.prototype.processResponse = function(options, obj) {
  return {
    polygonsCountyServiceOptions: options,
    result: obj
  };
};
goog.provide('alk.source.PolygonsCountyCache');

goog.require('alk.service.PolygonsCountyService');

goog.require('alkx.PolygonCounty');

/**
 * @classdesc
 * This class provides a request cache around the PolygonsCountyService.
 * This object is used within the {@link alk.source.WeatherAlertsSource}
 * implementation.
 *
 * @description
 * This constructor creates a utility object for the Weather Alerts service
 * which caches Polygons as they are common among weather alerts.
 *
 * When a WeatherAlert becomes available, the source extracts its polygon.
 * If the WeatherAlert.Polygon property is null, then the polygons are
 * extracted from the WeatherAlert.FipsCodes property, which contains
 * a space delimited list of 5 digit codes that name counties.
 *
 * The following procedure is implemented.
 * <pre>
 *    var pgc = cache.getPolygonForCountyCode(code);
 *    if (pgc == null) {
 *       cache.queueCountyCode(code, future);
 *    }
 * </pre>
 * Where `future` is a function that will be called when the polygon
 * for that code becomes available.
 * And after processing all weather alerts, the source will call
 * <pre>
 *         cache.processQueue();
 * </pre>
 * The processQueue function will call send out requests to the
 * PolygonsCountyService to retrieve the polygons and process them
 * when they come in.
 *
 * @param {alkx.PolygonsCountyCacheOptions=} opt_options
 * @constructor
 * @api
 */
alk.source.PolygonsCountyCache = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  if (options.polygonsCountyService !== undefined) {
    this.polygonsCountyService_ = options.polygonsCountyService;
  }
  if (this.polygonsCountyService_ == null) {
    this.polygonsCountyService_ = new alk.service.PolygonsCountyService(options.polygonsCountyServiceOptions);
  }
  this.cache_ = {};
  this.requests_ = {};
  this.requestIds_ = 0;
};

/**
 * This property contains the limit of the number of polygons to request.
 * The current service limit is 200;
 * @type {number}
 */
alk.source.PolygonsCountyCache.prototype.polygonCountyServiceLimit = 200;

/**
 * @type {alk.service.PolygonsCountyService}
 * @private
 */
alk.source.PolygonsCountyCache.prototype.polygonsCountyService_;

/**
 * @type {Object.<string, alkx.PolygonCounty>}
 * @private
 */
alk.source.PolygonsCountyCache.prototype.cache_;

/**
 * This property holds the codes to request and is mapped to a future.
 * When the code is loaded, the future is called with the polygon.
 * @type {Object.<string, Array<function(alkx.PolygonCounty)>>}
 * @private
 */
alk.source.PolygonsCountyCache.prototype.requests_;

/**
 * This property is the request id generator for the polygons service. It is an
 * increment counter.
 * @type {number}
 * @private
 */
alk.source.PolygonsCountyCache.prototype.requestIds_;

/**
 * This method returns a polygon response structure for the code.
 * It may return undefined if there is none in the cache.
 *
 * @param {string} code
 * @return {alkx.PolygonCounty|undefined}
 * @this {alk.source.PolygonsCountyCache}
 * @api
 */
alk.source.PolygonsCountyCache.prototype.getPolygonForCountyCode = function (code) {
  var obj = this.cache_[code];
  return obj;
};


/**
 * @description
 * This method queues a county code to be requested when {@link alk.source.PolygonsCountyCache#processQueue}
 * is called. This method is called after getPolygonForCountyCode returns null or undefined;
 *
 * @param {string} code The FIPS code
 * @param {function(alkx.PolygonCounty)} future Function to be called when code is loaded.
 * @this {alk.source.PolygonsCountyCache}
 * @api
 */
alk.source.PolygonsCountyCache.prototype.queueCountyCode = function (code, future) {
  this.requests_[code] = (this.requests_[code] || []);
  this.requests_[code].push(future);
};

/**
 * This method makes requests to get polygons for the codes queued up since
 * the last call to this method. Since there is a size limit
 * on calls made to the server, this method may make more than one request to get
 * all the codes. If there are no codes queued, then no request is made.
 *
 * When each code receives a polygon structure, its associated future is called.
 *
 * @param {Function=} complete Function is called to notify when all codes have been loaded.
 * @this {alk.source.PolygonsCountyCache}
 * @api
 */
alk.source.PolygonsCountyCache.prototype.processQueue = function (complete) {
  var self = this;
  var codesNeeded = Object.keys(/** @type{Object!} */(this.requests_));
  var futures = this.requests_;
  this.requests_ = {};

  // Since there is a limit on the number of FIPS codes in the request,
  // we must make several. This apparatus implements the method by which
  // to call complete after all requests have returned.

  var requests = {
    startTime: performance.now(),
    complete: complete,
    requestIds: {},
    responses: {}
  };

  // EMCA5 way to tell if an object is empty.
  function isEmpty(obj) {
    // noinspection LoopStatementThatDoesntLoopJS
    for(var i in obj) {return false;}
    return true;
  }

  // This function gets called at the response to each call in the
  // set of calls made. If we got the last one, we make the call
  // to complete.
  /**
   * @param {Object=} response
   */
  function allComplete (response) {
    var options = response.polygonsCountyServiceOptions;
    var requestId = options.requestId;
    requests.responses[requestId] = response;
    delete requests.requestIds[requestId];
    if (isEmpty(requests.requestIds)) {
      var endTime = performance.now();
      console.log("All codes have been retrieved in " + (endTime - requests.startTime) + "ms");
      requests.complete();
    }
  }

  // We will use this apparatus if we are given a complete function.
  var completeCallback = typeof complete === 'function' ? allComplete : function(o){};

  // Make requests. We can only make requests no more than a certain number of codes.
  var limit = this.polygonCountyServiceLimit;

  for(var i = 0; i*limit < codesNeeded.length; i++) {
    var codes = codesNeeded.slice(i*limit, (i+1)*limit);
    var requestId = this.requestIds_++;
    requests.requestIds[requestId] = codes;
    this.polygonsCountyService_.get({
      codes: codes,
      requestId: requestId
    }, function(response) {
      self.storeAndRespond_(futures, response, completeCallback);
    });
  }
};

/**
 * @param {Object.<string, Array.<function(alkx.PolygonCounty)>>} futuresMap
 * @param {alkx.PolygonsCountyServiceResponse|undefined} response
 * @param {function(Object=)} complete
 * @this {alk.source.PolygonsCountyCache}
 * @private
 */
alk.source.PolygonsCountyCache.prototype.storeAndRespond_ = function (futuresMap, response, complete) {
  var self = this;
  var startTime = performance.now();
  if (response) {
    var result = response.result;
    if (result && result instanceof Array) {
      result.forEach(function (pgc) {
        if (pgc && pgc.Polygon && pgc.Code) {
          self.cache_[pgc.Code] = pgc;
          var futures = futuresMap[pgc.Code];
          if (futures) {
            futures.forEach(function (future) {
              future(pgc);
            });
          }
        }
      });
    }
  }
  var endTime = performance.now();
  console.log("All futures have been completed in " + (endTime - startTime) + "ms");
  complete(response);
};
goog.provide('pcmws.api.WeatherAlertsService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Certainty');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.EndTime');
goog.require('pcmws.api.EventNames');
goog.require('pcmws.api.Point');
goog.require('pcmws.api.PT1');
goog.require('pcmws.api.PT2');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.Severity');
goog.require('pcmws.api.StartTime');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Urgency');
goog.require('pcmws.api.WeatherAlertsServiceOptions');


/**
 * The Weather Alerts Service service.
 *
 * The params of urgency, severity, and certainty, may contain "All".
 * However, the server generates a Bad Request if "All" is specified.
 * Each is left off the parameter list, in getParams, if they have the "All" value.
 *
 * @param {pcmws.api.WeatherAlertsServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.WeatherAlertsService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region],
    ['point', pcmws.api.Point],
    ['urgency', pcmws.api.Urgency],
    ['severity', pcmws.api.Severity],
    ['certainty', pcmws.api.Certainty],
    ['eventNames', pcmws.api.EventNames],
    ['startTime', pcmws.api.StartTime],
    ['endTime', pcmws.api.EndTime],
    ['pt1', pcmws.api.PT1],
    ['pt2', pcmws.api.PT2]
  ];
  pcmws.api.WeatherAlertsService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.WeatherAlertsServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.WeatherAlertsURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.WeatherAlertsService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.WeatherAlertsService}
 * @returns {pcmws.api.WeatherAlertsService}
 */
pcmws.api.WeatherAlertsService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.WeatherAlertsServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.WeatherAlertsService(opts);
};
goog.provide('alk.service.WeatherAlertsService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.WeatherAlertsService');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the PCM WeatherAlertsService.
 * @description
 * This constructor creates a Service object with which to access the
 * ALK Weather Alerts Service.
 *
 * @param {alkx.WeatherAlertsServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.WeatherAlertsService = function (opt_options) {
  alk.service.WeatherAlertsService.base(this, 'constructor', opt_options);
  this.pcmServiceOptions = this.getPCMServiceOptions(opt_options);
  this.weatherAlertsService = this.pcmws = new pcmws.api.WeatherAlertsService(this.pcmServiceOptions);
};
goog.inherits(alk.service.WeatherAlertsService, alk.service.Service);

/**
 * @description
 * The ALK Weather Alerts Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.WeatherAlertsService} object.
 *
 * @type {pcmws.api.WeatherAlertsService}
 */
alk.service.WeatherAlertsService.prototype.weatherAlertsService;

/**
 * @description
 * This function performs a request for a {@link alkx.WeatherAlertsServiceResponse} from
 * the options and defaults set on this {@link alk.service.WeatherAlertsService} object.
 *
 * The response is handled by a asynchronous callback.
 *
 * @param {(alkx.WeatherAlertsServiceOptions|null|
 *     function(alkx.WeatherAlertsServiceResponse))=} opts_or_callback
 *     Options override, if not the callback.
 * @param {function(alkx.WeatherAlertsServiceResponse)=} responseCallback
 *     The callback that handles the response.
 * @this {alk.service.WeatherAlertsService}
 * @override
 * @api
 */
alk.service.WeatherAlertsService.prototype.get = function(opts_or_callback, responseCallback) {
  /** @type {alkx.WeatherAlertsServiceOptions} */
  var options = {};
  /** function(alkx.WeatherAlertsServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.WeatherAlertsServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.WeatherAlertsService.base(this, 'get', downcastOptions, downcastCallback);
};

goog.provide('alk.source.WeatherAlertsSource');

goog.require('alk');
goog.require('alk.format.WeatherAlertsJSON');
goog.require('alk.source');
goog.require('alk.source.PolygonsCountyCache');
goog.require('alk.source.SubtractionLoadStrategy');
goog.require('alk.service.WeatherAlertsService');
goog.require('alk.val.SRS');

goog.require('alkx.WeatherAlertsSourceOptions');

/**
 * @classdesc
 * An instance of this class provides a 'source' for the {@link alk.layer.WeatherAlertsLayer}.
 * This source collects weather alerts from the supplied or created
 * {@link alk.service.WeatherAlertsService}.
 * @description
 * This constructor creates a Source object for Weather Alerts data.
 *
 * @param {alkx.WeatherAlertsSourceOptions=} opt_options
 * @constructor
 * @extends {ol.source.Vector}
 * @api
 */
alk.source.WeatherAlertsSource = function (opt_options) {
  /** @type {alkx.WeatherAlertsSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  var self = this;

  var optStrategy = options.strategy;
  var strategy;
  if (optStrategy !== undefined) {
    if (optStrategy instanceof alk.source.LoadStrategy) {
      this.loadStrategy_ = optStrategy;
    } else {
      strategy = optStrategy;
    }
  } else {
    this.loadStrategy_ = new alk.source.SubtractionLoadStrategy();
  }
  if (strategy === undefined && this.loadStrategy_ !== undefined) {
    strategy = function (extent, resolution) {
      return self.loadStrategy_.loadStrategy(extent, resolution);
    };
  }

  if (options.polygonsCountyCache !== undefined) {
    this.polygonsCountyCache_ = /** @type {alk.source.PolygonsCountyCache} */(options.polygonsCountyCache);
  }
  if (this.polygonsCountyCache_ == null) {
    this.polygonsCountyCache_ = new alk.source.PolygonsCountyCache(options.polygonsCountyCacheOptions);
  }

  /** @type {olx.source.VectorOptions} */
  var opts = {
    url: function (extent, resolution, projection) {
      return self.featureLoadURLFunction(extent, resolution, projection);
    },
    strategy: strategy,
    format: new alk.format.WeatherAlertsJSON({
      polygonsCountyCache: this.polygonsCountyCache_,
      defaultDataProjection: alk.val.SRS.EPSG4326
    }),
    wrapX: options.wrapX
  };

  alk.source.WeatherAlertsSource.base(this, 'constructor', opts);

  if (options.weatherAlertsService !== undefined) {
    this.weatherAlertsService_ = /** @type {alk.service.WeatherAlertsService} */(options.weatherAlertsService);
  }
  if (this.weatherAlertsService_ == null) {
    this.weatherAlertsService_ = new alk.service.WeatherAlertsService(options.weatherAlertsServiceOptions);
  }

  this.baseOptions_ = {
    weatherAlertsService: options.weatherAlertsService,
    weatherAlertsServiceOptions: options.weatherAlertsServiceOptions,
    polygonsCountyCache: options.polygonsCountyCache,
    polygonsCountyCacheOptions: options.polygonsCountyCacheOptions
  };

};
goog.inherits(alk.source.WeatherAlertsSource, ol.source.Vector);

/**
 * @type {alk.service.WeatherAlertsService}
 * @private
 */
alk.source.WeatherAlertsSource.prototype.weatherAlertsService_;

/**
 * @type {alk.source.PolygonsCountyCache}
 * @private
 */
alk.source.WeatherAlertsSource.prototype.polygonsCountyCache_;

/**
 * @returns {alk.service.WeatherAlertsService}
 * @this {alk.source.WeatherAlertsSource}
 * @api
 */
alk.source.WeatherAlertsSource.prototype.getWeatherAlertsService = function () {
  return this.weatherAlertsService_;
};

/**
 * @param {alk.service.WeatherAlertsService} service
 * @this {alk.source.WeatherAlertsSource}
 * @api
 */
alk.source.WeatherAlertsSource.prototype.setWeatherAlertsService = function (service) {
  this.weatherAlertsService_ = service;
  this.refresh();
};

/**
 * This method causes an entire refresh of this source. It does this by creating
 * a new WeatherAlertsService from the old one with the extended options.
 * @param {alkx.WeatherAlertsServiceOptions=} options
 * @this {alk.source.WeatherAlertsSource}
 * @api
 */
alk.source.WeatherAlertsSource.prototype.changeWeatherAlertsService = function (options) {
  var service = this.weatherAlertsService_;
  var opts = service.getServiceOptions(options);
  this.baseOptions_.weatherAlertsServiceOptions = opts;
  delete this.baseOptions_.weatherAlertsService;
  this.weatherAlertsService_ = new alk.service.WeatherAlertsService(opts);
  this.refresh();
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 * @this {alk.source.WeatherAlertsSource}
 * @return {string}
 */
alk.source.WeatherAlertsSource.prototype.featureLoadURLFunction = function (extent, resolution, projection) {
  var pt1 = ol.extent.getTopLeft(extent);
  var pt2 = ol.extent.getBottomRight(extent);
  var url = this.getWeatherAlertsService().getURL({
    pt1: ol.proj.transform(pt1, alk.val.SRS.EPSG3857, alk.val.SRS.EPSG4326),
    pt2: ol.proj.transform(pt2, alk.val.SRS.EPSG3857, alk.val.SRS.EPSG4326)
  });
  return url;
};

/**
 * This attribute contains the options with which the WeatherAlertsSource was created.
 * @type {Object.<string,*>}
 * @private
 */
alk.source.WeatherAlertsSource.prototype.baseOptions_;

/**
 * This method removes all features from this source.
 *
 * @param {Array.<ol.Feature>} features
 * @this {alk.source.WeatherAlertsSource}
 * @api
 */
alk.source.WeatherAlertsSource.prototype.removeAllFeatures = function (features) {
  for(var i = 0; i < features.length; i++) {
    this.removeFeature(features[i]);
  }
};

/**
 * @override
 * @this {alk.source.WeatherAlertsSource}
 */
alk.source.WeatherAlertsSource.prototype.refresh = function () {
  // If we are going to refresh, we need a new strategy, because it's keeping
  // track of what we've loaded.
  if (this.loadStrategy_ instanceof alk.source.SubtractionLoadStrategy) {
    this.loadStrategy_ = new alk.source.SubtractionLoadStrategy();
  }
  this.clear();
};

/**
 * This function returns the current state of weather alerts received by this source.
 * This function just returns the associated weather alert with each feature
 * currently residing in this source.
 *
 * ### NOTE ###
 *
 * This returns the immediate current state of the source. If the source is in the
 * process of updating, which could be from user interaction, such as a zoom in or out,
 * the result may not be stable.
 *
 * One may wait until the source's state, i.e. ``getState``, is in the ol.source.State.READY
 * state, as opposed to ol.source.State.LOADING. However, that condition is not really
 * guaranteed at any given point in time, unless other precautions are taken.
 *
 * If one desires a more stable result, use the {@link alk.service.WeatherAlertsService#get}
 * call with a specific pt1 and pt2 parameters defining the desired extent.
 *
 * @return {Array.<alkx.WeatherAlert>}
 * @this {alk.source.WeatherAlertsSource}
 * @api
 */
alk.source.WeatherAlertsSource.prototype.getWeatherAlerts = function () {
  var results = [];
  this.getFeatures().forEach(function(feature) {
    var weatherAlert = feature.get('weatherAlert');
    if (weatherAlert) {
      results.push(weatherAlert);
    }
  });
  return results;
};
goog.provide('alk.style.WeatherAlertsLayerStyle');

goog.require('alk.style');

/**
 * @classdesc
 * This is the base class that provides a styling function for the Weather Alerts Layer.
 * @description
 * This constructor is the base constructor for styling Weather Alerts.
 * @constructor
 * @extends {ol.Object}
 * @abstract
 * @api
 */
alk.style.WeatherAlertsLayerStyle = function () {
  alk.style.WeatherAlertsLayerStyle.base(this, 'constructor');
};
goog.inherits(alk.style.WeatherAlertsLayerStyle, ol.Object);

/**
 * This function provides the styleFunction for the Weather Alerts Layer.
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @abstract
 * @api
 */
alk.style.WeatherAlertsLayerStyle.prototype.styleFunction = function(feature, resolution) {};
goog.provide('alk.val.WeatherAlertColor');

goog.require('alk.val');

/**
 * This object contains the ALK colors to style Weather Alert Polygons. They
 * are keyed using the WeatherAlert.AlertEvent property.
 * @type {Object.<string,string>}
 * @api
 */
alk.val.WeatherAlertColor = {
  '911 Telephone Outage':'#C0C0C0',
  'Administrative Message':'#FFFFFF',
  'Air Quality Alert':'#808080',
  'Air Stagnation Advisory':'#808080',
  'Arroyo and Small Stream Flood Advisory':'#00FF7F',
  'Ashfall Advisory':'#696969',
  'Ashfall Warning':'#A9A9A9',
  'Avalanche Advisory':'#CD853F',
  'Avalanche Warning':'#1E90FF',
  'Avalanche Watch':'#F4A460',
  'Beach Hazards Statement':'#40E0D0',
  'Blizzard Warning':'#FF4500',
  'Blizzard Watch':'#ADFF2F',
  'Blowing Dust Advisory':'#BDB76B',
  'Brisk Wind Advisory':'#D8BFD8',
  'Child Abduction Emergency':'#FFD700',
  'Civil Danger Warning':'#FFB6C1',
  'Civil Emergency Message':'#FFB6C1',
  'Coastal Flood Advisory':'#7CFC00',
  'Coastal Flood Statement':'#6B8E23',
  'Coastal Flood Warning':'#228B22',
  'Coastal Flood Watch':'#66CDAA',
  'Dense Fog Advisory':'#708090',
  'Dense Smoke Advisory':'#F0E68C',
  'Dust Storm Warning':'#FFE4C4',
  'Earthquake Warning':'#8B4513',
  'Evacuation - Immediate':'#7FFF00',
  'Excessive Heat Warning':'#C71585',
  'Excessive Heat Watch':'#800000',
  'Extreme Cold Warning':'#0000FF',
  'Extreme Cold Watch':'#0000FF',
  'Extreme Fire Danger':'#E9967A',
  'Extreme Wind Warning':'#FF8C00',
  'Fire Warning':'#A0522D',
  'Fire Weather Watch':'#FFDEAD',
  'Flash Flood Statement':'#8B0000',
  'Flash Flood Warning':'#8B0000',
  'Flash Flood Watch':'#2E8B57',
  'Flood Advisory':'#00FF7F',
  'Flood Statement':'#00FF00',
  'Flood Warning':'#00FF00',
  'Flood Watch':'#2E8B57',
  'Freeze Warning':'#00FFFF',
  'Freeze Watch':'#041690',
  'Freezing Fog Advisory':'#008080',
  'Freezing Rain Advisory':'#DA70D6',
  'Freezing Spray Advisory':'#00BFFF',
  'Frost Advisory':'#6495ED',
  'Gale Warning':'#DDA0DD',
  'Gale Watch':'#FFC0CB',
  'Hard Freeze Warning':'#0000FF',
  'Hazardous Materials Warning':'#4B0082',
  'Hazardous Seas Warning':'#D8BFD8',
  'Hazardous Seas Watch':'#483D8B',
  'Hazardous Weather Outlook':'#EEE8AA',
  'Heat Advisory':'#FF7F50',
  'Heavy Freezing Spray Warning':'#00BFFF',
  'Heavy Freezing Spray Watch':'#BC8F8F',
  'High Surf Advisory':'#BA55D3',
  'High Surf Warning':'#228B22',
  'High Wind Warning':'#DAA520',
  'High Wind Watch':'#B8860B',
  'Hurricane Force Wind Warning':'#CD5C5C',
  'Hurricane Force Wind Watch':'#9932CC',
  'Hurricane Local Statement':'#FFE4B5',
  'Hurricane Warning':'#DC143C',
  'Hurricane Watch':'#FF00FF',
  'Hydrologic Advisory':'#00FF7F',
  'Hydrologic Outlook':'#90EE90',
  'Ice Storm Warning':'#8B008B',
  'Lake Effect Snow Advisory':'#48D1CC',
  'Lake Effect Snow Warning':'#008B8B',
  'Lake Effect Snow Watch':'#87CEFA',
  'Lake Wind Advisory':'#D2B48C',
  'Lakeshore Flood Advisory':'#7CFC00',
  'Lakeshore Flood Statement':'#6B8E23',
  'Lakeshore Flood Warning':'#228B22',
  'Lakeshore Flood Watch':'#66CDAA',
  'Law Enforcement Warning':'#C0C0C0',
  'Local Area Emergency':'#C0C0C0',
  'Low Water Advisory':'#A52A2A',
  'Marine Weather Statement':'#FFDAB9',
  'Nuclear Power Plant Warning':'#4B0082',
  'Radiological Hazard Warning':'#4B0082',
  'Red Flag Warning':'#FF1493',
  'Rip Current Statement':'#40E0D0',
  'Severe Thunderstorm Warning':'#FFA500',
  'Severe Thunderstorm Watch':'#DB7093',
  'Severe Weather Statement':'#00FFFF',
  'Shelter In Place Warning':'#FA8072',
  'Short Term Forecast':'#98FB98',
  'Small Craft Advisory':'#D8BFD8',
  'Small Craft Advisory For Hazardous Seas':'#D8BFD8',
  'Small Craft Advisory For Rough Bar':'#D8BFD8',
  'Small Craft Advisory For Winds':'#D8BFD8',
  'Small Stream Flood Advisory':'#00FF7F',
  'Special Marine Warning':'#FFA500',
  'Special Weather Statement':'#FFE4B5',
  'Storm Warning':'#9400D3',
  'Storm Watch':'#FFE4B5',
  'Test':'#F0FFFF',
  'Tornado Warning':'#FF0000',
  'Tornado Watch':'#FFFF00',
  'Tropical Depression Local Statement':'#FFE4B5',
  'Tropical Storm Local Statement':'#FFE4B5',
  'Tropical Storm Warning':'#B22222',
  'Tropical Storm Watch':'#F08080',
  'Tsunami Advisory':'#D2691E',
  'Tsunami Warning':'#FD6347',
  'Tsunami Watch':'#FF00FF',
  'Typhoon Local Statement':'#FFE4B5',
  'Typhoon Warning':'#DC143C',
  'Typhoon Watch':'#FF00FF',
  'Urban and Small Stream Flood Advisory':'#00FF7F',
  'Volcano Warning':'#2F4F4F',
  'Wind Advisory':'#D2B48C',
  'Wind Chill Advisory':'#AFEEEE',
  'Wind Chill Warning':'#B0C4DE',
  'Wind Chill Watch':'#5F9EA0',
  'Winter Storm Warning':'#FF69B4',
  'Winter Storm Watch':'#4682B4',
  'Winter Weather Advisory':'#7B68EE',
  /**Starts Canada weather alert.
   Don't see published color codes online.
   Try to match US code below **/
  'blowing snow':'#008B8B',               /* Lake Effect Snow Warning */
  'blizzard':'#FF4500',                         /* Blizzard Warning */
  'dustStorm':'#BDB76B',                   /* Blowing Dust Advisory */
  'freezeRain':'#DA70D6',                   /* Freezing Rain Advisory */
  'freezing drizzle':'#DA70D6',            /* Freezing Rain Advisory */
  'frost':'#6495ED',                              /* Frost Advisory */
  'heat':'#FF7F50',                               /* Heat Advisory */
  'hurricane':'#DC143C',                     /* Hurricane Warning */
  'rainfall':'#8B0000',                           /* Flash Flood Warning */
  'snowfall':'#48D1CC',                       /* Lake Effect Snow Advisory */
  'Test Message':'#F0FFFF',              /* Test */
  'thunderstorm':'#FFA500',               /* Severe Thunderstorm Warning  */
  'tornado':'#FF0000',                         /* Tornado Warning */
  'tropical storm':'#B22222',               /* Tropical Storm Warning */
  'weather': '#FFE4B5',                      /* Special Weather Statement */
  'wind':'#D2B48C',                            /* Wind Advisory */
  'windchill':'#AFEEEE',                     /* Wind Chill Advisory */
  'winterStorm':'#FF69B4',                 /* Winter Storm Warning  */
  'squall': '#87CEFA',
  'freezing rain': '#DA70D6',
  'special marine': '#FFA500',
  'winter storm': '#FF69B4'
};
goog.provide('alk.style.PolygonWeatherAlertsLayerStyle');

goog.require('alk.style.WeatherAlertsLayerStyle');
goog.require('alk.val.WeatherAlertColor');

/**
 * @classdesc
 * An instance of this class provides a {@link ol.style.StyleFunction} for
 * the {@link alk.layer.WeatherAlertsLayer} that styles polygons according
 * to the WeatherAlert.AlertEvent property using {@link alk.val.WeatherAlertColor}.
 * @description
 * This constructor creates a Style Function for the Weather Alerts layer.
 *
 * @param {{
 *  defaultStyle: (Array.<ol.style.Style>|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.WeatherAlertsLayerStyle}
 * @api
 */
alk.style.PolygonWeatherAlertsLayerStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};

  if (options.defaultStyle !== undefined) {
    this.defaultStyle_ = options.defaultStyle;
  }

  alk.style.PolygonWeatherAlertsLayerStyle.base(this, 'constructor');
  if (this.styles === undefined) {
    this.constructWeatherAlertStyles_();
  }
};
goog.inherits(alk.style.PolygonWeatherAlertsLayerStyle, alk.style.WeatherAlertsLayerStyle);

/**
 * @type {Array.<ol.style.Style>}
 * @private
 */
alk.style.PolygonWeatherAlertsLayerStyle.prototype.defaultStyle_;

/**
 * This method constructs the Weather Alert Styles to be used from the
 * {@link alk.val.WeatherAlertColor}, constructing a map keyed on WeatherAlert.AlertEvent.
 *
 * This construction gets done only once as the prototype is assigned here.
 * The styles constructed here are Fill Styles
 * for the Weather Polygons, and they are assigned as a 0.2 opacity of the color.
 */
alk.style.PolygonWeatherAlertsLayerStyle.prototype.constructWeatherAlertStyles_ = function() {
  var styles = alk.style.PolygonWeatherAlertsLayerStyle.prototype.styles = {};
  Object.keys(/** @type {!Object} */(alk.val.WeatherAlertColor)).forEach(function(k) {
    if (alk.val.WeatherAlertColor.hasOwnProperty(k)) {
      var color = ol.color.asArray(alk.val.WeatherAlertColor[k]);
      // Set the opacity
      color[3] = 0.2;
      styles[k] = [new ol.style.Style({
        fill: new ol.style.Fill({
          color: color
        })
      })];
    }
  });
};

/**
 * @type {Object.<string, Array.<ol.style.Style>>}
 */
alk.style.PolygonWeatherAlertsLayerStyle.prototype.styles;

/**
 * This function returns the style for only WeatherAlert features. The
 * feature must have the 'weatherAlert' property and have a suitable polygon
 * or collection of polygons geometries. Geometries may be updated asynchronously.
 *
 * The styles are generated using the colors from {@link alk.val.WeatherAlertColor}.
 * The styles consist of only Fill styles with an opacity set to 0.2 of the designated
 * color.
 *
 * If the feature is a WeatherAlert feature and does not have an associated color
 * in the color map, the set default style is used.
 *
 * @param {ol.Feature} feature The feature, which should have the 'weatherAlert' property.
 * @param {number} resolution The resolution of the zoom. Ignored.
 * @returns {Array.<ol.style.Style>}
 * @override
 * @this {alk.style.PolygonWeatherAlertsLayerStyle}
 * @api
 */
alk.style.PolygonWeatherAlertsLayerStyle.prototype.styleFunction = function(feature, resolution) {

  var weatherAlert = feature.get('weatherAlert');
  if (weatherAlert && feature.getGeometry()) {
    var style = this.styles[weatherAlert.AlertEvent];
    if (style !== undefined) {
      return style;
    } else {
      console.log("There is no style for WeatherAlert.AlertEvent = '" + weatherAlert.AlertEvent + "'");
      if (this.defaultStyle_ !== undefined) {
        return this.defaultStyle_;
      } else {
        return [];
      }
    }
  }
  return [];
};
goog.provide('alk.layer.WeatherAlertsLayer');

goog.require('alk');
goog.require('alk.layer');
goog.require('alk.source.WeatherAlertsSource');
goog.require('alk.style.PolygonWeatherAlertsLayerStyle');

goog.require('alkx.WeatherAlertsLayerOptions');

/**
 * @classdesc
 * An instance of this class provides a layer that may lookup a points of interest within
 * the radius of a point, using the ALK Weather Alerts Service, and display them.
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @description
 * This constructor creates a layer that gets its information from the ALK
 * Weather Alerts Service and displays them on the map with polygons and popups.
 *
 * All visual representation is handled by the 'style' option.
 * As a default, the {@link alk.style.PolygonWeatherAlertsLayerStyle} is used, which
 * as a default draws WeatherAlerts polygons according to their data.
 *
 * @param {alkx.WeatherAlertsLayerOptions=} opt_options
 * @fires {'change:updating'} This event is fired when the request is being made and when it returns.
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @api
 */
alk.layer.WeatherAlertsLayer = function (opt_options) {
  /** @type {alkx.WeatherAlertsLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var style = this.processStyle(options.style);

  var source = options.source;

  if (source == null) {
    source = new alk.source.WeatherAlertsSource({
      weatherAlertsServiceOptions: options.weatherAlertsServiceOptions
    });
  }
  var layerOptions = {
    style: style,
    declutter: options.declutter,
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    renderOrder: options.renderOrder,
    renderBuffer: options.renderBuffer,
    updateWhileAnimating: options.updateWhileAnimating,
    updateWhileInteracting: options.updateWhileInteracting
  };
  alk.layer.WeatherAlertsLayer.base(this, 'constructor', layerOptions);
};
goog.inherits(alk.layer.WeatherAlertsLayer, ol.layer.Vector);

/**
 * This attribute contains the WeatherAlertsLayerStyle that was either assigned
 * or created for this WeatherAlertsLayer.
 * @type {alk.style.WeatherAlertsLayerStyle}
 * @private
 */
alk.layer.WeatherAlertsLayer.prototype.weatherAlertsLayerStyle_;

/**
 * This function returns the WeatherAlertsLayerStyle that was either assigned or
 * created for this WeatherAlertsLayer.
 * @returns {alk.style.WeatherAlertsLayerStyle|undefined}
 * @this {alk.layer.WeatherAlertsLayer}
 * @api
 */
alk.layer.WeatherAlertsLayer.prototype.getWeatherAlertsLayerStyle = function () {
  return this.weatherAlertsLayerStyle_;
};

/**
 * This function assigns or creates the WeatherAlertsLayerStyle from 'style' option. If we don't
 * understand the value, we just let it go, figuring that the caller knows what they are
 * doing.
 * @param {alk.style.WeatherAlertsLayerStyle|alk.style.StrokeQueue|Array.<ol.style.Stroke>|ol.style.Stroke|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @returns {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 * @this {alk.layer.WeatherAlertsLayer}
 * @protected
 */
alk.layer.WeatherAlertsLayer.prototype.processStyle = function (optStyle) {
  var style;
  var self = this;
  if (optStyle !== undefined) {
    if (optStyle instanceof alk.style.WeatherAlertsLayerStyle) {
      self.weatherAlertsLayerStyle_ = optStyle;
      style = function (feature, resolution) {
        return self.weatherAlertsLayerStyle_.styleFunction(feature, resolution);
      };
    } else {
      // We just go with the supplied style.
      style = /** @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction} */ (optStyle);
    }
  } else {
    if (this.weatherAlertsLayerStyle_ === undefined) {
      var color = ol.color.asArray('#F0FFFF');
      // Set the opacity
      color[3] = 0.2;
      this.weatherAlertsLayerStyle_ = new alk.style.PolygonWeatherAlertsLayerStyle({
        defaultStyle: [new ol.style.Style({
          fill: new ol.style.Fill({
            color: color
          })
        })]
      });
    }

    style = function (feature, resolution) {
      return self.weatherAlertsLayerStyle_.styleFunction(feature, resolution);
    };
  }
  return style;
};

/**
 * This function sets the Style for this layer.
 * @override
 * @param {alk.style.WeatherAlertsLayerStyle|ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|string|undefined} optStyle
 * @this {alk.layer.WeatherAlertsLayer}
 * @api
 */
alk.layer.WeatherAlertsLayer.prototype.setStyle = function (optStyle) {
  var style = this.processStyle(optStyle);
  alk.layer.WeatherAlertsLayer.base(this, 'setStyle', style);
};
goog.provide('pcmws.api.Country');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the Country parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Country = function (value) {
  pcmws.api.Country .base(this, 'constructor', 'country', value);
};
goog.inherits(pcmws.api.Country, pcmws.api.Param);
goog.provide('pcmws.api.DeviceId');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the DeviceId parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.DeviceId = function (value) {
  pcmws.api.DeviceId .base(this, 'constructor', 'deviceId', value);
};
goog.inherits(pcmws.api.DeviceId, pcmws.api.Param);
goog.provide('pcmws.api.ProductKey');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the ProductKey parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.ProductKey = function (value) {
  pcmws.api.ProductKey .base(this, 'constructor', 'prodKey', value);
};
goog.inherits(pcmws.api.ProductKey, pcmws.api.Param);
goog.provide('pcmws.api.Proj');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the Proj parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Proj = function (value) {
  pcmws.api.Proj .base(this, 'constructor', 'proj', value);
};
goog.inherits(pcmws.api.Proj, pcmws.api.Param);
goog.provide('pcmws.api.TimeOffset');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the TimeOffset parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.TimeOffset = function (value) {
  pcmws.api.TimeOffset .base(this, 'constructor', 'timeOffset', value);
};
goog.inherits(pcmws.api.TimeOffset, pcmws.api.Param);
goog.provide('pcmws.api.WeatherImageTileService');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Country');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DeviceId');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.ProductKey');
goog.require('pcmws.api.Proj');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.TimeOffset');
goog.require('pcmws.api.WeatherDisplay');
goog.require('pcmws.api.WeatherImageTileServiceOptions');
goog.require('pcmws.api.WeatherImageTileURL');
goog.require('pcmws.api.Width');
goog.require('pcmws.api.X');
goog.require('pcmws.api.Y');
goog.require('pcmws.api.Z');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the OpenLayers XYZ source layer for
 * PCMiler Traffic Tile service.
 * @param {pcmws.api.WeatherImageTileServiceOptions=} opt_options Options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.WeatherImageTileService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['drawerGroups', pcmws.api.DrawerGroups],
    ['format', pcmws.api.Format],
    ['imgOption', pcmws.api.ImgOption],
    ['imgSrc', pcmws.api.ImgSrc],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['style', pcmws.api.Style],
    ['width', pcmws.api.Width],
    ['height', pcmws.api.Height],
    ['timeOffset', pcmws.api.TimeOffset],
    ['weatherDisplay', pcmws.api.WeatherDisplay],
    ['proj', pcmws.api.Proj],
    ['productKey', pcmws.api.ProductKey],
    ['country', pcmws.api.Country],
    ['deviceId', pcmws.api.DeviceId],
    ['x', pcmws.api.X, '{x}'],
    ['y', pcmws.api.Y, '{y}'],
    ['z', pcmws.api.Z, '{z}']
  ];
  pcmws.api.WeatherImageTileService.base(this, 'constructor', specs, opt_options);
  /** @type {pcmws.api.WeatherImageTileServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.WeatherImageTileURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.WeatherImageTileService, pcmws.api.StaticService);

/**
 * @override
 * @this {pcmws.api.WeatherImageTileService}
 * @returns {pcmws.api.WeatherImageTileService}
 */
pcmws.api.WeatherImageTileService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.WeatherImageTileServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.WeatherImageTileService(opts);
};

/**
 * @inheritDoc
 * @this {pcmws.api.WeatherImageTileService}
 */
pcmws.api.WeatherImageTileService.prototype.getAttribution = function(opts_or_callback, responseCallback) {
  /** @type {function(Object)|undefined} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    callback = responseCallback;
  }
  if (typeof callback === 'function') {
    callback.call(this, {
      text: "Copyright &copy; 2017 Aeris, Inc",
      url: 'http://aeris.com',
      image: pcmws.AERIS_WEATHER_LOGO_URL
    });
  }
};
goog.provide('alk.service.WeatherImageTileService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.WeatherImageTileService');

goog.require('alkx.WeatherImageTileServiceOptions');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults, generates a URL for the
 * ALK Weather Image Tile service.
 * @description
 * This constructor creates a Service object with which to access the
 * ALK Weather Image Tile Service. It is used primarily to create URLs based
 * on the given options.
 *
 * @param {alkx.WeatherImageTileServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.WeatherImageTileService = function (opt_options) {
  alk.service.WeatherImageTileService.base(this,'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.weatherImageTileService = this.pcmws = new pcmws.api.WeatherImageTileService(this.pcmServiceOptions);
};
goog.inherits(alk.service.WeatherImageTileService, alk.service.Service);


/**
 * @description
 * The ALK Weather Image Tile Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.WeatherImageTileService} object.
 *
 * @type {pcmws.api.WeatherImageTileService}
 */
alk.service.WeatherImageTileService.prototype.weatherImageTileService;
goog.provide('alk.source.WeatherSource');

goog.require('alk.ATTRIBUTION');
goog.require('alk.service.WeatherImageTileService');
goog.require('alk.source.ImageTileSource');

goog.require('alkx.WeatherSourceOptions');

/**
 * @classdesc
 * An instance of this class holds the source for an ALK Weather Source that is used
 * in the {@link alk.layer.WeatherLayer} subclasses.
 * @description
 * This constructor creates a Source object for accessing the ALK Weather Service.
 *
 * It is an {@link ol.source.Tile} source that uses the ALK Weather Service.
 *
 * @param {alkx.WeatherSourceOptions=} opt_options
 * @extends {alk.source.ImageTileSource}
 * @constructor
 * @api
 */
alk.source.WeatherSource = function (opt_options) {
  /** @type {alkx.WeatherSourceOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.WeatherServiceOptions} */
  var serviceOptions = options.serviceOptions !== undefined ? options.serviceOptions : {};

  if (serviceOptions.display === undefined) {
    throw "alk.source.WeatherSource needs a serviceOptions.display of alk.val.Display.Radar or alk.val.Display.Satellite.";
  }

  var service = new alk.service.WeatherImageTileService(serviceOptions);

  var attributions;
  if (options.attributions !== undefined) {
    attributions = options.attributions;
  }

  alk.source.WeatherSource.base(this, 'constructor', {
    attributions: attributions,
    service: service,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    //logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileSize: options.tileSize,
    tileUrlFunction: options.tileUrlFunction,
    wrapX: options.wrapX,
    transition: options.transition
  });
};
goog.inherits(alk.source.WeatherSource, alk.source.ImageTileSource);

/**
 * @override
 * @param {alkx.AttributionJSON=} attributionJSON
 */
alk.source.WeatherSource.prototype.processAttributionResponse = function(attributionJSON) {
  /** @type {ol.AttributionLike} */
  var attribution;
  if (attributionJSON) {
    var url = attributionJSON.url;
    var image = attributionJSON.image;
    attribution = 'Weather data from <a href="'+url+'" target="_blank"><img src="'+image+'"></a>';
  } else {
    attribution = alk.ATTRIBUTION;
  }
  this.setAttributions([attribution]);
};
goog.provide('alk.layer.WeatherLayer');

goog.require('alk.layer');
goog.require('alk.source.WeatherSource');
goog.require('alk.layer.ImageTileLayer');

goog.require('alkx.WeatherLayerOptions');
goog.require('alkx.WeatherSourceOptions');

/**
 * @classdesc
 * An instance of this class is to be used for the weather
 * layer in an {@link ol.Map}, which is normally placed above a
 * base map layer. It uses a {@link ol.source.Tile} source that is
 * specific to the ALK Weather Service. This is a base weather
 * layer class. Select a subclass for a specific type, such
 * as Satellite or Radar weather data.
 *
 * @description
 * This constructor is the base constructor for a weather styled
 * layer. See {@link alk.layer.WeatherRadarLayer} or
 * {@link alk.layer.WeatherSatelliteLayer} for more details.
 *
 * @param {alkx.WeatherLayerOptions=} opt_options
 * @extends {alk.layer.ImageTileLayer}
 * @constructor
 * @api
 */
alk.layer.WeatherLayer = function(opt_options) {
  /** @type {alkx.WeatherLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.WeatherSourceOptions} */
  var sourceOptions = options.sourceOptions !== undefined ? options.sourceOptions : {};

  var source = new alk.source.WeatherSource({
    serviceOptions: sourceOptions.serviceOptions,
    cacheSize: sourceOptions.cacheSize,
    crossOrigin: sourceOptions.crossOrigin,
    opaque: sourceOptions.opaque,
    projection: sourceOptions.projection,
    reprojectionErrorThreshold: sourceOptions.reprojectionErrorThreshold,
    maxZoom: sourceOptions.maxZoom,
    minZoom: sourceOptions.minZoom,
    tileGrid: sourceOptions.tileGrid,
    tileLoadFunction: sourceOptions.tileLoadFunction,
    tilePixelRatio: sourceOptions.tilePixelRatio,
    tileSize: sourceOptions.tileSize,
    tileUrlFunction: sourceOptions.tileUrlFunction,
    wrapX: sourceOptions.wrapX,
    transition: sourceOptions.transition
  });

  alk.layer.WeatherLayer.base(this, 'constructor',  {
    opacity: options.opacity,
    source: source,
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError
  });
};
goog.inherits(alk.layer.WeatherLayer, alk.layer.ImageTileLayer);
goog.provide('alk.layer.WeatherRadarLayer');

goog.require('alk.layer');
goog.require('alk.layer.WeatherLayer');

goog.require('alkx.WeatherLayerOptions');
goog.require('alkx.WeatherSourceOptions');
goog.require('alkx.WeatherServiceOptions');

/**
 * @classdesc
 * An instance of this class is to be used for the weather
 * layer in an {@link ol.Map}, which is normally placed above a
 * base map layer. It uses a {@link ol.source.Tile} source that is
 * specific to the ALK Weather Radar Service.
 *
 * @description
 * This constructor creates a Weather Tile Layer that displays ALK
 * weather data using the ALK Weather Radar Service.
 *
 * @param {alkx.WeatherLayerOptions=} opt_options
 * @extends {alk.layer.WeatherLayer}
 * @constructor
 * @api
 */
alk.layer.WeatherRadarLayer = function(opt_options) {
  /** @type {alkx.WeatherLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.WeatherSourceOptions} */
  var srcOpts = options.sourceOptions !== undefined ? options.sourceOptions : {};
  /** @type {alkx.WeatherServiceOptions} */
  var svcOpts = srcOpts.serviceOptions !== undefined ? srcOpts.serviceOptions : {};

  var serviceOptions = {
    apiKey: svcOpts.apiKey,
    dataset: svcOpts.dataset,
    display: alk.val.Display.Radar,
    drawerGroups: svcOpts.drawerGroups,
    format: svcOpts.format,
    imgOption: svcOpts.imgOption,
    imgSrc: svcOpts.imgSrc,
    region: svcOpts.region,
    srs: svcOpts.srs,
    style: svcOpts.style,
    width: svcOpts.width,
    height: svcOpts.height
  };

  var sourceOptions = {
    serviceOptions: serviceOptions,
    cacheSize: srcOpts.cacheSize,
    crossOrigin: srcOpts.crossOrigin,
    opaque: srcOpts.opaque,
    projection: srcOpts.projection,
    reprojectionErrorThreshold: srcOpts.reprojectionErrorThreshold,
    maxZoom: srcOpts.maxZoom,
    minZoom: srcOpts.minZoom,
    tileGrid: srcOpts.tileGrid,
    tileLoadFunction: srcOpts.tileLoadFunction,
    tilePixelRatio: srcOpts.tilePixelRatio,
    tileSize: srcOpts.tileSize,
    tileUrlFunction: srcOpts.tileUrlFunction,
    wrapX: srcOpts.wrapX,
    transition: srcOpts.transition
  };

  alk.layer.WeatherRadarLayer.base(this, 'constructor',  {
    opacity: options.opacity,
    sourceOptions: sourceOptions,
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError
  });
};
goog.inherits(alk.layer.WeatherRadarLayer, alk.layer.WeatherLayer);
goog.provide('alk.val.Display');

goog.require('alk.val');
goog.require('pcmws.val.WeatherDisplay');

/**
 * @description
 * This enum holds the valid values for the Display parameter.
 * @enum {string}
 * @api
 *
 * */
alk.val.Display = {
  /** @api */
  Radar: pcmws.val.WeatherDisplay.Radar,
  /** @api */
  Satellite: pcmws.val.WeatherDisplay.Satellite
};

goog.provide('alk.layer.WeatherSatelliteLayer');

goog.require('alk.layer');
goog.require('alk.layer.WeatherLayer');
goog.require('alk.val.Display');

goog.require('alkx.WeatherLayerOptions');
goog.require('alkx.WeatherSourceOptions');
goog.require('alkx.WeatherServiceOptions');


/**
 * @classdesc
 * An instance of this class is to be used for the weather
 * layer in an {@link ol.Map}, which is normally placed above a
 * base map layer. It uses a {@link ol.source.Tile} source that is
 * specific to the ALK Weather Satellite Service.
 *
 * @description
 * This constructor creates a Weather Tile Layer that displays ALK
 * weather data using the ALK Weather Satellite Service.
 *
 * @param {alkx.WeatherLayerOptions=} opt_options
 * @extends {alk.layer.WeatherLayer}
 * @constructor
 * @api
 */
alk.layer.WeatherSatelliteLayer = function(opt_options) {
  /** @type {alkx.WeatherLayerOptions} */
  var options = opt_options !== undefined ? opt_options : {};
  /** @type {alkx.WeatherSourceOptions} */
  var srcOpts = options.sourceOptions !== undefined ? options.sourceOptions : {};
  /** @type {alkx.WeatherServiceOptions} */
  var svcOpts = srcOpts.serviceOptions !== undefined ? srcOpts.serviceOptions : {};


  var serviceOptions = {
    apiKey: svcOpts.apiKey,
    dataset: svcOpts.dataset,
    display: alk.val.Display.Satellite,
    drawerGroups: svcOpts.drawerGroups,
    format: svcOpts.format,
    imgOption: svcOpts.imgOption,
    imgSrc: svcOpts.imgSrc,
    region: svcOpts.region,
    srs: svcOpts.srs,
    style: svcOpts.style,
    width: svcOpts.width,
    height: svcOpts.height
  };

  var sourceOptions = {
    serviceOptions: serviceOptions,
    cacheSize: srcOpts.cacheSize,
    crossOrigin: srcOpts.crossOrigin,
    opaque: srcOpts.opaque,
    projection: srcOpts.projection,
    reprojectionErrorThreshold: srcOpts.reprojectionErrorThreshold,
    maxZoom: srcOpts.maxZoom,
    minZoom: srcOpts.minZoom,
    tileGrid: srcOpts.tileGrid,
    tileLoadFunction: srcOpts.tileLoadFunction,
    tilePixelRatio: srcOpts.tilePixelRatio,
    tileSize: srcOpts.tileSize,
    tileUrlFunction: srcOpts.tileUrlFunction,
    wrapX: srcOpts.wrapX,
    transition: srcOpts.transition
  };

  alk.layer.WeatherSatelliteLayer.base(this, 'constructor',  {
    opacity: options.opacity,
    sourceOptions: sourceOptions,
    map: options.map,
    visible: options.visible,
    extent: options.extent,
    minResolution: options.minResolution,
    maxResolution: options.maxResolution,
    useInterimTilesOnError: options.useInterimTilesOnError
  });
};
goog.inherits(alk.layer.WeatherSatelliteLayer, alk.layer.WeatherLayer);
goog.provide('alk.overlay.WeatherAlertPopup');

goog.require('alk.overlay');

goog.require('alkx.WeatherAlert');
goog.require('alkx.WeatherAlertPopupOptions');

/**
 * @classdesc
 * An instance of this class provides an overlay on the map
 * that will show a WeatherAlertPopup. It creates the
 * following structure in the DOM.
 *
 * <div class='alk-popup'>
 *   <a class='alk-popup-close' href='#'></a>
 *   <div class='alk-popup-header'>Weather Alert</div>
 *   <div class='alk-popup-content alk-weather-alert'>
 *     <ul class='alk-popup-list'>
 *       <li class='alk-popup-item alk-wa-title'>Title: ...</li>
 *       <li class='alk-popup-item alk-wa-summary'>Summary: ...</li>
 *       <li class='alk-popup-item alk-wa-event'>Event: ...</li>
 *       <li class='alk-popup-item alk-wa-effective'>Effective: ...</li>
 *       <li class='alk-popup-item alk-wa-expires'>Expires: ...</li>
 *       <li class='alk-popup-item alk-wa-urgency'>Urgency: ...</li>
 *       <li class='alk-popup-item alk-wa-severity'>Severity: ...</li>
 *       <li class='alk-popup-item alk-wa-certainty'>Certainty: ...</li>
 *     </ul>
 *   </div>
 * </div>
 *
 * @description
 * This constructor creates a popup overlay that displays ALK Weather
 * Alert data.
 *
 * @param {alkx.WeatherAlertPopupOptions=} opt_options
 * @constructor
 * @extends {ol.Overlay}
 * @api
 */
alk.overlay.WeatherAlertPopup = function (opt_options) {
  /** @type {alkx.WeatherAlertPopupOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  var element = null;
  var close = null;
  if (options.weatherAlert) {
    var ce = this.createPopupElement(options.weatherAlert);
    element = ce.element;
    close = ce.close;
  }

  /** @type {olx.OverlayOptions} */
  var opts = {
    id: options.id,
    element: element,
    offset: options.offset,
    position: options.position,
    positioning: options.positioning,
    stopEvent: options.stopEvent,
    insertFirst: options.insertFirst,
    autoPan: options.autoPan,
    autoPanAnimation: options.autoPanAnimation,
    autoPanMargin: options.autoPanMargin
  };
  alk.overlay.WeatherAlertPopup.base(this, 'constructor', opts);

  this.closeElement = close;
};
goog.inherits(alk.overlay.WeatherAlertPopup, ol.Overlay);

/**
 * This property holds the close element.
 * @type {Element}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.closeElement;

/**
 * This method sets the weather alert for this popup.
 * @param {alkx.WeatherAlert} alert The Weather Alert.
 * @fires {change:element} Fires this event when changed.
 * @this {alk.overlay.WeatherAlertPopup}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.setWeatherAlert = function (alert) {
  var ce = this.createPopupElement(alert);
  this.closeElement = ce.close;
  this.setElement(ce.element);
};

/**
 * This property contains the HTML string that has {{content}} string for form the list in the
 * weather alert.
 * @type {string}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.listFormat =
  '<dl class="{{class}}">{{content}}</dl>';

/**
 * This parameter contains the HTML string that has {{class}}, {{label}}, and {{content}} strings
 * to form a line in the Weather Alert.
 * @type {string}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.itemFormat =
  '<dt class="{{class}}"><strong>{{label}}</strong></dt><dd class="{{class}}">{{content}}</dd>';

/**
 * This function returns the HTML string for a single Weather Alert Element.
 *
 * @param {string} format  The format string that has {{class}}, {{label}}, and {{content}} strings.
 * @param {string} klass The string with which to replace {{class}}.
 * @param {string} label The string with which to replace {{label}}.
 * @param {string} content The string with which to replace {{content}}.
 * @returns {string}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.createItemHTML = function (format, klass, label, content) {
  var str = format;
  str = str.replace(/\{\{class\}\}/g, klass);
  str = str.replace(/\{\{label\}\}/g, label);
  str = str.replace(/\{\{content\}\}/g, content);
  return str;
};

/**
 * This method returns the inner HTML, which is a list of items.
 * @param {string} format The format of the list that contains {{class}} and {{content}}
 * @param {string} klass The class of the list, if applicable.
 * @param {string} content The HTML string of the list contents.
 * @returns {string}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.createListHTML = function (format, klass, content) {
  var str = format;
  str = str.replace(/\{\{class\}\}/g, klass);
  str = str.replace(/\{\{content\}\}/g, content);
  return str;
};
/**
 * This property holds the [class,label,alertkey] specifications for building the Weather Alert content.
 * Each triple is given to {@link alk.overlay.WeatherAlertPopup#createElement}.
 * @type {Array.<Array<string>>}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.elements = function () {
  return [
    ['alk-popup-item alk-wa-title', 'Title', "Title"],
    ['alk-popup-item alk-wa-summary', 'Summary', "Summary"],
    ['alk-popup-item alk-wa-event', 'Event', "AlertEvent"],
    ['alk-popup-item alk-wa-effective', 'Effective', "DispEffective"],
    ['alk-popup-item alk-wa-expires', 'Expires', "DispExpires"],
    ['alk-popup-item alk-wa-urgency', 'Urgency', "Urgency"],
    ['alk-popup-item alk-wa-severity', 'Severity', "Severity"],
    ['alk-popup-item alk-wa-certainty', 'Certainty', "Certainty"]
  ];
}();

/**
 * This returns the div for the Weather Alert.
 * @param {alkx.WeatherAlert} alert
 * @returns {Element}
 * @this {alk.overlay.WeatherAlertPopup}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.createContentElement = function (alert) {
  var self = this;
  var children = [];
  this.elements.forEach(function (spec) {
    var klass = spec[0];
    var label = spec[1];
    var key = spec[2];
    var content = alert[key];
    if (content) {
      children.push(self.createItemHTML(self.itemFormat, klass, label, content));
    }
  });
  var listContentHTML = children.join('');
  var listHTML = this.createListHTML(this.listFormat, 'alk-popup-list', listContentHTML);
  var content = document.createElement('div');
  content.className = 'alk-popup-content alk-weather-alert';
  content.innerHTML = listHTML;
  return content;
};

/**
 * This creates the popup element.
 * @param {alkx.WeatherAlert} alert
 * @returns {{close: Element, element: Element}}
 * @this {alk.overlay.WeatherAlertPopup}
 * @api
 */
alk.overlay.WeatherAlertPopup.prototype.createPopupElement = function (alert) {
  var content = this.createContentElement(alert);
  var popup = document.createElement('div');
  popup.className = 'alk-popup';
  var header = document.createElement('div');
  header.className = 'alk-popup-header';
  header.innerHTML = "<strong>Weather Alert</strong>";
  var close = document.createElement('a');
  close.href = "#";
  close.className = 'alk-popup-close';
  popup.appendChild(header);
  popup.appendChild(close);
  popup.appendChild(content);
  return {
    close: close,
    element: popup
  };
};
goog.provide('alk.service.RestService');

goog.require('alk.service.ServiceBase');

/**
 * @classdesc
 * This class is the base class for an ALK Rest Service that conforms to
 * certain the options.
 * @description
 * This constructor is a base constructor for an ALK Rest Service that
 * conforms to certain ALK related options.
 *
 * @param {alkx.ServiceOptions=} opt_options
 * @constructor
 * @extends {alk.service.ServiceBase}
 * @api
 */
alk.service.RestService = function (opt_options) {
  alk.service.RestService.base(this, 'constructor', opt_options);
};
goog.inherits(alk.service.RestService, alk.service.ServiceBase);
goog.provide('pcmws.api.AvoidFavorSetsRestServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.RestServiceURL');
/**
 * @classdesc
 * This class is used to hold the host and base path of a URL for the Custom Place Sets Rest Service.
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path. See {@link pcmws.api.AvoidFavorSetsRestServiceURL#path} for documentation.
 * @extends {pcmws.api.RestServiceURL}
 * @constructor
 *
 */
pcmws.api.AvoidFavorSetsRestServiceURL = function (hosturl, path) {
  pcmws.api.AvoidFavorSetsRestServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.AvoidFavorSetsRestServiceURL, pcmws.api.RestServiceURL);

/**
 * @description
 * This value contains the path of the url. The path should contain the following
 * strings:
 *     '{XDR}'   This string gets replaced with 'XDR/', and is used only
 *               when dealing with IE 8 & 9.
 * Example:
 *   new pcmws.api.AvoidFavorsRestServiceURL(
 *       'https://pcmiler.alk.com',
 *       '/apis/rest/v1.0/service.svc/{XDR}avoidFavorSets');
 * @type {string}
 *
 */
pcmws.api.AvoidFavorSetsRestServiceURL.prototype.path;
goog.provide('pcmws.api.EncodedParam');

goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class specifies a named parameter whose value is automatically encoded.
 */
/**
 * Constructs an encoded parameter.
 * @constructor
 * @param {string} name The parameter name
 * @param {*} value The value given to the parameter.
 * @extends {pcmws.api.Param}
 */
pcmws.api.EncodedParam = function (name, value) {
  pcmws.api.EncodedParam.base(this, 'constructor', name, value);
  this.shouldEncodeValue = true;
};
goog.inherits(pcmws.api.EncodedParam, pcmws.api.Param);

goog.provide('pcmws.api.RestService');

goog.require('pcmws.api');
goog.require('pcmws.api.RestServiceOptions');
goog.require('pcmws.api.RestServiceURL');
goog.require('pcmws.api.XMLHttpRequest');


/**
 * @classdesc
 * This class contains the base functions for a REST service.
 * @param {Array.<Array.<string|Function>>} specs
 * @param {pcmws.api.RestServiceOptions=} opt_options
 * @constructor
 * @abstract
 *
 */
pcmws.api.RestService = function (specs, opt_options) {
  /** @type {pcmws.api.RestServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.RestServiceURL(options.hostURL, options.path);

  this.formalParameters = {};
  this.formalParameterDefaults = {};
  var self = this;
  specs.forEach(function (spec) {
    var optionKey = /** @type {string} */(spec[0]);
    var type = /** @type {Function} */(spec[1]);
    var def = spec[2];
    self.formalParameters[optionKey] = type;
    self.formalParameterDefaults[optionKey] = def;
  });
  this.processOptions(opt_options);
};

/**
 * @type {Object.<string,Function>}
 */
pcmws.api.RestService.prototype.formalParameters;

/**
 * @type {Object.<string,*>}
 */
pcmws.api.RestService.prototype.formalParameterDefaults;

/**
 * @description
 * Contains the service URL, which is the hostURL and path.
 * @type {pcmws.api.RestServiceURL}
 */
pcmws.api.RestService.prototype.serviceURL_;

/**
 * @description
 * Returns the combination of the host and path of the for this particular service.
 * @return {pcmws.api.RestServiceURL}
 * @this {pcmws.api.RestService}
 *
 */
pcmws.api.RestService.prototype.getServiceURL = function () {
  return this.serviceURL_;
};



/**
 * This method is meant to clone this object from its given options.
 * This method must be overridden or it will throw an error.
 *
 */
pcmws.api.RestService.prototype.clone = function () {
  throw "Needs to be overridden by the particular service";
  // constructor(this.toServiceOptions());
};

/**
 * This function processes options for both URL creation and requests.
 * @param {Object=} opt_options Options
 * @protected
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.processOptions = function (opt_options) {

  var options = opt_options !== undefined ? opt_options : {};
  var self = this;
  Object.keys(/** @type {!Object} */(this.formalParameters)).forEach(function (optionKey) {
    if (self.formalParameters.hasOwnProperty(optionKey)) {
      var value = options[optionKey];
      if (value === undefined) {
        value = self.formalParameterDefaults[optionKey];
      }
      if (value !== undefined) {
        /** @constructor @param {Object} options */
        //var constructor = /** @type {function(new:constructor, Object)} */(self.formalParameters[optionKey]);
        //self[optionKey] = (new constructor(/** @type {!Object} */(value)));
        var constructor = self.formalParameters[optionKey];
        self[optionKey] = new constructor(value);
      } else {
        var param = self[optionKey];
        if (param instanceof pcmws.api.Param) {
          self[optionKey] = param;
        }
      }
    }
  });
};

/**
 * Returns the relevant properties.
 * @returns {Object}
 * @protected
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.toServiceOptions = function () {
  var opts = {};
  var self = this;
  Object.keys(/** @type {!Object} */(this.formalParameters)).forEach(function (optionKey) {
    if (self.formalParameters.hasOwnProperty(optionKey)) {
      if (self[optionKey] !== undefined) {
        var val = self[optionKey];
        opts[optionKey] = val.getValue();  // TODO: checkedValue?
      }
    }
  });
  return opts;
};

/**
 *
 * @param {Object=} opt_options
 * @returns {Array}
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.getParamsArray = function(opt_options) {
  var service = this;
  if (opt_options !== undefined) {
    service = this.clone();
    service.processOptions(opt_options);
  }
  var params = [];
  Object.keys(/** @type {!Object} */(service.formalParameters)).forEach(function (optionKey) {
    if (service.formalParameters.hasOwnProperty(optionKey)) {
      if (service[optionKey] instanceof pcmws.api.Param) {
        params.push(service[optionKey]);
      }
    }
  });
  return params;
};

/**
 * This method performs a retrieval.
 * @param {Object} input
 * @param {Function} success
 * @param {Function} failure
 * @abstract
 */
pcmws.api.RestService.prototype.get = function (input, success, failure) {};

/**
 * This method performs an add.
 * @param {Object} input
 * @param {Function} success
 * @param {Function} failure
 */
pcmws.api.RestService.prototype.add = function (input, success, failure) {
  throw "Not implemented, or applicable to the service.";
};

/**
 * This method performs an update.
 * @param {Object} input
 * @param {Function} success
 * @param {Function} failure
 */
pcmws.api.RestService.prototype.update = function (input, success, failure) {
  throw "Not implemented, or applicable to the service.";
};

/**
 * This method performs a delete.
 * @param {Object} input
 * @param {Function} success
 * @param {Function} failure
 */
pcmws.api.RestService.prototype.delete = function (input, success, failure) {
  throw "Not implemented, or applicable to the service.";
};

/**
 * This function returns the major version number of MSIE
 * (Microsoft Internet Explorer) from the navigator.userAgent
 * property. If not, MSIE, then -1 is returned;
 *
 * @returns {number} major version number
 */
pcmws.api.RestService.prototype.getIEMajorVersion = function(){
  var agent = navigator.userAgent;
  var matches = agent.match(/MSIE\s?(\d+)(?:\.(\d+))?/i);
  return (matches !== null ? parseInt(matches[1],10) : -1);
};


/**
 * This method constructs the URL using the path and the parameters.
 * @param {string} path
 * @param {Array.<pcmws.api.Param>} paramsArray
 * @returns {string}
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.constructURL = function (path, paramsArray) {
  function not_null(v) {
    return !!v;
  }
  var params = paramsArray.map(function (param) {return param.getURLParam();});
  params = params.filter(not_null);
  var query = params.length > 0 ? '?' + params.join('&') : '';
  return this.getServiceURL().hostURL + path + query;
};

/**
 * This method returns a pcmws.api.XMLHttpRequest if the
 * response type was 'json' and it didn't work in the browser.
 * Some browsers do not do the conversion. It is used in all
 * xhr* methods and wraps the response xhr.
 * @param {string?} responseType
 * @param {XMLHttpRequest} xhr
 * @return {XMLHttpRequest}
 * @private
 */
pcmws.api.RestService.prototype.jsonFix_ = function (responseType, xhr) {
  var nxhr = xhr;
  try {
    if (responseType === 'json') {
      var response = xhr.response;
      if (response) {
        if (typeof response === 'string') {
          var obj = /** @type {Object} */ (JSON.parse(response));
          nxhr = new pcmws.api.XMLHttpRequest(xhr, obj);
        }
      }
    }
  } catch (e) {
  }
  return nxhr;
};

/**
 * Adds headers to an XHR.
 * Notably, this implementation does NOT take into consideration
 * multiple occurrences of the same header.
 * @param {XMLHttpRequest} xhr
 * @param {Object} headers
 * @private
 */
pcmws.api.RestService.prototype.addHeaders_ = function (xhr, headers) {
  if (headers) {
    Object.keys(headers).forEach(function(key) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    });
  }
};
/**
 * @param {string} url
 * @param {string} method
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {string|null} data
 * @param {Function} success
 * @param {Function} failure
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.xhrInvoke = function (url, method, type, headers, data, success, failure) {
  var self = this;
  var xhr = new XMLHttpRequest();
  xhr.open(method, url, true);
  if (type) {
    xhr.responseType = type;
  }
  this.addHeaders_(xhr, headers);
  xhr.onload = function (event) {
    if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
      success.call(self, self.jsonFix_(type, xhr));
    } else {
      failure.call(self, self.jsonFix_(type, xhr));
    }
  };
  xhr.onerror = function () {
    failure.call(self, self.jsonFix_(type, xhr));
  };
  if (data) {
    xhr.send(data);
  } else {
    xhr.send();
  }
};

/**
 *
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {Function} success
 * @param {Function} failure
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.xhrGet = function (url, type, headers, success, failure) {
  this.xhrInvoke(url, 'GET', type, headers, null, success, failure);
};
/**
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {string|null} data
 * @param {Function} success
 * @param {Function} failure
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.xhrPost = function (url, type, headers, data, success, failure) {
  this.xhrInvoke(url, 'POST', type, headers, data, success, failure);
};

/**
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {string|null} data
 * @param {Function} success
 * @param {Function} failure
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.xhrPut = function (url, type, headers, data, success, failure) {
  this.xhrInvoke(url, 'PUT', type, headers, data, success, failure);
};


/**
 * @param {string} url
 * @param {string|null} type
 * @param {Object|null} headers
 * @param {Function} success
 * @param {Function} failure
 * @this {pcmws.api.RestService}
 */
pcmws.api.RestService.prototype.xhrDelete = function (url, type, headers, success, failure) {
  this.xhrInvoke(url, 'DELETE', type, headers, null, success, failure);
};
goog.provide('pcmws.api.AvoidFavorSetsRestService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.AvoidFavorSetsAddOptions');
goog.require('pcmws.api.AvoidFavorSetsDeleteOptions');
goog.require('pcmws.api.AvoidFavorSetsGetOptions');
goog.require('pcmws.api.AvoidFavorSetsRestServiceOptions');
goog.require('pcmws.api.AvoidFavorSetsRestServiceURL');
goog.require('pcmws.api.AvoidFavorSetsUpdateOptions');
goog.require('pcmws.api.EncodedParam');
goog.require('pcmws.api.RestService');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.AvoidFavorSetsRestServiceOptions=} opt_options
 * @extends {pcmws.api.RestService}
 * @constructor
 *
 */
pcmws.api.AvoidFavorSetsRestService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken]
  ];
  pcmws.api.AvoidFavorSetsRestService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.AvoidFavorSetsRestServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.AvoidFavorSetsRestServiceURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.AvoidFavorSetsRestService, pcmws.api.RestService);


/**
 * @override
 * @returns {pcmws.api.AvoidFavorSetsRestService}
 * @this {pcmws.api.AvoidFavorSetsRestService}
 */
pcmws.api.AvoidFavorSetsRestService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.AvoidFavorSetsRestServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.AvoidFavorSetsRestService(opts);
};


/**
 * This method performs a retrieval.
 * @param {Object} input See {@link pcmws.api.AvoidFavorSetsGetOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.AvoidFavorSetsRestService}
 *
 */
pcmws.api.AvoidFavorSetsRestService.prototype.get = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.AvoidFavorSetsGetOptions} */(input);
  var setId = input1.id || -1;
  var path = this.getServiceURL().path + '/' + setId;
  path = path.replace('{XDR}', '');
  var detail = !!input1.detail;
  var headers = {
    'Content-Type' : 'application/json'
  };
  var params = this.getParamsArray().concat([
    new pcmws.api.BooleanParam('detail', detail),
    new pcmws.api.EncodedParam('tag', input1.tag),
    new pcmws.api.EncodedParam('name', input1.name)
  ]);
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, 'GET', 'json', headers, null, function (xhr) {
    if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
      if (xhr.response instanceof Array) {
        pass(xhr.response);
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};

/**
 * This method performs an add.
 * @param {Object} input See {@link pcmws.api.AvoidFavorSetsAddOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.AvoidFavorSetsRestService}
 *
 */
pcmws.api.AvoidFavorSetsRestService.prototype.add = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.AvoidFavorSetsAddOptions} */(input);
  var path = this.getServiceURL().path;
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  nparams.push(new pcmws.api.EncodedParam('name', input1.name));
  nparams.push(new pcmws.api.EncodedParam('tag', input1.tag));
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  path = path.replace('{XDR}', '');
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, 'POST', 'json', headers, null, function (xhr) {
    if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
      if (xhr.response) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
/**
 * This method performs an update.
 * @param {Object} input See {@link pcmws.api.AvoidFavorSetsUpdateOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.AvoidFavorSetsRestService}
 *
 */
pcmws.api.AvoidFavorSetsRestService.prototype.update = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.AvoidFavorSetsUpdateOptions} */(input);
  var setId = input1.id;
  var path = this.getServiceURL().path;
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  nparams = nparams.concat([
    new pcmws.api.EncodedParam('name', input1.name),
    new pcmws.api.EncodedParam('tag', input1.tag)
  ]);
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  var ieMajorVersion = this.getIEMajorVersion();
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/' + setId + '/update';
    method = 'POST';
  } else {
    path = path.replace('{XDR}', '') + '/' + setId;
    method = 'PUT';
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, null, function (xhr) {
    if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
      if (xhr.response) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};

/**
 * This method performs an delete.
 * @param {Object} input See {@link pcmws.api.AvoidFavorSetsDeleteOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.AvoidFavorSetsRestService}
 *
 */
pcmws.api.AvoidFavorSetsRestService.prototype.delete = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.AvoidFavorSetsDeleteOptions} */(input);
  var setId = input1.id;
  var path = this.getServiceURL().path;
  var ieMajorVersion = this.getIEMajorVersion();
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/' + setId + '/delete';
    method = 'POST';
  } else {
    path = path.replace('{XDR}', '') + '/' + setId;
    method = 'DELETE';
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, null, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
goog.provide('alk.service.AvoidFavorSetsService');

goog.require('alk.service.RestService');
goog.require('pcmws.api.AvoidFavorSetsRestService');

goog.require('alkx.AvoidFavorSetsServiceOptions');
goog.require('alkx.AvoidFavorSetsServiceGetOptions');
goog.require('alkx.AvoidFavorSetsServiceGetResponse');
goog.require('alkx.AvoidFavorSetsServiceAddOptions');
goog.require('alkx.AvoidFavorSetsServiceAddResponse');
goog.require('alkx.AvoidFavorSetsServiceDeleteOptions');
goog.require('alkx.AvoidFavorSetsServiceDeleteResponse');

/**
 * @classdesc
 * An instance of this class forms access to the ALK Custom Avoid/Favor Sets Service.
 *
 * @description
 * This constructor creates a Service object for the ALK Custom Avoid/Favor Sets Service.
 *
 * @param {alkx.AvoidFavorSetsServiceOptions=} opt_options
 * @constructor
 * @extends {alk.service.RestService}
 * @api
 */
alk.service.AvoidFavorSetsService = function (opt_options) {
  alk.service.AvoidFavorSetsService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.avoidFavorSetsService = this.pcmws = new pcmws.api.AvoidFavorSetsRestService(this.pcmServiceOptions);
};
goog.inherits(alk.service.AvoidFavorSetsService, alk.service.RestService);

/**
 *
 * @param {alkx.AvoidFavorSetsServiceGetOptions?} input
 * @param {function(alkx.AvoidFavorSetsServiceGetResponse)=} success
 * @param {function(alkx.AvoidFavorSetsServiceGetResponse)=} failure
 * @this {alk.service.AvoidFavorSetsService}
 * @api
 */
alk.service.AvoidFavorSetsService.prototype.get = function (input, success, failure) {
  this.avoidFavorSetsService.get(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
/**
 *
 * @param {alkx.AvoidFavorSetsServiceAddOptions?} input
 * @param {function(alkx.AvoidFavorSetsServiceAddResponse)=} success
 * @param {function(alkx.AvoidFavorSetsServiceAddResponse)=} failure
 * @this {alk.service.AvoidFavorSetsService}
 * @api
 */
alk.service.AvoidFavorSetsService.prototype.add = function (input, success, failure) {
  this.avoidFavorSetsService.add(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 *
 * @param {alkx.AvoidFavorSetsServiceUpdateOptions} input
 * @param {function(alkx.AvoidFavorSetsServiceUpdateResponse)=} success
 * @param {function(alkx.AvoidFavorSetsServiceUpdateResponse)=} failure
 * @this {alk.service.AvoidFavorSetsService}
 * @api
 */
alk.service.AvoidFavorSetsService.prototype.update = function (input, success, failure) {
  this.avoidFavorSetsService.update(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 *
 * @param {alkx.AvoidFavorSetsServiceDeleteOptions} input
 * @param {function(alkx.AvoidFavorSetsServiceDeleteResponse)=} success
 * @param {function(alkx.AvoidFavorSetsServiceDeleteResponse)=} failure
 * @this {alk.service.AvoidFavorSetsService}
 * @api
 */
alk.service.AvoidFavorSetsService.prototype.delete = function (input, success, failure) {
  this.avoidFavorSetsService.delete(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
goog.provide('pcmws.api.AvoidFavorsRestServiceURL');

goog.require('pcmws.api');
goog.require('pcmws.api.RestServiceURL');
/**
 * @classdesc
 * This class is used to hold the host and base path of a URL for the Custom Places Rest Service.
 * @param {string=} hosturl The optional host. If undefined it will use the prototype.hostURL;
 * @param {string=} path The path. See {@link pcmws.api.AvoidFavorsRestServiceURL#path} for documentation.
 * @extends {pcmws.api.RestServiceURL}
 * @constructor
 *
 */
pcmws.api.AvoidFavorsRestServiceURL = function (hosturl, path) {
  pcmws.api.AvoidFavorsRestServiceURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.AvoidFavorsRestServiceURL, pcmws.api.RestServiceURL);

/**
 * @description
 * This value contains the path of the url. The path should contain the following
 * strings:
 *     '{XDR}'   This string gets replaced with 'XDR/', and is used only
 *               when dealing with IE 8 & 9.
 *     '{setId}' This string gets replaced with the Set Id number for which the
 *               places belong.
 * Example:
 *   new pcmws.api.AvoidFavorsRestServiceURL(
 *       'https://pcmiler.alk.com',
 *       '/apis/rest/v1.0/service.svc/{XDR}avoidFavorSets/{setId}/avoidFavor');
 *
 * @type {string}
 *
 */
pcmws.api.AvoidFavorsRestServiceURL.prototype.path;
goog.provide('pcmws.val.RegionNum');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive Region parameters.
 *
 * @enum {number}
 * 
 */
pcmws.val.RegionNum = {

  /**
   * @description
   * This value designates Africa.
   * 
   */
  AF: 1,

  /**
   * @description
   * This value designates Asia
   * 
   */
  AS: 2,

  /**
   * @description
   * This value designates Europe.
   * 
   */
  EU: 3,

  /**
   * @description
   * This value designates North America.
   * 
   */
  NA: 4,

  /**
   * @description
   * This value designates Other Countries.
   * 
   */
  OC: 5,

  /**
   * @description
   * This value designates South America.
   * 
   */
  SA: 6,

  /**
   * @description
   * This value designates Mediterranean.
   * 
   */
  ME: 7
};
goog.provide('pcmws.api.AvoidFavorsRestService');

goog.require('pcmws.api');
goog.require('pcmws.api.AFPoint');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.AvoidFavorMapLink');
goog.require('pcmws.api.AvoidFavorsAddOptions');
goog.require('pcmws.api.AvoidFavorsDeleteOptions');
goog.require('pcmws.api.AvoidFavorsRestServiceOptions');
goog.require('pcmws.api.AvoidFavorsRestServiceURL');
goog.require('pcmws.api.RestService');
goog.require('pcmws.api.SetId');
goog.require('pcmws.val');
goog.require('pcmws.val.RegionNum');



/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.AvoidFavorsRestServiceOptions=} opt_options
 * @extends {pcmws.api.RestService}
 * @constructor
 *
 */
pcmws.api.AvoidFavorsRestService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['setId', pcmws.api.SetId]
  ];
  pcmws.api.AvoidFavorsRestService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.AvoidFavorsRestServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.AvoidFavorsRestServiceURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.AvoidFavorsRestService, pcmws.api.RestService);


/**
 * @override
 * @returns {pcmws.api.AvoidFavorsRestService}
 * @this {pcmws.api.AvoidFavorsRestService}
 */
pcmws.api.AvoidFavorsRestService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.AvoidFavorsRestServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.AvoidFavorsRestService(opts);
};

/**
 * @inheritDoc
 */
pcmws.api.AvoidFavorsRestService.prototype.get = function (input, success, failure) {
  throw 'Not implemented. Use AvoidFavorSetsRestService.';
};

/**
 * This method performs an add.
 * @param {Object} input See {@link pcmws.api.AvoidFavorsAddOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.AvoidFavorsRestService}
 *
 */
pcmws.api.AvoidFavorsRestService.prototype.add = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.AvoidFavorsAddOptions} */(input);
  var nparams = this.getParamsArray();
  var params = [];
  var headers = {
    'Content-Type' : 'application/json'
  };
  /** @type {string!} */
  var setId = nparams.reduce(function (a, v) {
      if (v.name === 'setId') {
        return v.getCheckedValue();
      } else if (v.name === "authToken") {
        headers['Authorization'] = v.getCheckedValue();
      } else {
        params.push(v);
        return a;
      }
    }, null) || '' + (input1.setId || '');

  var path = this.getServiceURL().path.replace('{setId}', setId);
  /** @type {pcmws.api.AvoidFavorMapLink!} */
  var mapLink = input1.avoidFavorMapLink || {};
  /** @type {pcmws.api.AFPoint!} */
  var afPoint = mapLink.afPoint || {};
  /** @type {number} */
  var type = ['f','F','2',2].indexOf(afPoint.Type) > 0 ? 2 : 1;
  /** @type {number} */
  var region = /** @type {number!} */(pcmws.val.toEnumNumber(mapLink.dataRegion, pcmws.val.RegionNum, 1, 4)); // 4 - NA
  var linkToAdd = {
    MapBound1: [mapLink.mapBounds[0], mapLink.mapBounds[3]],
    MapBound2: [mapLink.mapBounds[2], mapLink.mapBounds[1]],
    Projection: mapLink.projection,
    AFPoint: {
      Type: type,
      Point: afPoint.point,
      Comment: afPoint.comment
    },
    Region: region
  };
  var ieMajorVersion = this.getIEMajorVersion();
  var data = '';
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/add';
    params = [
      new pcmws.api.Param('jsonAFMapLink', JSON.stringify(linkToAdd))
    ];
  } else {
    path = path.replace('{XDR}','');
    data = JSON.stringify({
      avoidFavorMapLink: linkToAdd
    });
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, 'POST', 'json', headers, data, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (xhr.response instanceof Array) {
          pass(xhr.response);
        } else if (typeof xhr.response === 'object') {
          if (xhr.response.hasOwnProperty('XDRAddAvoidFavorResult')) {
            pass(xhr.response['XDRAddAvoidFavorResult']);
          } else if (xhr.response.hasOwnProperty('AddAvoidFavorResult')) {
            pass(xhr.response['AddAvoidFavorResult']);
          } else {
            fail(xhr.response);
          }
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
/**
 * @inheritDoc
 *
 */
pcmws.api.AvoidFavorsRestService.prototype.update = function (input, success, failure) {
  throw "Not implemented, or not applicable.";
};

/**
 * This method performs an update.
 * @param {Object} input See {@link pcmws.api.AvoidFavorsDeleteOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.AvoidFavorsRestService}
 *
 */
pcmws.api.AvoidFavorsRestService.prototype.delete = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.AvoidFavorsDeleteOptions} */(input);
  var nparams = this.getParamsArray();
  var params = [];
  var headers = {
    'Content-Type' : 'application/json'
  };
  /** @type {string|null} */
  var setId = nparams.reduce(function (a, v) {
      if (v.name === 'setId') {
        return v.getCheckedValue();
      } else if (v.name === "authToken") {
        headers['Authorization'] = v.getCheckedValue();
      } else {
        params.push(v);
        return a;
      }
    }, null) || '' + (input1.setId || '');

  /** @type {string!} */
  var afId = '' + (input1.afId || '');
  var path = this.getServiceURL().path.replace('{setId}', setId);
  var ieMajorVersion = this.getIEMajorVersion();
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/delete/' + afId;
    method = 'POST';
  } else {
    path = path.replace('{XDR}','') + '/' + afId;
    method = 'DELETE';
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, null, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
goog.provide('alk.service.AvoidFavorsService');

goog.require('alk.service.RestService');
goog.require('pcmws.api.AvoidFavorsRestService');

goog.require('alkx.AvoidFavorsServiceOptions');
goog.require('alkx.AvoidFavorsServiceAddOptions');
goog.require('alkx.AvoidFavorsServiceAddResponse');
goog.require('alkx.AvoidFavorsServiceDeleteOptions');
goog.require('alkx.AvoidFavorsServiceDeleteResponse');

/**
 * @classdesc
 * An instance of this class forms access to the ALK Avoid/Favor Service.
 *
 * @description
 * This constructor creates a Service object to access the ALK Avoid/Favor Service.
 *
 * @param {alkx.AvoidFavorsServiceOptions=} opt_options
 * @constructor
 * @extends {alk.service.RestService}
 * @api
 */
alk.service.AvoidFavorsService = function (opt_options) {
  alk.service.AvoidFavorsService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.avoidFavorsService = this.pcmws = new pcmws.api.AvoidFavorsRestService(this.pcmServiceOptions);
};
goog.inherits(alk.service.AvoidFavorsService, alk.service.RestService);

/**
 *
 * @param {alkx.AvoidFavorsServiceAddOptions?} input
 * @param {function(alkx.AvoidFavorsServiceAddResponse)=} success
 * @param {function(alkx.AvoidFavorsServiceAddResponse)=} failure
 * @this {alk.service.AvoidFavorsService}
 * @api
 */
alk.service.AvoidFavorsService.prototype.add = function (input, success, failure) {
  this.avoidFavorsService.add(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 *
 * @param {alkx.AvoidFavorsServiceDeleteOptions} input
 * @param {function(alkx.AvoidFavorsServiceDeleteResponse)=} success
 * @param {function(alkx.AvoidFavorsServiceDeleteResponse)=} failure
 * @this {alk.service.AvoidFavorsService}
 * @api
 */
alk.service.AvoidFavorsService.prototype.delete = function (input, success, failure) {
  this.avoidFavorsService.delete(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
goog.provide('pcmws.api.CountriesSingleSearchService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.CountriesSingleSearchServiceOptions');
goog.require('pcmws.api.CountriesSingleSearchURL');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.StaticService');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for the
 * Single Search Countries service.
 * @param {pcmws.api.CountriesSingleSearchServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.CountriesSingleSearchService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region]
  ];
  pcmws.api.CountriesSingleSearchService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.CountriesSingleSearchServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.CountriesSingleSearchURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.CountriesSingleSearchService, pcmws.api.StaticService);


/**
 * @override
 * @returns {pcmws.api.CountriesSingleSearchService}
 * @this {pcmws.api.CountriesSingleSearchService}
 */
pcmws.api.CountriesSingleSearchService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.CountriesSingleSearchServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.CountriesSingleSearchService(opts);
};


/**
 * @inheritDoc
 * @this {pcmws.api.CountriesSingleSearchService}
 */
pcmws.api.CountriesSingleSearchService.prototype.getURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};

/**
 * @inheritDoc
 * @this {pcmws.api.CountriesSingleSearchService}
 */
pcmws.api.CountriesSingleSearchService.prototype.getAttributionURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceAttributionURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};
goog.provide('alk.service.CountriesSingleSearchService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.CountriesSingleSearchService');

goog.require('alkx.CountriesSingleSearchServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Countries Single Search Service.
 *
 * @description
 * This constructor creates a Service object to access the ALK Countries Single Search Service.
 *
 * @param {alkx.CountriesSingleSearchServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.CountriesSingleSearchService = function (opt_options) {
  alk.service.CountriesSingleSearchService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.countriesSingleSearchService = this.pcmws = new pcmws.api.CountriesSingleSearchService(this.pcmServiceOptions);
};
goog.inherits(alk.service.CountriesSingleSearchService, alk.service.Service);

/**
 * @description
 * The ALK Countries Single Service Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.CountriesSingleSearchService} object.
 *
 * @type {pcmws.api.CountriesSingleSearchService}
 */
alk.service.CountriesSingleSearchService.prototype.countriesSingleSearchService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from Countries Single Search Service returns a JSON object
 * containing a single {@link alkx.CountriesSingleSearchServiceResult}.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.CountriesSingleSearchService}.
 * @param {Object=} obj The JSON response from the {@link alk.service.CountriesSingleSearchService}.
 * @returns {Object} Containing the countriesSingleSearchServiceOptions and if a successful call
 *  also contains a JSON object containing the points of interest requested.
 * @override
 * @api
 */
alk.service.CountriesSingleSearchService.prototype.processResponse = function (options, obj) {
  return {
    countriesSingleSearchServiceOptions: options,
    result: obj
  };
};

/**
 * @description
 * This method performs a call to the Countries Single Search Service to retrieve Country specifications.
 * @param {(alkx.CountriesSingleSearchServiceOptions|null|function(alkx.CountriesSingleSearchServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.CountriesSingleSearchServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.CountriesSingleSearchService}
 * @api
 */
alk.service.CountriesSingleSearchService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.CountriesSingleSearchServiceOptions} */
  var options = {};
  /** function(alkx.CountriesSingleSearchServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.CountriesSingleSearchServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.CountriesSingleSearchService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('pcmws.api.CustomCategoriesRestService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.CustomCategoriesAddOptions');
goog.require('pcmws.api.CustomCategoriesGetOptions');
goog.require('pcmws.api.CustomCategoriesRestServiceOptions');
goog.require('pcmws.api.CustomCategoriesRestServiceURL');
goog.require('pcmws.api.CustomCategoriesUpdateOptions');
goog.require('pcmws.api.RestService');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.CustomCategoriesRestServiceOptions=} opt_options
 * @extends {pcmws.api.RestService}
 * @constructor
 *
 */
pcmws.api.CustomCategoriesRestService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken]
  ];
  pcmws.api.CustomCategoriesRestService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.CustomCategoriesRestServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.CustomCategoriesRestServiceURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.CustomCategoriesRestService, pcmws.api.RestService);

/**
 * @override
 * @returns {pcmws.api.CustomCategoriesRestService}
 * @this {pcmws.api.CustomCategoriesRestService}
 */
pcmws.api.CustomCategoriesRestService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.CustomCategoriesRestServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.CustomCategoriesRestService(opts);
};

/**
 * This method performs a retrieval.
 * @param {Object} input See {@link pcmws.api.CustomCategoriesGetOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomCategoriesRestService}
 *
 */
pcmws.api.CustomCategoriesRestService.prototype.get = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomCategoriesGetOptions} */(input);
  var id = input1.id;
  var params = this.getParamsArray().concat([
    new pcmws.api.Param('tag', input1.tag),
    new pcmws.api.Param('catName', input1.name)
  ]);
  var path = this.getServiceURL().path;
  path = path.replace('{XDR}','') + '/' + id;
  var url = this.constructURL(path, params);
  this.xhrGet(url, 'json', {}, function (xhr) {
    if (typeof success === 'function') {
      success(xhr.response);
    }
  }, function (xhr) {
    if (typeof failure === 'function') {
      failure(xhr.response);
    }
  });
};

/**
 * This method performs an add.
 * @param {Object} input See {@link pcmws.api.CustomCategoriesAddOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomCategoriesRestService}
 *
 */
pcmws.api.CustomCategoriesRestService.prototype.add = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomCategoriesAddOptions} */(input);
  var category = {
    Name: input1.name,
    Icon: input1.icon,
    IconURL: input1.iconURL,
    Tag: input1.tag
  };
  var path = this.getServiceURL().path;
  var ieMajorVersion = this.getIEMajorVersion();
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  var data = '';
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/add';
    params = params.concat([
      new pcmws.api.Param('jsonCategory', JSON.stringify(category))
    ]);
  } else {
    path = path.replace('{XDR}', '');
    data = JSON.stringify({
      category: category
    });
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, 'POST', 'json', headers, data, function (xhr) {
    if (xhr.response) {
      if (typeof xhr.response === 'number') {
        pass(xhr.response);
      } else if (typeof xhr.response === 'object') {
        if (xhr.response.hasOwnProperty('AddCustomCategoryResult')) {
          pass(xhr.response['AddCustomCategoryResult']);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    if (typeof failure === 'function') {
      fail(xhr.response);
    }
  });
};

/**
 * This method performs an update.
 * @param {Object} input See {@link pcmws.api.CustomCategoriesUpdateOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomCategoriesRestService}
 *
 */
pcmws.api.CustomCategoriesRestService.prototype.update = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomCategoriesUpdateOptions} */(input);
  var id = input1.id;
  var category = {
    Id: id,
    Name: input1.name,
    Icon: input1.icon,
    IconURL: input1.iconURL,
    Tag: input1.tag
  };
  var path = this.getServiceURL().path;
  var ieMajorVersion = this.getIEMajorVersion();
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  var data = '';
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/update';
    method = 'POST';
    params = params.concat([
      new pcmws.api.Param('jsonCategory', JSON.stringify(category))
    ]);
  } else {
    path = path.replace('{XDR}', '');
    method = 'PUT';
    data = JSON.stringify({
      category: category
    });
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, data, function (xhr) {
    if (xhr.response) {
      if (typeof xhr.response === 'number') {
        pass(xhr.response);
      } else if (typeof xhr.response === 'object') {
        if (xhr.response.hasOwnProperty('UpdateCustomCategoryResult')) {
          pass(xhr.response['UpdateCustomCategoryResult']);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    if (typeof failure === 'function') {
      fail(xhr.response);
    }
  });
};

/**
 * This method is not implemented on the service;
 * @param {Object?} input
 * @param {Function} success
 * @param {Function} failure
 * @override
 *
 */
pcmws.api.CustomCategoriesRestService.prototype.delete = function (input, success, failure) {
  throw "Not implemented.";
};
goog.provide('alk.service.CustomCategoriesService');

goog.require('alk.service.RestService');
goog.require('pcmws.api.CustomCategoriesRestService');

goog.require('alkx.CustomCategoriesServiceOptions');
goog.require('alkx.CustomCategoriesServiceGetOptions');
goog.require('alkx.CustomCategoriesServiceGetResponse');
goog.require('alkx.CustomCategoriesServiceAddOptions');
goog.require('alkx.CustomCategoriesServiceAddResponse');
goog.require('alkx.CustomCategoriesServiceUpdateOptions');
goog.require('alkx.CustomCategoriesServiceUpdateResponse');

/**
 * @classdesc
 * An instance of this class forms access to the ALK Custom Categories Service.
 *
 * @description
 * This constructor creates a Service object with which to access the ALK
 * Custom Categories Service.
 *
 * @param {alkx.CustomCategoriesServiceOptions=} opt_options
 * @constructor
 * @extends {alk.service.RestService}
 * @api
 */
alk.service.CustomCategoriesService = function (opt_options) {
  alk.service.CustomCategoriesService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.customCategoriesService = this.pcmws = new pcmws.api.CustomCategoriesRestService(this.pcmServiceOptions);
};
goog.inherits(alk.service.CustomCategoriesService, alk.service.RestService);

/**
 * This method accesses the service to retrieve the Custom Categories.
 * @param {alkx.CustomCategoriesServiceGetOptions?} input
 * @param {function(alkx.CustomCategoriesServiceGetResponse)=} success
 * @param {function(alkx.CustomCategoriesServiceGetResponse)=} failure
 * @this {alk.service.CustomCategoriesService}
 * @api
 */
alk.service.CustomCategoriesService.prototype.get = function (input, success, failure) {
  this.customCategoriesService.get(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
/**
 *
 * This method accesses the service to add Custom Categories.
 * @param {alkx.CustomCategoriesServiceAddOptions?} input
 * @param {function(alkx.CustomCategoriesServiceAddResponse)=} success
 * @param {function(alkx.CustomCategoriesServiceAddResponse)=} failure
 * @this {alk.service.CustomCategoriesService}
 * @api
 */
alk.service.CustomCategoriesService.prototype.add = function (input, success, failure) {
  this.customCategoriesService.add(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 *
 * This method accesses the service to update Custom Categories.
 * @param {alkx.CustomCategoriesServiceUpdateOptions} input
 * @param {function(alkx.CustomCategoriesServiceUpdateResponse)=} success
 * @param {function(alkx.CustomCategoriesServiceUpdateResponse)=} failure
 * @this {alk.service.CustomCategoriesService}
 * @api
 */
alk.service.CustomCategoriesService.prototype.update = function (input, success, failure) {
  this.customCategoriesService.update(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
goog.provide('pcmws.api.CustomPlaceSetsRestService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.CustomPlaceSetsAddOptions');
goog.require('pcmws.api.CustomPlaceSetsDeleteOptions');
goog.require('pcmws.api.CustomPlaceSetsGetOptions');
goog.require('pcmws.api.CustomPlaceSetsRestServiceOptions');
goog.require('pcmws.api.CustomPlaceSetsRestServiceURL');
goog.require('pcmws.api.CustomPlaceSetsUpdateOptions');
goog.require('pcmws.api.EncodedParam');
goog.require('pcmws.api.RestService');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.CustomPlaceSetsRestServiceOptions=} opt_options
 * @extends {pcmws.api.RestService}
 * @constructor
 *
 */
pcmws.api.CustomPlaceSetsRestService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken]
  ];
  pcmws.api.CustomPlaceSetsRestService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.CustomPlaceSetsRestServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.CustomPlaceSetsRestServiceURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.CustomPlaceSetsRestService, pcmws.api.RestService);


/**
 * @override
 * @returns {pcmws.api.CustomPlaceSetsRestService}
 * @this {pcmws.api.CustomPlaceSetsRestService}
 */
pcmws.api.CustomPlaceSetsRestService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.CustomPlaceSetsRestServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.CustomPlaceSetsRestService(opts);
};


/**
 * This method performs a retrieval.
 * @param {Object} input See {@link pcmws.api.CustomPlaceSetsGetOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomPlaceSetsRestService}
 *
 */
pcmws.api.CustomPlaceSetsRestService.prototype.get = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomPlaceSetsGetOptions} */(input);
  var setId = input1.id || -1;
  var path = this.getServiceURL().path + '/' + setId;
  path = path.replace('{XDR}', '');
  var includePlaces = !!input1.includePlaces;
  var corner1;
  var corner2;
  if (includePlaces && input1.extent) {
    var extent = /** @type {Array.<number>!} */(input1.extent);
    corner1 = ol.extent.getTopLeft(extent);
    corner2 = ol.extent.getBottomRight(extent);
  }
  var headers = {
    'Content-Type' : 'application/json'
  };
  var params = this.getParamsArray().concat([
    new pcmws.api.BooleanParam('includePlaces', includePlaces),
    new pcmws.api.EncodedParam('tag', input1.tag),
    new pcmws.api.EncodedParam('placeName', input1.placeName),
    new pcmws.api.EncodedParam('catId', input1.catId),
    new pcmws.api.EncodedParam('catName', input1.catName),
    new pcmws.api.LonLat('corner1', corner1),
    new pcmws.api.LonLat('corner2', corner2)
  ]);
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, 'GET', 'json', headers, null, function (xhr) {
    if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
      if (xhr.response instanceof Array) {
        pass(xhr.response);
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};

/**
 * This method performs an add.
 * @param {Object} input See {@link pcmws.api.CustomPlaceSetsAddOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomPlaceSetsRestService}
 *
 */
pcmws.api.CustomPlaceSetsRestService.prototype.add = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomPlaceSetsAddOptions} */(input);
  var path = this.getServiceURL().path;
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  nparams.push(new pcmws.api.EncodedParam('name', input1.name));
  nparams.push(new pcmws.api.EncodedParam('tag', input1.tag));
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  path = path.replace('{XDR}', '');
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, 'POST', 'json', headers, null, function (xhr) {
    if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
      if (xhr.response) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
/**
 * This method performs an update.
 * @param {Object} input See {@link pcmws.api.CustomPlaceSetsUpdateOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomPlaceSetsRestService}
 *
 */
pcmws.api.CustomPlaceSetsRestService.prototype.update = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomPlaceSetsUpdateOptions} */(input);
  var setId = input1.id;
  var path = this.getServiceURL().path;
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  nparams = nparams.concat([
    new pcmws.api.EncodedParam('name', input1.name),
    new pcmws.api.EncodedParam('tag', input1.tag)
  ]);
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  var ieMajorVersion = this.getIEMajorVersion();
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/' + setId + '/update';
    method = 'POST';
  } else {
    path = path.replace('{XDR}', '') + '/' + setId;
    method = 'PUT';
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, null, function (xhr) {
    if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
      if (xhr.response) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};

/**
 * This method performs an delete.
 * @param {Object} input See {@link pcmws.api.CustomPlaceSetsDeleteOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomPlaceSetsRestService}
 *
 */
pcmws.api.CustomPlaceSetsRestService.prototype.delete = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomPlaceSetsDeleteOptions} */(input);
  var setId = input1.id;
  var path = this.getServiceURL().path;
  var ieMajorVersion = this.getIEMajorVersion();
  var headers = {
    'Content-Type' : 'application/json'
  };
  var nparams = this.getParamsArray();
  var params = [];
  nparams.forEach(function(param) {
    if (param.name === 'authToken') {
      headers['Authorization']= param.getCheckedValue();
    } else {
      params.push(param);
    }
  });
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/' + setId + '/delete';
    method = 'POST';
  } else {
    path = path.replace('{XDR}', '') + '/' + setId;
    method = 'DELETE';
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, null, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
goog.provide('alk.service.CustomPlaceSetsService');

goog.require('alk.service.RestService');
goog.require('pcmws.api.CustomPlaceSetsRestService');

goog.require('alkx.CustomPlaceSetsServiceOptions');
goog.require('alkx.CustomPlaceSetsServiceGetOptions');
goog.require('alkx.CustomPlaceSetsServiceGetResponse');
goog.require('alkx.CustomPlaceSetsServiceAddOptions');
goog.require('alkx.CustomPlaceSetsServiceAddResponse');
goog.require('alkx.CustomPlaceSetsServiceUpdateOptions');
goog.require('alkx.CustomPlaceSetsServiceUpdateResponse');
goog.require('alkx.CustomPlaceSetsServiceDeleteOptions');
goog.require('alkx.CustomPlaceSetsServiceDeleteResponse');

/**
 * @classdesc
 * An instance of this class forms access to the ALK Custom Place Sets Service.
 * @description
 * This constructor creates a Service object that accesses the ALK Custom Place Sets Service.
 *
 * @param {alkx.CustomPlaceSetsServiceOptions=} opt_options
 * @constructor
 * @extends {alk.service.RestService}
 * @api
 */
alk.service.CustomPlaceSetsService = function (opt_options) {
  alk.service.CustomPlaceSetsService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.customPlaceSetsService = this.pcmws = new pcmws.api.CustomPlaceSetsRestService(this.pcmServiceOptions);
};
goog.inherits(alk.service.CustomPlaceSetsService, alk.service.RestService);

/**
 * This method retrieves Custom Place Sets.
 * @param {alkx.CustomPlaceSetsServiceGetOptions?} input
 * @param {function(alkx.CustomPlaceSetsServiceGetResponse)=} success
 * @param {function(alkx.CustomPlaceSetsServiceGetResponse)=} failure
 * @this {alk.service.CustomPlaceSetsService}
 * @api
 */
alk.service.CustomPlaceSetsService.prototype.get = function (input, success, failure) {
  this.customPlaceSetsService.get(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
/**
 * This method attempts to add a Place Set to the Custom Place Sets.
 * @param {alkx.CustomPlaceSetsServiceAddOptions?} input
 * @param {function(alkx.CustomPlaceSetsServiceAddResponse)=} success
 * @param {function(alkx.CustomPlaceSetsServiceAddResponse)=} failure
 * @this {alk.service.CustomPlaceSetsService}
 * @api
 */
alk.service.CustomPlaceSetsService.prototype.add = function (input, success, failure) {
  this.customPlaceSetsService.add(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 * This method updates an existing Place Set.
 * @param {alkx.CustomPlaceSetsServiceUpdateOptions} input
 * @param {function(alkx.CustomPlaceSetsServiceUpdateResponse)=} success
 * @param {function(alkx.CustomPlaceSetsServiceUpdateResponse)=} failure
 * @this {alk.service.CustomPlaceSetsService}
 * @api
 */
alk.service.CustomPlaceSetsService.prototype.update = function (input, success, failure) {
  this.customPlaceSetsService.update(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 * This method deletes a Custom Place Set.
 * @param {alkx.CustomPlaceSetsServiceDeleteOptions} input
 * @param {function(alkx.CustomPlaceSetsServiceDeleteResponse)=} success
 * @param {function(alkx.CustomPlaceSetsServiceDeleteResponse)=} failure
 * @this {alk.service.CustomPlaceSetsService}
 * @api
 */
alk.service.CustomPlaceSetsService.prototype.delete = function (input, success, failure) {
  this.customPlaceSetsService.delete(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
goog.provide('pcmws.api.CustomPlacesRestService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.CustomPlacesAddOptions');
goog.require('pcmws.api.CustomPlacesDeleteOptions');
goog.require('pcmws.api.CustomPlacesRestServiceOptions');
goog.require('pcmws.api.CustomPlacesRestServiceURL');
goog.require('pcmws.api.CustomPlacesUpdateOptions');
goog.require('pcmws.api.RestService');
goog.require('pcmws.api.SetId');
goog.require('pcmws.val');
goog.require('pcmws.val.RegionNum');



/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.CustomPlacesRestServiceOptions=} opt_options
 * @extends {pcmws.api.RestService}
 * @constructor
 *
 */
pcmws.api.CustomPlacesRestService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['setId', pcmws.api.SetId]
  ];
  pcmws.api.CustomPlacesRestService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.CustomPlacesRestServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.CustomPlacesRestServiceURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.CustomPlacesRestService, pcmws.api.RestService);


/**
 * @override
 * @returns {pcmws.api.CustomPlacesRestService}
 * @this {pcmws.api.CustomPlacesRestService}
 */
pcmws.api.CustomPlacesRestService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.CustomPlacesRestServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.CustomPlacesRestService(opts);
};

/**
 * @inheritDoc
 */
pcmws.api.CustomPlacesRestService.prototype.get = function (input, success, failure) {
  throw 'Not implemented. Use CustomPlaceSetsRestService.';
};

/**
 * This method performs an add.
 * @param {Object} input See {@link pcmws.api.CustomPlacesAddOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomPlacesRestService}
 *
 */
pcmws.api.CustomPlacesRestService.prototype.add = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomPlacesAddOptions} */(input);
  var nparams = this.getParamsArray();
  var params = [];
  var headers = {
    'Content-Type' : 'application/json'
  };
  /** @type {string!} */
  var setId = nparams.reduce(function (a, v) {
      if (v.name === 'setId') {
        return v.getCheckedValue();
      } else if (v.name === "authToken") {
        headers['Authorization'] = v.getCheckedValue();
      } else {
        params.push(v);
        return a;
      }
    }, null) || '' + (input1.setId || '');

  var path = this.getServiceURL().path.replace('{setId}', setId);
  /** @type {pcmws.api.CustomPlacesPlace!} */
  var place = input1.place || {};
  /** @type {pcmws.api.CustomPlacesAddress!} */
  var addr = place.address || {};
  /** @type {pcmws.api.CustomPlacesCoords!} */
  var coords = place.coords || {};
  var placeToAdd = {
    CategoryId: place.categoryId,
    Phone : place.phone,
    Address: {
      StreetAddress: addr.streetAddress,
      City: addr.city,
      State: addr.state,
      County: addr.county,
      Zip: addr.zip
    },
    Coords: {
      Lat: coords.lat,
      Lon: coords.lon
    },
    Region: pcmws.val.toEnumNumber(place.dataRegion, pcmws.val.RegionNum, 1, 4), // 4 - NA
    PlaceName: place.placeName
  };
  var ieMajorVersion = this.getIEMajorVersion();
  var data = '';
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/add';
    params = [
      new pcmws.api.Param('jsonPlaceToAdd', JSON.stringify(placeToAdd))
    ];
  } else {
    path = path.replace('{XDR}','');
    data = JSON.stringify({
      placeToAdd: placeToAdd
    });
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, 'POST', 'json', headers, data, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else if (typeof xhr.response === 'object') {
          if (xhr.response.hasOwnProperty('AddCustomPlaceResult')) {
            pass(xhr.response['AddCustomPlaceResult']);
          } else {
            fail(xhr.response);
          }
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
/**
 * This method performs an update.
 * @param {Object} input See {@link pcmws.api.CustomPlacesUpdateOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomPlacesRestService}
 *
 */
pcmws.api.CustomPlacesRestService.prototype.update = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomPlacesUpdateOptions} */(input);
  var nparams = this.getParamsArray();
  var params = [];
  var headers = {
    'Content-Type' : 'application/json'
  };
  /** @type {string!} */
  var setId = nparams.reduce(function (a, v) {
      if (v.name === 'setId') {
        return v.getCheckedValue();
      } else if (v.name === "authToken") {
        headers['Authorization'] = v.getCheckedValue();
      } else {
        params.push(v);
        return a;
      }
    }, null) || '' + (input1.setId || '');

  var path = this.getServiceURL().path.replace('{setId}', setId);
  /** @type {pcmws.api.CustomPlacesPlace!} */
  var place = input1.place || {};
  /** @type {pcmws.api.CustomPlacesAddress!} */
  var addr = place.address || {};
  /** @type {pcmws.api.CustomPlacesCoords!} */
  var coords = place.coords || {};
  var placeToUpdate = {
    Id: place.customPlaceId,
    CategoryId: place.categoryId,
    Phone : place.phone,
    Address: {
      StreetAddress: addr.streetAddress,
      City: addr.city,
      State: addr.state,
      County: addr.county,
      Zip: addr.zip
    },
    Coords: {
      Lat: coords.lat,
      Lon: coords.lon
    },
    Region: pcmws.val.toEnumNumber(place.dataRegion, pcmws.val.RegionNum, 1, 4), // 4 - NA
    PlaceName: place.placeName
  };
  var ieMajorVersion = this.getIEMajorVersion();
  var data = '';
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/update';
    method = 'POST';
    params = [
      new pcmws.api.Param('jsonPlaceToUpdate', JSON.stringify(placeToUpdate))
    ];
  } else {
    path = path.replace('{XDR}','');
    method = 'PUT';
    data = JSON.stringify({
      placeToUpdate: placeToUpdate
    });
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, data, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else if (typeof xhr.response === 'object') {
          if (xhr.response.hasOwnProperty('UpdateCustomPlaceResult')) {
            pass(xhr.response['UpdateCustomPlaceResult']);
          } else {
            fail(xhr.response);
          }
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};

/**
 * This method performs an update.
 * @param {Object} input See {@link pcmws.api.CustomPlacesDeleteOptions}
 * @param {Function} success
 * @param {Function} failure
 * @override
 * @this {pcmws.api.CustomPlacesRestService}
 *
 */
pcmws.api.CustomPlacesRestService.prototype.delete = function (input, success, failure) {
  var input1 = /** @type {pcmws.api.CustomPlacesDeleteOptions} */(input);
  var nparams = this.getParamsArray();
  var params = [];
  var headers = {
    'Content-Type' : 'application/json'
  };
  /** @type {string|null} */
  var setId = nparams.reduce(function (a, v) {
      if (v.name === 'setId') {
        return v.getCheckedValue();
      } else if (v.name === "authToken") {
        headers['Authorization'] = v.getCheckedValue();
      } else {
        params.push(v);
        return a;
      }
    }, null) || '' + (input1.setId || '');

  /** @type {string!} */
  var placeId = '' + (input1.placeId || '');
  var path = this.getServiceURL().path.replace('{setId}', setId);
  var ieMajorVersion = this.getIEMajorVersion();
  var method;
  if (0 < ieMajorVersion && ieMajorVersion < 10) {
    path = path.replace('{XDR}', 'XDR/') + '/delete/' + placeId;
    method = 'POST';
  } else {
    path = path.replace('{XDR}','') + '/' + placeId;
    method = 'DELETE';
  }
  var url = this.constructURL(path, params);
  function pass(resp) {if (typeof success === 'function') success(resp);}
  function fail(resp) {if (typeof failure === 'function') failure(resp);}
  this.xhrInvoke(url, method, 'json', headers, null, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'number') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
goog.provide('alk.service.CustomPlacesService');

goog.require('alk.service.RestService');
goog.require('pcmws.api.CustomPlacesRestService');

goog.require('alkx.CustomPlacesServiceOptions');
goog.require('alkx.CustomPlacesServiceAddOptions');
goog.require('alkx.CustomPlacesServiceAddResponse');
goog.require('alkx.CustomPlacesServiceUpdateOptions');
goog.require('alkx.CustomPlacesServiceUpdateResponse');
goog.require('alkx.CustomPlacesServiceDeleteOptions');
goog.require('alkx.CustomPlacesServiceDeleteResponse');

/**
 * @classdesc
 * An instance of this class forms access to the ALK Custom Places Service.
 * @description
 * This constructor creates a Service object that accesses the ALK Custom Places Service.
 *
 * @param {alkx.CustomPlacesServiceOptions=} opt_options
 * @constructor
 * @extends {alk.service.RestService}
 * @api
 */
alk.service.CustomPlacesService = function (opt_options) {
  alk.service.CustomPlacesService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.customPlacesService = this.pcmws = new pcmws.api.CustomPlacesRestService(this.pcmServiceOptions);
};
goog.inherits(alk.service.CustomPlacesService, alk.service.RestService);

/**
 * This method retrieves Custom Places.
 * @param {alkx.CustomPlacesServiceAddOptions?} input
 * @param {function(alkx.CustomPlacesServiceAddResponse)=} success
 * @param {function(alkx.CustomPlacesServiceAddResponse)=} failure
 * @this {alk.service.CustomPlacesService}
 * @api
 */
alk.service.CustomPlacesService.prototype.add = function (input, success, failure) {
  this.customPlacesService.add(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 * This method updates existing Custom Places.
 * @param {alkx.CustomPlacesServiceUpdateOptions} input
 * @param {function(alkx.CustomPlacesServiceUpdateResponse=)=} success
 * @param {function(alkx.CustomPlacesServiceUpdateResponse=)=} failure
 * @this {alk.service.CustomPlacesService}
 * @api
 */
alk.service.CustomPlacesService.prototype.update = function (input, success, failure) {
  this.customPlacesService.update(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};

/**
 * This method deletes existing Places.
 * @param {alkx.CustomPlacesServiceDeleteOptions} input
 * @param {function(alkx.CustomPlacesServiceDeleteResponse=)=} success
 * @param {function(alkx.CustomPlacesServiceDeleteResponse=)=} failure
 * @this {alk.service.CustomPlacesService}
 * @api
 */
alk.service.CustomPlacesService.prototype.delete = function (input, success, failure) {
  this.customPlacesService.delete(input, function (response) {
    if (typeof success === 'function') {
      success(response);
    }
  }, function (response) {
    if (typeof failure === 'function') {
      failure(response);
    }
  });
};
goog.provide('pcmws.api.POICategoriesSingleSearchService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.POICategoriesSingleSearchServiceOptions');
goog.require('pcmws.api.POICategoriesSingleSearchURL');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.StaticService');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for the
 * Single Search POICategories service.
 * @param {pcmws.api.POICategoriesSingleSearchServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.POICategoriesSingleSearchService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region]
  ];
  pcmws.api.POICategoriesSingleSearchService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.POICategoriesSingleSearchServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.POICategoriesSingleSearchURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.POICategoriesSingleSearchService, pcmws.api.StaticService);


/**
 * @override
 * @returns {pcmws.api.POICategoriesSingleSearchService}
 * @this {pcmws.api.POICategoriesSingleSearchService}
 */
pcmws.api.POICategoriesSingleSearchService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.POICategoriesSingleSearchServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.POICategoriesSingleSearchService(opts);
};

/**
 * @inheritDoc
 * @this {pcmws.api.POICategoriesSingleSearchService}
 */
pcmws.api.POICategoriesSingleSearchService.prototype.getURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};

/**
 * @inheritDoc
 * @this {pcmws.api.POICategoriesSingleSearchService}
 */
pcmws.api.POICategoriesSingleSearchService.prototype.getAttributionURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceAttributionURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};

goog.provide('alk.service.POICategoriesSingleSearchService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.POICategoriesSingleSearchService');

goog.require('alkx.POICategoriesSingleSearchServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK POI Service.
 * @description
 * This constructor creates a Service object that accesses the ALK POI Service.
 *
 * @param {alkx.POICategoriesSingleSearchServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.POICategoriesSingleSearchService = function (opt_options) {
  alk.service.POICategoriesSingleSearchService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.pOICategoriesSingleSearchService = this.pcmws = new pcmws.api.POICategoriesSingleSearchService(this.pcmServiceOptions);
};
goog.inherits(alk.service.POICategoriesSingleSearchService, alk.service.Service);

/**
 * @description
 * The ALK POI Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.POICategoriesSingleSearchService} object.
 *
 * @type {pcmws.api.POICategoriesSingleSearchService}
 */
alk.service.POICategoriesSingleSearchService.prototype.pOICategoriesSingleSearchService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from POI Categories Single Search Service returns a JSON object
 * containing a single {@link alkx.POICategoriesSingleSearchServiceResult}.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.POICategoriesSingleSearchService}.
 * @param {Object} obj The JSON response from the {@link alk.service.POICategoriesSingleSearchService}.
 * @returns {Object} Containing the pOICategoriesSingleSearchServiceOptions and if a successful call
 *  also contains a JSON object containing the points of interest requested.
 * @override
 * @api
 */
alk.service.POICategoriesSingleSearchService.prototype.processResponse = function (options, obj) {
  return {
    pOICategoriesSingleSearchServiceOptions: options,
    result: obj
  };
};

/**
 * @description
 * This method performs a call to the POI Categories Single Search Service.
 * @param {(alkx.POICategoriesSingleSearchServiceOptions|null|function(alkx.POICategoriesSingleSearchServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.POICategoriesSingleSearchServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.POICategoriesSingleSearchService}
 * @api
 */
alk.service.POICategoriesSingleSearchService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.POICategoriesSingleSearchServiceOptions} */
  var options = {};
  /** function(alkx.POICategoriesSingleSearchServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.POICategoriesSingleSearchServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.POICategoriesSingleSearchService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('pcmws.api.RoutePathService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.RoutePathRequest');
goog.require('pcmws.api.RoutePathServiceOptions');
goog.require('pcmws.api.RouteURL');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.RoutePathServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.RoutePathService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['srs', pcmws.api.SRS],
    ['routePathRequest', pcmws.api.RoutePathRequest]
  ];
  pcmws.api.RoutePathService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.RoutePathServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.RouteURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.RoutePathService, pcmws.api.StaticService);

/**
 * This method returns a clone of this RoutePathService object.
 * @override
 * @this {pcmws.api.RoutePathService}
 * @returns {pcmws.api.RoutePathService}
 *
 */
pcmws.api.RoutePathService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.RoutePathServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.RoutePathService(opts);
};

/**
 * This method performs a get of the service.
 * @param {(Object|Function)=} opt_options See {@link pcmws.api.RoutePathServiceOptions}
 * @param {Function=} responseSuccessErrorCallback
 * @param {Function=} responseErrorCallback
 * @override
 * @this {pcmws.api.RoutePathService}
 *
 */
pcmws.api.RoutePathService.prototype.get = function (opt_options, responseSuccessErrorCallback, responseErrorCallback) {
  var self = this;
  var options = {};
  var success;
  var failure;
  if (typeof opt_options === 'function') {
    success = /** @type {Function} */(opt_options);
    failure = responseSuccessErrorCallback;
  } else {
    options = opt_options || {};
    success = responseSuccessErrorCallback;
    failure = responseErrorCallback;
  }
  if (failure === undefined) {
    failure = success;
  }
  var nparams = this.getParamsArray(options);
  var params = [];
  var headers = {
    'Content-Type' : 'application/json'
  };
  var request = {};
  nparams.forEach(function (param) {
    var pair = param.getDataPair();
      if (pair[0] === "authToken") {
        headers['Authorization'] = pair[1];
      } else switch (pair[0]) {
        case 'dataset':
        case 'srs':
          params.push(param);
          break;
        case 'routePathRequest':
          request = pair[1];
          break;
        default:
          break;
      }
    });
  /** @type {string} */
  var data = typeof request === 'object' ? JSON.stringify(request) : request;
  var serviceURL = this.getServiceURL();
  var url = this.constructURL(serviceURL.hostURL, serviceURL.path, params);
  function pass(resp) {if (typeof success === 'function') success(self.processResponse(resp));}
  function fail(resp) {if (typeof failure === 'function') failure(self.processErrorResponse(resp));}
  this.xhrInvoke(url, 'POST', 'json', headers, data, function (xhr) {
    if (xhr.response) {
      if (!xhr.status || 200 <= xhr.status && xhr.status < 300) {
        if (typeof xhr.response === 'object') {
          pass(xhr.response);
        } else {
          fail(xhr.response);
        }
      } else {
        fail(xhr.response);
      }
    } else {
      fail(xhr.response);
    }
  }, function (xhr) {
    fail(xhr.response);
  });
};
goog.provide('alk.service.RoutePathService');

goog.require('alk.service.Service');
goog.require('pcmws.api.RoutePathService');

goog.require('alkx.RoutePathServiceOptions');

/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Route Service.
 * @description
 * This constructor creates a Service object that acceses the
 * ALK Routing engine.
 *
 * @param {alkx.RoutePathServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.RoutePathService = function (opt_options) {
  alk.service.RoutePathService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.routePathService = this.pcmws = new pcmws.api.RoutePathService(this.pcmServiceOptions);
};
goog.inherits(alk.service.RoutePathService, alk.service.Service);

/**
 * @description
 * The ALK Route Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.RoutePathService} object.
 *
 * @type {pcmws.api.RoutePathService}
 */
alk.service.RoutePathService.prototype.routePathService;
goog.provide('pcmws.api.RouteReportsService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.AvoidFavors');
goog.require('pcmws.api.AvoidTolls');
goog.require('pcmws.api.Axles');
goog.require('pcmws.api.BorderWait');
goog.require('pcmws.api.BreakInterval');
goog.require('pcmws.api.BreakLength');
goog.require('pcmws.api.Certainty');
goog.require('pcmws.api.CiteInterval');
goog.require('pcmws.api.CondenseDirections');
goog.require('pcmws.api.CostGreenHouseGas');
goog.require('pcmws.api.CostMaintenanceEmpty');
goog.require('pcmws.api.CostMaintenanceLoad');
goog.require('pcmws.api.CostPerFuelUnit');
goog.require('pcmws.api.CostTimeEmpty');
goog.require('pcmws.api.CostTimeLoad');
goog.require('pcmws.api.CustomRoadSpeeds');
goog.require('pcmws.api.DistanceUnits');
goog.require('pcmws.api.ElevationLimit');
goog.require('pcmws.api.EstimatedTimeOpts');
goog.require('pcmws.api.EventNames');
goog.require('pcmws.api.ExchangeRate');
goog.require('pcmws.api.FerryDiscourage');
goog.require('pcmws.api.FuelEconomyEmpty');
goog.require('pcmws.api.FuelEconomyLoad');
goog.require('pcmws.api.GovernorSpeedLimit');
goog.require('pcmws.api.HazMat');
goog.require('pcmws.api.HighwayOnly');
goog.require('pcmws.api.HosEnabled');
goog.require('pcmws.api.HosRemCycleDutyTime');
goog.require('pcmws.api.HosRemDriveTime');
goog.require('pcmws.api.HosRemDriveTimeUntilBreak');
goog.require('pcmws.api.HosRemOnDutyTime');
goog.require('pcmws.api.HubRouting');
goog.require('pcmws.api.IncludeTollData');
goog.require('pcmws.api.Language');
goog.require('pcmws.api.LCV');
goog.require('pcmws.api.OpenBorders');
goog.require('pcmws.api.OverrideClass');
goog.require('pcmws.api.OverrideRestrict');
goog.require('pcmws.api.RemainingHoursOfService');
goog.require('pcmws.api.ReportFormat');
goog.require('pcmws.api.Reports');
goog.require('pcmws.api.RouteOptimization');
goog.require('pcmws.api.RouteReportsServiceOptions');
goog.require('pcmws.api.RouteReportsURL');
goog.require('pcmws.api.RouteType');
goog.require('pcmws.api.Severity');
goog.require('pcmws.api.SideOfStreetAdherence');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.Stops');
goog.require('pcmws.api.THoursWithSeconds');
goog.require('pcmws.api.TollCurrency');
goog.require('pcmws.api.TollPlan');
goog.require('pcmws.api.TruckConfig');
goog.require('pcmws.api.Urgency');
goog.require('pcmws.api.UseTraffic');
goog.require('pcmws.api.VehicleDimensionUnits');
goog.require('pcmws.api.VehicleHeight');
goog.require('pcmws.api.VehicleLength');
goog.require('pcmws.api.VehicleType');
goog.require('pcmws.api.VehicleWeight');
goog.require('pcmws.api.VehicleWidth');



/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for PCMiler Route service.
 * @param {pcmws.api.RouteReportsServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.RouteReportsService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['avoidFavors', pcmws.api.AvoidFavors],
    ['avoidTolls', pcmws.api.AvoidTolls],
    ['axles', pcmws.api.Axles],
    ['borderWait', pcmws.api.BorderWait],
    ['breakInterval', pcmws.api.BreakInterval],
    ['breakLength', pcmws.api.BreakLength],
    ['certainty', pcmws.api.Certainty],
    ['citeInterval', pcmws.api.CiteInterval],
    ['condenseDirections', pcmws.api.CondenseDirections],
    ['costGreenHouseGas', pcmws.api.CostGreenHouseGas],
    ['costMaintenanceEmpty', pcmws.api.CostMaintenanceEmpty],
    ['costMaintenanceLoad', pcmws.api.CostMaintenanceLoad],
    ['costPerFuelUnit', pcmws.api.CostPerFuelUnit],
    ['costTimeEmpty', pcmws.api.CostTimeEmpty],
    ['costTimeLoad', pcmws.api.CostTimeLoad],
    ['customRoadSpeeds', pcmws.api.CustomRoadSpeeds],
    ['distanceUnits', pcmws.api.DistanceUnits],
    ['elevationLimit', pcmws.api.ElevationLimit],
    ['estimatedTimeOpts', pcmws.api.EstimatedTimeOpts],
    ['eventNames', pcmws.api.EventNames],
    ['exchangeRate', pcmws.api.ExchangeRate],
    ['ferryDiscourage', pcmws.api.FerryDiscourage],
    ['fuelEconomyEmpty', pcmws.api.FuelEconomyEmpty],
    ['fuelEconomyLoad', pcmws.api.FuelEconomyLoad],
    ['governorSpeedLimit', pcmws.api.GovernorSpeedLimit],
    ['hazMat', pcmws.api.HazMat],
    ['highwayOnly', pcmws.api.HighwayOnly],
    ['hosEnabled', pcmws.api.HosEnabled],
    ['hosRemCycleDutyTime', pcmws.api.HosRemCycleDutyTime],
    ['hosRemDriveTime', pcmws.api.HosRemDriveTime],
    ['hosRemDriveTimeUntilBreak', pcmws.api.HosRemDriveTimeUntilBreak],
    ['hosRemOnDutyTime', pcmws.api.HosRemOnDutyTime],
    ['hubRouting', pcmws.api.HubRouting],
    ['includeTollData', pcmws.api.IncludeTollData],
    ['language', pcmws.api.Language],
    ['lCV', pcmws.api.LCV],
    ['openBorders', pcmws.api.OpenBorders],
    ['overrideClass', pcmws.api.OverrideClass],
    ['overrideRestrict', pcmws.api.OverrideRestrict],
    ['remainingHoursOfService', pcmws.api.RemainingHoursOfService],
    ['reportFormat', pcmws.api.ReportFormat],
    ['reports', pcmws.api.Reports],
    ['routeOptimization', pcmws.api.RouteOptimization],
    ['routeType', pcmws.api.RouteType],
    ['severity', pcmws.api.Severity],
    ['sideOfStreetAdherence', pcmws.api.SideOfStreetAdherence],
    ['stops', pcmws.api.Stops],
    ['tHoursWithSeconds', pcmws.api.THoursWithSeconds],
    ['tollCurrency', pcmws.api.TollCurrency],
    ['tollPlan', pcmws.api.TollPlan],
    ['truckConfig', pcmws.api.TruckConfig],
    ['urgency', pcmws.api.Urgency],
    ['useTraffic', pcmws.api.UseTraffic],
    ['vehicleDimensionUnits', pcmws.api.VehicleDimensionUnits],
    ['vehicleHeight', pcmws.api.VehicleHeight],
    ['vehicleLength', pcmws.api.VehicleLength],
    ['vehicleType', pcmws.api.VehicleType],
    ['vehicleWeight', pcmws.api.VehicleWeight],
    ['vehicleWidth', pcmws.api.VehicleWidth]
  ];
  pcmws.api.RouteReportsService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.RouteReportsServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.RouteReportsURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.RouteReportsService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.RouteReportsService}
 * @returns {pcmws.api.RouteReportsService}
 */
pcmws.api.RouteReportsService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.RouteReportsServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.RouteReportsService(opts);
};
goog.provide('alk.service.RouteReportsService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.RouteReportsService');

goog.require('alkx.RouteReportsServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the PCM RouteReportsService.
 * @description
 * This constructor creates a Service object to access the ALK PC Miler
 * Route Reports Service.
 * @param {alkx.RouteReportsServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.RouteReportsService = function (opt_options) {
  alk.service.RouteReportsService.base(this, 'constructor', opt_options);
  this.pcmServiceOptions = this.getPCMServiceOptions(opt_options);
  this.routeReportsService = this.pcmws = new pcmws.api.RouteReportsService(this.pcmServiceOptions);
};
goog.inherits(alk.service.RouteReportsService, alk.service.Service);

/**
 * @description
 * The ALK Route Reports Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this {@link alk.service.RouteReportsService} object.
 *
 * @type {pcmws.api.RouteReportsService}
 */
alk.service.RouteReportsService.prototype.routeReportsService;

/**
 * @description
 * This function performs a request for a {@link alkx.RouteReportsServiceResponse} from
 * the options and defaults set on this {@link alk.service.RouteReportsService} object.
 *
 * The response is handled by a asynchronous callback.
 *
 * @param {(alkx.RouteReportsServiceOptions|null|
 *     function(alkx.RouteReportsServiceResponse))=} opts_or_callback
 *     Options override, if not the callback.
 * @param {function(alkx.RouteReportsServiceResponse)=} responseCallback
 *     The callback that handles the response.
 * @override
 * @this {alk.service.RouteReportsService}
 * @api
 */
alk.service.RouteReportsService.prototype.get = function(opts_or_callback, responseCallback) {
  /** @type {alkx.RouteReportsServiceOptions} */
  var options = {};
  /** function(alkx.RouteReportsServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.RouteReportsServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.RouteReportsService.base(this, 'get', downcastOptions, downcastCallback);
};

goog.provide('pcmws.api.SearchTypesSingleSearchService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SearchTypesSingleSearchServiceOptions');
goog.require('pcmws.api.SearchTypesSingleSearchURL');
goog.require('pcmws.api.StaticService');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for the
 * Single Search SearchTypes service.
 * @param {pcmws.api.SearchTypesSingleSearchServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.SearchTypesSingleSearchService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region]
  ];
  pcmws.api.SearchTypesSingleSearchService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.SearchTypesSingleSearchServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.SearchTypesSingleSearchURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.SearchTypesSingleSearchService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.SearchTypesSingleSearchService}
 * @returns {pcmws.api.SearchTypesSingleSearchService}
 */
pcmws.api.SearchTypesSingleSearchService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.SearchTypesSingleSearchServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.SearchTypesSingleSearchService(opts);
};



/**
 * @inheritDoc
 * @this {pcmws.api.SearchTypesSingleSearchService}
 */
pcmws.api.SearchTypesSingleSearchService.prototype.getURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};

/**
 * @inheritDoc
 * @this {pcmws.api.SearchTypesSingleSearchService}
 */
pcmws.api.SearchTypesSingleSearchService.prototype.getAttributionURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceAttributionURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};
goog.provide('alk.service.SearchTypesSingleSearchService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.SearchTypesSingleSearchService');

goog.require('alkx.SearchTypesSingleSearchServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK Types Single Search  Service.
 * @param {alkx.SearchTypesSingleSearchServiceOptions=} opt_options If defined, these options are used to make
 *        the base POI Service object. Calls to {@link alk.service.SearchTypesSingleSearchService#get} and
 *        {@link alk.service.SearchTypesSingleSearchService#getServiceOptions} on this object will take options
 *        and override and extend what is set here.
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.SearchTypesSingleSearchService = function (opt_options) {
  alk.service.SearchTypesSingleSearchService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.searchTypesSingleSearchService = this.pcmws = new pcmws.api.SearchTypesSingleSearchService(this.pcmServiceOptions);
};
goog.inherits(alk.service.SearchTypesSingleSearchService, alk.service.Service);

/**
 * @description
 * The ALK Search Types Single Search Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.SearchTypesSingleSearchService} object.
 *
 * @type {pcmws.api.SearchTypesSingleSearchService}
 */
alk.service.SearchTypesSingleSearchService.prototype.searchTypesSingleSearchService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from Search Types Single Search Service returns a JSON object
 * containing a single {@link alkx.SearchTypesSingleSearchServiceResult}.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.SearchTypesSingleSearchService}.
 * @param {Object} obj The JSON response from the {@link alk.service.SearchTypesSingleSearchService}.
 * @returns {Object} Containing the searchTypesSingleSearchServiceOptions and if a successful call
 *  also contains a JSON object containing the points of interest requested.
 * @override
 * @api
 */
alk.service.SearchTypesSingleSearchService.prototype.processResponse = function (options, obj) {
  return {
    searchTypesSingleSearchServiceOptions: options,
    result: obj
  };
};

/**
 * @description
 * This method performs a call to the Search Types Single Search Service.
 * @param {(alkx.SearchTypesSingleSearchServiceOptions|null|function(alkx.SearchTypesSingleSearchServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.SearchTypesSingleSearchServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.SearchTypesSingleSearchService}
 * @api
 */
alk.service.SearchTypesSingleSearchService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.SearchTypesSingleSearchServiceOptions} */
  var options = {};
  /** function(alkx.SearchTypesSingleSearchServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.SearchTypesSingleSearchServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.SearchTypesSingleSearchService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('pcmws.api.StatesSingleSearchService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.StatesSingleSearchServiceOptions');
goog.require('pcmws.api.StatesSingleSearchURL');
goog.require('pcmws.api.StaticService');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for the
 * Single Search States service.
 * @param {pcmws.api.StatesSingleSearchServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.StatesSingleSearchService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['region', pcmws.api.Region]
  ];
  pcmws.api.StatesSingleSearchService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.StatesSingleSearchServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.StatesSingleSearchURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.StatesSingleSearchService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.StatesSingleSearchService}
 * @returns {pcmws.api.StatesSingleSearchService}
 */
pcmws.api.StatesSingleSearchService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.StatesSingleSearchServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.StatesSingleSearchService(opts);
};



/**
 * @inheritDoc
 * @this {pcmws.api.StatesSingleSearchService}
 */
pcmws.api.StatesSingleSearchService.prototype.getURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};

/**
 * @inheritDoc
 * @this {pcmws.api.StatesSingleSearchService}
 */
pcmws.api.StatesSingleSearchService.prototype.getAttributionURL = function (opt_options) {
  var paramsA = this.getParamsArray(opt_options);
  var url = this.getServiceAttributionURL().toString();
  var region = 'ww';
  paramsA.forEach(function (param) {
    if (param.name === 'region') {
      region = param.getCheckedValue();
    }
  });
  url = url.replace('{region}', region);
  var params = paramsA.filter(wanted).map(function (param) {return param.getURLParam();});

  return url + '?' + params.filter(not_null).join('&');

  function not_null(v) {
    return v;
  }

  function wanted(v) {
    return v && v.name !== 'region';
  }
};
goog.provide('alk.service.StatesSingleSearchService');

goog.require('alk.service');
goog.require('alk.service.Service');
goog.require('pcmws.api.StatesSingleSearchService');

goog.require('alkx.StatesSingleSearchServiceOptions');
/**
 * @classdesc
 * An instance of this class, given the parameters and defaults,
 * is used to make requests to the ALK States Single Search Service.
 * @description
 * This constructor creates a Service object to access the ALK States Single Search Service.
 * @param {alkx.StatesSingleSearchServiceOptions=} opt_options
 * @extends {alk.service.Service}
 * @constructor
 * @api
 */
alk.service.StatesSingleSearchService = function (opt_options) {
  alk.service.StatesSingleSearchService.base(this, 'constructor', opt_options);
  var options = this.getServiceOptions({});
  this.pcmServiceOptions = this.getPCMServiceOptions(options);
  this.statesSingleSearchService = this.pcmws = new pcmws.api.StatesSingleSearchService(this.pcmServiceOptions);
};
goog.inherits(alk.service.StatesSingleSearchService, alk.service.Service);

/**
 * @description
 * The ALK States Single Search Web Service URL generator.
 *
 * This property is created by the constructor. It should not be overwritten as
 * it could lead to inconsistencies with the options that were used to create
 * this this {@link alk.service.StatesSingleSearchService} object.
 *
 * @type {pcmws.api.StatesSingleSearchService}
 */
alk.service.StatesSingleSearchService.prototype.statesSingleSearchService;

/**
 * @description
 * This call processes the response before it is given to the callback.
 *
 * This particular method enhances the response from the ALK/PCM service and modifies
 * it accordingly.
 *
 * The response returned from States Single Search Service returns a JSON object
 * containing a single {@link alkx.StatesSingleSearchServiceResult}.
 *
 * @param {Object} options The options that were given with the call combined with the base options
 *                         used for the {@link alk.service.StatesSingleSearchService}.
 * @param {Object=} obj The JSON response from the {@link alk.service.StatesSingleSearchService}.
 * @returns {Object} Containing the statesSingleSearchServiceOptions and if a successful call
 *  also contains a JSON object containing the points of interest requested.
 * @override
 * @api
 */
alk.service.StatesSingleSearchService.prototype.processResponse = function (options, obj) {
  return {
    statesSingleSearchServiceOptions: options,
    result: obj
  };
};

/**
 * @description
 * This method performs a call to the States Single Search Service.
 * @param {(alkx.StatesSingleSearchServiceOptions|null|function(alkx.StatesSingleSearchServiceResponse))=} opts_or_callback This parameter contains any options to override or
 *                         extend the options set in the construction of this object
 *                         for the call.
 * @param {function(alkx.StatesSingleSearchServiceResponse)=} responseCallback The response handler.
 * @override
 * @this {alk.service.StatesSingleSearchService}
 * @api
 */
alk.service.StatesSingleSearchService.prototype.get = function (opts_or_callback, responseCallback) {
  /** @type {alkx.StatesSingleSearchServiceOptions} */
  var options = {};
  /** function(alkx.StatesSingleSearchServiceResponse} */
  var callback;
  if (typeof opts_or_callback === 'function') {
    callback = opts_or_callback;
  } else {
    if (opts_or_callback !== undefined) {
      options = /** @type {alkx.StatesSingleSearchServiceOptions} */(opts_or_callback);
    }
    callback = responseCallback;
  }
  var downcastOptions = /** @type {Object} */ (options);
  var downcastCallback= /** @type {function(Object)} */ (callback);
  alk.service.StatesSingleSearchService.base(this, 'get', downcastOptions, downcastCallback);
};
goog.provide('alk.Stop');

goog.require('alk');

/**
 *
 * @param {Array.<number>|alkx.StopOptions} options
 * @constructor
 */
alk.Stop = function(options) {
  if (options instanceof 'Array') {
    options = {
      coords: /** Array.<number> */ (options)
    }
  }
  alk.Stop.base(this, 'constructor');
  this.set('coords', this.coords = options.coords, true);
  this.set('stopType', this.stopType = options.stopType, true);
  this.set('label', this.label = options.label, true);
};
goog.inherits(alk.Stop, ol.Object);

/**
 * @type {alk.val.StopType}
 */
alk.Stop.prototype.stopType;
goog.provide('alk.style.Arrow');

goog.require('alk.style');

goog.require('alkx.style.ArrowOptions');

/**
 * @classdesc
 * An instance of this class represents an OpenLayers style that
 * forms an arrow.
 *
 * @description
 * This constructor creates a Regular Shape Style object that represents
 * an arrow.
 *
 * @param {alkx.style.ArrowOptions} options
 * @constructor
 * @extends {ol.style.RegularShape}
 * @api
 */
alk.style.Arrow = function(options) {
  var opts = {
    angle: options.angle || Math.PI * 45.0/180.0,
    atlasManager: options.atlasManager,
    points: 3,
    radius: options.radius || 20,
    rotateWithView: options.rotateWithView,
    rotation: options.rotation,
    snapToPixel: options.snapToPixel,
    fill: options.fill,
    stroke: options.stroke,
    scale: options.scale
  };
  alk.style.Arrow.base(this, 'constructor', opts);
  if (options.scale) {
    this.setScale(options.scale);
  }
};
goog.inherits(alk.style.Arrow, ol.style.RegularShape);

/**
 * @override
 * @param {ol.style.AtlasManager|undefined} atlasManager
 * @protected
 * @this {alk.style.Arrow}
 */
alk.style.Arrow.prototype.render_ = function (atlasManager) {
  alk.style.Arrow.base(this, 'render_', atlasManager);
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 * @this {alk.style.Arrow}
 */
alk.style.Arrow.prototype.draw_ = function(renderOptions, context, x, y) {
  var angle0, radiusC;
  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0);

  // then move to (x, y)
  context.translate(x, y);
  context.beginPath();

  angle0 = this.getAngle();
  radiusC = this.getRadius();
  var offset = renderOptions.size / 2;
  var x1,y1;
  x1 = offset - radiusC * Math.cos(angle0) - x;
  y1 = offset + radiusC * Math.sin(angle0) - y;
  var x2,y2;
  x2 = offset + radiusC * Math.cos(angle0) - x;
  y2 = y1;
  context.moveTo(x1 , y1);
  context.lineTo(offset,offset);
  context.lineTo(x2, y2);
  if (this.getFill()) {
    context.lineTo(y1,y2);
    context.fillStyle = ol.colorlike.asColorLike(this.getFill().getColor());
    context.fill();
  }
  if (this.getStroke()) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
    }
    context.lineCap = renderOptions.lineCap;
    context.lineJoin = renderOptions.lineJoin;
    context.miterLimit = renderOptions.miterLimit;
    context.stroke();
  }
  context.closePath();
};
goog.provide('alk.val.ArrowsType');

/**
 * @enum {string}
 * @api
 */
alk.val.ArrowsType = {
  /** @api */
  None: 'None',
  /** @api */
  Line: 'Line',
  /** @api */
  End: 'End'
};
goog.provide('alk.style.ArrowsRouteStyle');

goog.require('alk.style');
goog.require('alk.style.StopsRouteStyle');
goog.require('alk.style.Arrow');
goog.require('alk.val.ArrowsType');

/**
 * @classdesc
 * An instance of this class provides a {@link ol.style.StyleFunction} for
 * a particular routeId. This class works in conjunction with the RoutingLayer
 * in that features will have set properties of 'routeId' on them.
 *
 * @description
 * This constructor creates a Style object that styles any route features
 * having a geometry of {ol.geom.Point} such that they will be tagged
 * with 'stop' and 'stopIndex' if they are stops. The 'stop' property will
 * have the original coordinates, and the 'stopIndex' property will have
 * the index in the stop list given to the RoutingLayer#addRoute function.
 * Features tagged with 'stop' may also be tagged with 'stopType' of {@link ol.val.StopType}
 * according to the policy set forth in the RoutingLayer. For instance, a Route with 'hubRouting'
 * set will not have a 'stop' feature with a 'stopType' of 'Destination'.
 *
 * This particular ArrowsRouteStyle assigns styles for a particular 'routeId from a set of rotating strokes
 * from a {@link alk.style.StrokeQueue}.
 * If the arrows option is set to Line, arrows are drawn along the route at regular
 * intervals. If the arrows option is set to End, a single arrow is drawn at the end.
 * @param {{
 *  arrows: (alk.val.ArrowsType|undefined),
 *  originStyle: (ol.style.Image|undefined),
 *  destinationStyle: (ol.style.Image|undefined),
 *  strokeQueue: (alk.style.StrokeQueue|undefined)
 *  }=} opt_options
 * @constructor
 * @extends {alk.style.StopsRouteStyle}
 * @api
 */
alk.style.ArrowsRouteStyle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  if (options.arrows) {
    this.arrowsType_ = options.arrows;
  }
  var opts = {
    originStyle: options.originStyle,
    destinationStyle: options.destinationStyle,
    strokeQueue: options.strokeQueue
  };
  alk.style.ArrowsRouteStyle.base(this, 'constructor', opts);
};
goog.inherits(alk.style.ArrowsRouteStyle, alk.style.StopsRouteStyle);

/**
 * @type {alk.val.ArrowsType}
 * @private
 */
alk.style.ArrowsRouteStyle.prototype.arrowsType_;

/**
 * This function returns an {@link ol.style.Image} to use as an arrow.
 * It is only called once per feature. The feature will be a MultiLineString or
 * LineString geometry and will have its 'routeId' property set. However, the
 * strokeStyle is associated with the 'routeId'.
 * @param {ol.Feature} feature The feature we are drawing arrows on.
 * @param {number} resolution The resolution
 * @param {ol.style.Stroke} strokeStyle The selected stroke style for the route.
 * @param {number} bearing The bearing to which the arrow should point. Usually used
 *                         in the 'rotation' property.
 * @returns {ol.style.Image|null} If this returns null, no arrows will be drawn.
 * @api
 */
alk.style.ArrowsRouteStyle.prototype.getArrow = function(feature, resolution, strokeStyle, bearing) {
  return new alk.style.Arrow({
    scale: 3.0/resolution,
    rotation: bearing,
    stroke: strokeStyle
  });
};

/**
 * @param {ol.Feature} feature
 * @param {number} resolution
 * @returns {Array.<ol.style.Style>}
 * @override
 * @this {alk.style.ArrowsRouteStyle}
 * @api
 */
alk.style.ArrowsRouteStyle.prototype.styleFunction = function(feature, resolution) {
  var self = this;
  var styles = alk.style.ArrowsRouteStyle.base(this, 'styleFunction', feature, resolution);

  function getBearing(p1, p2) {
    var ax = p2[0] - p1[0];
    var ay = p2[1] - p1[1];
    var angle = Math.atan2(ax, ay);
    return angle;
  }

  var strokeStyle = this.getStrokeStyle(feature, resolution);

  if (feature.getGeometry().getType() === 'LineString') {
    var arrow = this.getArrow(feature, resolution, strokeStyle, 0.0);
    if (arrow) {
      feature.getGeometry().forEachSegment(function(pt1, pt2) {
        var bearing = getBearing(pt1, pt2);
        styles.push(
          new ol.style.Style({
            geometry:  new ol.geom.Point(pt2),
            image: self.getArrow(feature, resolution, strokeStyle, bearing)
          })
        );
      });
    }
  } else if (feature.getGeometry().getType() === 'MultiLineString') {
    var arrow = this.getArrow(feature, resolution, strokeStyle, 0.0);
    if (arrow) {
      feature.getGeometry().getLineStrings().forEach(function (lineString) {
        lineString.forEachSegment(function (pt1, pt2) {
          var bearing = getBearing(pt1, pt2);
          styles.push(
            new ol.style.Style({
              geometry: new ol.geom.Point(pt2),
              image: self.getArrow(feature, resolution, strokeStyle, bearing)
            })
          );
        });
      });
    }
  } else {
    console.warn("ArrowsRouteStyle: Unsupported Style " + feature.getGeometry().getType());
  }
  return styles;
};
goog.provide('alk.style.ShadowedCircle');

goog.require('alk.style');

// TODO: alk.style.ShadowedCircle Doesn't work.
/**
 * @classdesc
 * An instance of this class is a style that provides for a shadow of a circle.
 * @description
 * This constructor creates a Style that represents a shadowed circle.
 *
 * @param {olx.style.CircleOptions=} opt_options
 * @extends {ol.style.Circle}
 * @constructor
 * @api
 */
alk.style.ShadowedCircle = function (opt_options) {
  var options = opt_options !== undefined ? opt_options : {};
  var opts = {
    fill: options.fill,
    stroke: options.stroke,
    radius: options.radius
  };
  this.offsetX = options.offset ? (options.offset[0] || 3) : 3;
  this.offsetY = options.offset ? (options.offset[1] || 1) : 1;
  alk.style.ShadowedCircle.base(this, 'constructor', opts);
};
goog.inherits(alk.style.ShadowedCircle, ol.style.Circle);
/**
 *
 * @param {Object} renderOptions
 * @param {Object} context
 * @param {number} x
 * @param {number} y
 * @this {alk.style.ShadowedCircle}
 * @private
 */
alk.style.ShadowedCircle.prototype.draw_ = function (renderOptions, context, x, y) {
  context.shadowOffsetY = this.offsetX;
  context.shadowOffsetX = this.offsetY;
  context.shadowColor = 'rgba(10,10,10,0.25)';
  alk.style.ShadowedCircle.base(this, 'draw_', renderOptions, context, x, y);
};
goog.provide('alk.val.Certainty');

goog.require('alk.val');
/**
 * @description
 * This object contains the definitive values for the Certainty parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.Certainty = {
  /** @api */
 All: 'All',
  /** @api */
 Observed: 'Observed',
  /** @api */
 Likely: 'Likely',
  /** @api */
 Possible: 'Possible',
  /** @api */
 Unlikely: 'Unlikely',
  /** @api */
 Unknown: 'Unknown'
};
goog.provide('alk.val.Dataset');

goog.require('alk.val');
goog.require('pcmws.val.Dataset');

/**
 * @description
 * This enum holds the valid values for the Dataset parameter.
 * @enum {string}
 * @api
 *
 * */
alk.val.Dataset = {
  /** @api */
  Current: pcmws.val.Dataset.Current,
  /** @api */
  PCM_EU: pcmws.val.Dataset.PCM_EU,
  /** @api */
  PCM_OC: pcmws.val.Dataset.PCM_OC,
  /** @api */
  PCM_SA: pcmws.val.Dataset.PCM_SA,
  /** @api */
  PCM_GT: pcmws.val.Dataset.PCM_GT,
  /** @api */
  PCM_AF: pcmws.val.Dataset.PCM_AF,
  /** @api */
  PCM_AS: pcmws.val.Dataset.PCM_AS,
  /** @api */
  PCM_ME: pcmws.val.Dataset.PCM_ME,
  /** @api */
  PCM_SE: pcmws.val.Dataset.PCM_SE,
  /** @api */
  PCM_NA: pcmws.val.Dataset.PCM_NA
};

goog.provide('alk.val.DrawerGroup');

goog.require('alk.val');
goog.require('pcmws.val.DrawerGroup');

/**
 * @description
 * This object provides the definitive values for the DrawerGroup parameter.
 *
 * @enum {string}
 * @api
 */
alk.val.DrawerGroup = {
  /** @api */
  Cities: pcmws.val.DrawerGroup.Cities,
  /** @api */
  Labels: pcmws.val.DrawerGroup.Labels,
  /** @api */
  Roads: pcmws.val.DrawerGroup.Roads,
  /** @api */
  Commercial: pcmws.val.DrawerGroup.Commercial,
  /** @api */
  Borders: pcmws.val.DrawerGroup.Borders,
  /** @api */
  Areas: pcmws.val.DrawerGroup.Areas
};

goog.provide('alk.val.Format');

goog.require('alk.val');
goog.require('pcmws.val.Format');

/**
 * @description
 * This object contains the definitive values for the Format parameter.
 *
 * @enum {string}
 * @api
 */
alk.val.Format = {
  /** @api */
  ImagePNG: pcmws.val.Format.ImagePNG
};
goog.provide('alk.val.FuelUnits');

goog.require('alk.val');

/**
 * @enum {string}
 * @api
 */
alk.val.FuelUnits = {
  /** @api */
  Gallons: "Gallons",
  /** @api */
  Liters: "Liters"
};
goog.provide('alk.val.HazMat');

goog.require('alk.val');
goog.require('pcmws.val.HazMat');

/**
 * @description
 * This object contains the definitive values for the HazMat parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.HazMat = {
  /** @api */
  None: pcmws.val.HazMat.None,
  /** @api */
  General: pcmws.val.HazMat.General,
  /** @api */
  Caustic: pcmws.val.HazMat.Caustic,
  /** @api */
  Explosives: pcmws.val.HazMat.Explosives,
  /** @api */
  Flammable: pcmws.val.HazMat.Flammable,
  /** @api */
  Inhalants: pcmws.val.HazMat.Inhalants,
  /** @api */
  Radioactive: pcmws.val.HazMat.Radioactive
};
goog.provide('alk.val.HistDay');

goog.require('alk.val');
goog.require('pcmws.val.HistDay');
/**
 * @description
 * This object contains the definitive HistDay parameters.
 *
 * @enum {string}
 * @api
 */
alk.val.HistDay = {
  /** @api */
  Monday: pcmws.val.HistDay.Monday,
  /** @api */
  Tuesday: pcmws.val.HistDay.Tuesday,
  /** @api */
  Wednesday: pcmws.val.HistDay.Wednesday,
  /** @api */
  Thursday: pcmws.val.HistDay.Thursday,
  /** @api */
  Friday: pcmws.val.HistDay.Friday,
  /** @api */
  Saturday: pcmws.val.HistDay.Saturday,
  /** @api */
  Sunday: pcmws.val.HistDay.Sunday
};
goog.provide('pcmws.val.HosRuleType');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the HosRuleType parameter.
 *
 * @enum {string}
 * 
 */
pcmws.val.HosRuleType = {
  /**  */
  USFed607LH: 'USFed607LH',
  /**  */
  USFed708LH: 'USFed708LH'
};
goog.provide('alk.val.HosRuleType');

goog.require('alk.val');
goog.require('pcmws.val.HosRuleType');

/**
 * @description
 * This object contains the definitive values for the HosRuleType parameter.
 *
 * @enum {string}
 * @api
 */
alk.val.HosRuleType = {
  /** @api */
  USFed607LH: pcmws.val.HosRuleType.USFed607LH,
  /** @api */
  USFed708LH: pcmws.val.HosRuleType.USFed708LH
};
goog.provide('alk.val.ImgOption');

goog.require('alk.val');
goog.require('pcmws.val.ImgOption');

/**
 * @enum {string}
 * @api
 */
alk.val.ImgOption = {
  /** @api */
  Background: pcmws.val.ImgOption.Background,
  /** @api */
  Foreground: pcmws.val.ImgOption.Foreground,
  /** @api */
  Both: pcmws.val.ImgOption.Both
};

goog.provide('alk.val.ImgSrc');

goog.require('alk.val');
goog.require('pcmws.val.ImgSrc');

/**
 * @description
 * This object contains the definitive values for the ImgSrc parameter.
 *
 * @enum {string}
 * @api
 */
alk.val.ImgSrc = {
  /** @api */
  Default: pcmws.val.ImgSrc.Default,
  /** @api */
  ALKCurated: pcmws.val.ImgSrc.ALKCurated,
  /** @api */
  Sat1: pcmws.val.ImgSrc.Sat1,
  /** @api */
  Sat2: pcmws.val.ImgSrc.Sat2,
  /** @api */
  Sat3: pcmws.val.ImgSrc.Sat3,
  /** @api */
  Sat4: pcmws.val.ImgSrc.Sat4,
  /** @api */
  Sat5: pcmws.val.ImgSrc.Sat5,
  /** @api */
  Sat6: pcmws.val.ImgSrc.Sat6
};
goog.provide('alk.val.Language');

goog.require('alk.val');

/**
 * @enum {string}
 * @api
 */
alk.val.Language = {
  /** @api */
  ENUS: 'ENUS',
  /** @api */
  ENGB: 'ENGB',
  /** @api */
  DE: 'DE',
  /** @api */
  FR: 'FR',
  /** @api */
  ES: 'ES',
  /** @api */
  IT: 'IT'
};
goog.provide('alk.val.OverrideClass');

goog.require('alk.val');
goog.require('pcmws.val.OverrideClass');

/**
 * @description
 * This object contains the definitive values for the OverrideClass parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.OverrideClass = {
  /** @api */
  NationalNetwork: pcmws.val.OverrideClass.NationalNetwork,
  /** @api */
  FiftyThreeFoot: pcmws.val.OverrideClass.FiftyThreeFoot
};
goog.provide('alk.val.POICategory');

goog.require('alk.val');
goog.require('pcmws.val.POICategory');

/**
 * @description
 * This object provides the definitive values for the POICategory parameter.
 *
 * @enum {string}
 * @api
 */
alk.val.POICategory = {
  /** @api */
  All: pcmws.val.POICategory.All,
  /** @api */
  City: pcmws.val.POICategory.City,
  /** @api */
  Zip: pcmws.val.POICategory.Zip,
  /** @api */
  Place: pcmws.val.POICategory.Place,
  /** @api */
  Airport: pcmws.val.POICategory.Airport,
  /** @api */
  Automotive: pcmws.val.POICategory.Automotive,
  /** @api */
  WeighStation: pcmws.val.POICategory.WeighStation,
  /** @api */
  Dining: pcmws.val.POICategory.Dining,
  /** @api */
  Education: pcmws.val.POICategory.Education,
  /** @api */
  Emergency: pcmws.val.POICategory.Emergency,
  /** @api */
  Government: pcmws.val.POICategory.Government,
  /** @api */
  Gas: pcmws.val.POICategory.Gas,
  /** @api */
  Lodging: pcmws.val.POICategory.Lodging,
  /** @api */
  Parks: pcmws.val.POICategory.Parks,
  /** @api */
  Retail: pcmws.val.POICategory.Retail,
  /** @api */
  SportsRec: pcmws.val.POICategory.SportsRec,
  /** @api */
  Travel: pcmws.val.POICategory.Travel,
  /** @api */
  TruckServices: pcmws.val.POICategory.TruckServices,
  /** @api */
  Attractions: pcmws.val.POICategory.Attractions
};

goog.provide('alk.val.Region');

goog.require('alk.val');
goog.require('pcmws.val.Region');
/**
 * @description
 * This object contains the definitive Region parameters.
 *
 * @enum {string}
 * @api
 */
alk.val.Region = {
  /** @api */
  NA: pcmws.val.Region.NA,
  /** @api */
  EU: pcmws.val.Region.EU,
  /** @api */
  OC: pcmws.val.Region.OC,
  /** @api */
  SA: pcmws.val.Region.SA,
  /** @api */
  AF: pcmws.val.Region.AF,
  /** @api */
  AS: pcmws.val.Region.AS,
  /** @api */
  ME: pcmws.val.Region.ME
};
goog.provide('alk.val.ReportFormat');

goog.require('alk.val');

/**
 * @enum {string}
 * @api
 */
alk.val.ReportFormat = {
  /** @api */
  JSON: "JSON"
};
goog.provide('alk.val.Report');

goog.require('alk.val');
/**
 * @enum {string}
 * @api
 */
alk.val.Report = {
  /** @api */
  CalcMiles: "CalcMiles",
  /** @api */
  Mileage: "Mileage",
  /** @api */
  Directions: "Directions",
  /** @api */
  State: "State",
  /** @api */
  Detail: "Detail",
  /** @api */
  Road: "Road",
  /** @api */
  GeoTunnel: "GeoTunnel"
};
goog.provide('alk.val.RouteOptimization');

goog.require('alk.val');
goog.require('pcmws.val.RouteOptimization');
/**
 * @description
 * This object contains the definitive values for the RouteOptimization parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.RouteOptimization = {
  /** @api */
  None: pcmws.val.RouteOptimization.None,
  /** @api */
  ThruAll: pcmws.val.RouteOptimization.ThruAll,
  /** @api */
  DestinationFixed: pcmws.val.RouteOptimization.DestinationFixed
};
goog.provide('alk.val.RouteType');

goog.require('alk.val');
goog.require('pcmws.val.RouteType');
/**
 * @description
 * This object contains the definitive values for the RouteType parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.RouteType = {
  /** @api */
  Practical: pcmws.val.RouteType.Practical,
  /** @api */
  Shortest: pcmws.val.RouteType.Shortest
};
goog.provide('alk.val.Severity');

goog.require('alk.val');
/**
 * @description
 * This object contains the definitive values for the Severity parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.Severity = {
  /** @api */
 All: 'All',
  /** @api */
 Extreme: 'Extreme',
  /** @api */
 Severe: 'Severe',
  /** @api */
 Moderate: 'Moderate',
  /** @api */
 Minor: 'Minor',
  /** @api */
 Unknown: 'Unknown'
};
goog.provide('alk.val.Style');

goog.require('alk.val');
goog.require('pcmws.val.Style');
/**
 * @description
 * This object contains the definitive values for the Style parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.Style = {
  /** @api */
  Transportation: pcmws.val.Style.Transportation,
  /** @api */
  DataDark: pcmws.val.Style.DataDark,
  /** @api */
  DataLight: pcmws.val.Style.DataLight,
  /** @api */
  Basic: pcmws.val.Style.Basic,
  /** @api */
  Default: pcmws.val.Style.Transportation,
  /** @api */
  Classic: pcmws.val.Style.Transportation,
  /** @api */
  Monochrome: pcmws.val.Style.DataLight,
  /** @api */
  RoadAtlas: pcmws.val.Style.Transportation,
  /** @api */
  Night: pcmws.val.Style.DataDark,
  /** @api */
  Satellite: pcmws.val.Style.Satellite,
  /** @api */
  Lightness: pcmws.val.Style.DataLight,
  /** @api */
  Smooth: pcmws.val.Style.DataLight,
  /** @api */
  Terrain: pcmws.val.Style.Terrain,
  /** @api */
  Modern: pcmws.val.Style.DataDark
};
goog.provide('alk.val.TollCurrency');

goog.require('alk.val');

/**
 * @enum {string}
 * @api
 */
alk.val.TollCurrency = {
  /** @api */
  US: "US",
  /** @api */
  CDN: "CDN"
};
goog.provide('alk.val.TollPlan');

goog.require('alk.val');

/**
 * @enum {string}
 * @api
 */
alk.val.TollPlan = {
  /** @api */
  All: "All",
  /** @api */
  C407ETRTransponder: "407ETR Transponder",
  /** @api */
  A25Transponder: "A25 Transponder",
  /** @api */
  BreezeBy: "BreezeBy",
  /** @api */
  CPass: "C-Pass",
  /** @api */
  CruiseCard: "Cruise Card",
  /** @api */
  EPass: "E-Pass",
  /** @api */
  EPassCanada: "E-Pass Canada",
  /** @api */
  EXpressToll: "EXpress Toll",
  /** @api */
  EZTag: "EZ Tag",
  /** @api */
  EZPass: "EZPass",
  /** @api */
  EZPassNJ: "EZPass-NJ",
  /** @api */
  EZPassWV: "EZPassWV",
  /** @api */
  FastLane: "FAST LANE",
  /** @api */
  FasTrak: "FasTrak",
  /** @api */
  GeauxPass: "GeauxPass",
  /** @api */
  GoodToGo: "Good To Go",
  /** @api */
  GOPass: "GO-PASS",
  /** @api */
  IPass: "I-Pass",
  /** @api */
  IZoom: "I-Zoom",
  /** @api */
  KTag: "K-TAG",
  /** @api */
  LaredoTradeTag: "Laredo Trade Tag",
  /** @api */
  LeeWay : "LeeWay",
  /** @api */
  MacPass: "MACPASS",
  /** @api */
  NCQuickPass: "NC Quick Pass",
  /** @api */
  NEXPress: "NEXPress",
  /** @api */
  PalmettoPass: "Palmetto Pass",
  /** @api */
  PeachPass: "Peach Pass",
  /** @api */
  PikePass: "PikePass",
  /** @api */
  QuickPass: "QuickPass",
  /** @api */
  SmartTag: "SmartTag",
  /** @api */
  StraitPass: "StraitPASS",
  /** @api */
  SunPass: "SunPass",
  /** @api */
  TollTag: "TollTag",
  /** @api */
  TxTag: "TxTag",
  /** @api */
  WalbashPass: "Walbash Pass"
};
goog.provide('alk.val.TruckConfig');

goog.require('alk.val');
goog.require('pcmws.val.TruckConfig');
/**
 * @description
 * This object contains the definitive values for the TruckConfig parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.TruckConfig = {
  /** @api */
  TwentyEightDoubleTrailer: pcmws.val.TruckConfig.TwentyEightDoubleTrailer,
  /** @api */
  FortyStraightTruck: pcmws.val.TruckConfig.FortyStraightTruck,
  /** @api */
  FortyEightSemiTrailer: pcmws.val.TruckConfig.FortyEightSemiTrailer,
  /** @api */
  FiftyThreeSemiTrailer: pcmws.val.TruckConfig.FiftyThreeSemiTrailer,
  /** @api */
  FullSizeVan: pcmws.val.TruckConfig.FullSizeVan,
  /** @api */
  TwentySixStraightTruck: pcmws.val.TruckConfig.TwentySixStraightTruck
};
goog.provide('alk.val.Urgency');

goog.require('alk.val');
/**
 * @description
 * This object contains the definitive values for the Urgency parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.Urgency = {
  /** @api */
 All: 'All',
  /** @api */
 Immediate: 'Immediate',
  /** @api */
 Expected: 'Expected',
  /** @api */
 Future: 'Future',
  /** @api */
 Past: 'Past',
  /** @api */
 Unknown: 'Unknown'
};
goog.provide('alk.val.VehicleDimensionUnits');

goog.require('alk.val');
goog.require('pcmws.val.VehicleDimensionUnits');
/**
 * @description
 * This object contains the definitive values for the VehicleDimensionUnits parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.VehicleDimensionUnits = {
  /** @api */
  English: pcmws.val.VehicleDimensionUnits.English,
  /** @api */
  Metric: pcmws.val.VehicleDimensionUnits.Metric
};
goog.provide('alk.val.VehicleType');

goog.require('alk.val');
goog.require('pcmws.val.VehicleType');
/**
 * @description
 * This object contains the definitive values for the VehicleType parameter;
 *
 * @enum {string}
 * @api
 */
alk.val.VehicleType = {
  /** @api */
  Truck: pcmws.val.VehicleType.Truck,
  /** @api */
  LightTruck: pcmws.val.VehicleType.LightTruck,
  /** @api */
  Auto: pcmws.val.VehicleType.Auto
};
goog.provide('alk.VERSION');

goog.require('alk');

/**
 * @description
 * This property contains the version of the ALK Maps library,
 * which is 2.0.0.
 *
 * @type {string}
 * @api
 */
alk.VERSION = "2.0.0";
goog.require('alk.defaults');

/*
 * We always export the library with Production Defaults.
 */
alk.defaults.setProductionDefaults();
goog.provide('pcmws.api.Display');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');

/**
 * @classdesc
 * An instance of this class generates the Display parameter.
 *
 * @param {string=} value
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.Display = function (value) {
  pcmws.api.Display .base(this, 'constructor', 'display', value);
};
goog.inherits(pcmws.api.Display, pcmws.api.Param);
goog.provide('pcmws.api.HosRuleType');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.Param');
goog.require('pcmws.val.HosRuleType');

/**
 * @classdesc
 * An instance of this class holds the parameter name and value of the
 * 'HosRuleType' parameter in a PCM service.
 *
 * This parameter specifies the hours of service rule to use in creating a route.
 *
 * @param {pcmws.val.HosRuleType|number|string=} value The HosRuleType value for this parameter.
 * @constructor
 * @extends {pcmws.api.Param}
 *
 */
pcmws.api.HosRuleType = function (value) {
  pcmws.api.HosRuleType.base(this, 'constructor', 'hosRuleType', value);
};
goog.inherits(pcmws.api.HosRuleType, pcmws.api.Param);

/**
 * @inheritDoc
 */
pcmws.api.HosRuleType.prototype.check = function (value) {
  return this.checkHosRuleType(value);
};

/**
 * @description
 * TODO: The number values need to be checked for HosRuleType.
 * This function checks the validity of the HosRuleType parameter against its known possible values.
 * @param {boolean|number|string|undefined}  value The value to be checked against
 * @returns {pcmws.val.HosRuleType|string|undefined}
 */
pcmws.api.HosRuleType.prototype.checkHosRuleType = function (value) {

  if (this.checkValue(value, pcmws.val.HosRuleType.USFed607LH, 0)) {
    return pcmws.val.HosRuleType.USFed607LH;
  }
  else if (this.checkValue(value, pcmws.val.HosRuleType.USFed708LH, 1)) {
    return pcmws.val.HosRuleType.USFed708LH;
  }
  if (pcmws.ARG_CHECK) {
    throw "Illegal HosRuleType parameter value: " + value;
  }
  return undefined;
};
goog.provide('pcmws.api.UseAvoidFavors');

goog.require('pcmws');
goog.require('pcmws.api');
goog.require('pcmws.api.BooleanParam');

/**
 * @classdesc
 * An instance of this class represents the UseAvoidFavors parameter for a PCM service.
 * @param {boolean|string|number=} value The value.
 * @constructor
 * @extends {pcmws.api.BooleanParam}
 *
 */
pcmws.api.UseAvoidFavors = function (value) {
  pcmws.api.UseAvoidFavors.base(this, 'constructor', 'useAvoidFavors', value);
};
goog.inherits(pcmws.api.UseAvoidFavors, pcmws.api.BooleanParam);
goog.provide('pcmws.api.MapService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.MapURL');
goog.require('pcmws.api.PT1');
goog.require('pcmws.api.PT2');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.StaticServiceOptions');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.Width');


/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for
 * PCMiler Map service.
 * @param {pcmws.api.MapServiceOptions=} opt_options Options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.MapService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['drawerGroups', pcmws.api.DrawerGroups],
    ['format', pcmws.api.Format],
    ['imgOption', pcmws.api.ImgOption],
    ['imgSrc', pcmws.api.ImgSrc],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['style', pcmws.api.Style],
    ['width', pcmws.api.Width],
    ['height', pcmws.api.Height],
    ['pt1', pcmws.api.PT1],
    ['pt2', pcmws.api.PT2]
  ];
  pcmws.api.MapService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.StaticServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.MapURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.MapService, pcmws.api.StaticService);

/**
 * @override
 * @returns {pcmws.api.MapService}
 * @this {pcmws.api.MapService}
 */
pcmws.api.MapService.prototype.clone = function () {
  var opts = this.toServiceOptions();
  return new pcmws.api.MapService(opts);
};
goog.provide('pcmws.api.TrafficService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.Width');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.HistDay');
goog.require('pcmws.api.HistTimeBin');
goog.require('pcmws.api.HistTimeZone');
goog.require('pcmws.api.StrokeWidth');
goog.require('pcmws.api.PenWidth');
goog.require('pcmws.api.PT1');
goog.require('pcmws.api.PT2');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.TrafficURL');

goog.require('pcmws.api.TrafficServiceOptions');

/**
 * @param {pcmws.api.TrafficServiceOptions=} opt_options Options
 * @constructor
 * @extends {pcmws.api.StaticService}
 *
 */
pcmws.api.TrafficService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['drawerGroups', pcmws.api.DrawerGroups],
    ['format', pcmws.api.Format],
    ['imgOption', pcmws.api.ImgOption],
    ['imgSrc', pcmws.api.ImgSrc],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['style', pcmws.api.Style],
    ['width', pcmws.api.Width],
    ['height', pcmws.api.Height],
    ['histDay', pcmws.api.HistDay],
    ['histTimeBin', pcmws.api.HistTimeBin],
    ['histTimeZone', pcmws.api.HistTimeZone],
    ['strokeWidth', pcmws.api.StrokeWidth],
    ['penWidth', pcmws.api.PenWidth],
    ['pt1', pcmws.api.PT1],
    ['pt2', pcmws.api.PT2]
  ];
  pcmws.api.TrafficService.base(this, 'constructor', specs, opt_options);

  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.TrafficURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.TrafficService, pcmws.api.StaticService);


/**
 * @override
 * @this {pcmws.api.TrafficService}
 * @returns {pcmws.api.TrafficService}
 */
pcmws.api.TrafficService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.TrafficServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.TrafficService(opts);
};
goog.provide('pcmws.api.WeatherService');

goog.require('pcmws.api');
goog.require('pcmws.api.AuthToken');
goog.require('pcmws.api.Dataset');
goog.require('pcmws.api.DrawerGroups');
goog.require('pcmws.api.Format');
goog.require('pcmws.api.ImgOption');
goog.require('pcmws.api.ImgSrc');
goog.require('pcmws.api.Region');
goog.require('pcmws.api.SRS');
goog.require('pcmws.api.Style');
goog.require('pcmws.api.Width');
goog.require('pcmws.api.Height');
goog.require('pcmws.api.TimeOffset');
goog.require('pcmws.api.WeatherDisplay');
goog.require('pcmws.api.Proj');
goog.require('pcmws.api.ProductKey');
goog.require('pcmws.api.Country');
goog.require('pcmws.api.DeviceId');
goog.require('pcmws.api.PT1');
goog.require('pcmws.api.PT2');
goog.require('pcmws.api.Display');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.WeatherURL');

goog.require('pcmws.api.WeatherServiceOptions');

/**
 * @classdesc
 * An instance of this class configured with the given options,
 * generates the URL needed for the for
 * PCMiler Weather Map service.
 * @param {pcmws.api.WeatherServiceOptions=} opt_options
 * @extends {pcmws.api.StaticService}
 * @constructor
 *
 */
pcmws.api.WeatherService = function (opt_options) {
  var specs = [
    ['authToken', pcmws.api.AuthToken],
    ['dataset', pcmws.api.Dataset],
    ['drawerGroups', pcmws.api.DrawerGroups],
    ['format', pcmws.api.Format],
    ['imgOption', pcmws.api.ImgOption],
    ['imgSrc', pcmws.api.ImgSrc],
    ['region', pcmws.api.Region],
    ['srs', pcmws.api.SRS],
    ['style', pcmws.api.Style],
    ['width', pcmws.api.Width],
    ['height', pcmws.api.Height],
    ['timeOffset', pcmws.api.TimeOffset],
    ['weatherDisplay', pcmws.api.WeatherDisplay],
    ['proj', pcmws.api.Proj],
    ['productKey', pcmws.api.ProductKey],
    ['country', pcmws.api.Country],
    ['deviceId', pcmws.api.DeviceId],
    ['pt1', pcmws.api.PT1],
    ['pt2', pcmws.api.PT2],
    ['display', pcmws.api.Display]
  ];
  pcmws.api.WeatherService.base(this, 'constructor', specs, opt_options);

  /** @type {pcmws.api.WeatherServiceOptions} */
  var options = opt_options !== undefined ? opt_options : {};

  this.serviceURL_ = new pcmws.api.WeatherURL(options.hostURL, options.path);
};
goog.inherits(pcmws.api.WeatherService, pcmws.api.StaticService);


/**
 * @override
 * @returns {pcmws.api.WeatherService}
 */
pcmws.api.WeatherService.prototype.clone = function () {
  var opts = /** @type {pcmws.api.WeatherServiceOptions} */(this.toServiceOptions());
  return new pcmws.api.WeatherService(opts);
};
goog.provide('pcmws.api.TypeSingleSearchURL');

goog.require('pcmws.api');
goog.require('pcmws.api.SingleSearchServiceURL');

/**
 * @classdesc
 * An instance of this class returns the URL for the Single Search SingleSearchTypes service
 * @param {string=} hosturl This is the optional host URL, which should start with http/s://
 * @param {string=} path This is the optional path override.
 * @constructor
 * @extends {pcmws.api.SingleSearchServiceURL}
 *
 */
pcmws.api.TypeSingleSearchURL = function (hosturl, path) {
  pcmws.api.TypeSingleSearchURL.base(this, 'constructor', hosturl, path);
};
goog.inherits(pcmws.api.TypeSingleSearchURL, pcmws.api.SingleSearchServiceURL);

/**
 * @description
 * The default path for the Single Search SingleSearchTypes URL.
 * @type {string}
 * @override
 *
 */
pcmws.api.TypeSingleSearchURL.prototype.path;
goog.provide('pcmws.val.RadiusUnits');

goog.require('pcmws.val');
/**
 * @description
 * This object contains the definitive values for the DistanceUnits parameter;
 *
 * @enum {string}
 * 
 */
pcmws.val.RadiusUnits = {
  /**  */
  Miles: 'Miles',
  /**  */
  Kilometers: 'Kilometers'
};

goog.require('alk');
goog.require('pcmws');

alk.VERSION = "2.0.0";
pcmws.VERSION = "1.0.0";
/**
 * @fileoverview Custom exports file.
 * @suppress {checkVars,extraRequire}
 */

goog.require('alk');
goog.require('alk.ATTRIBUTION');
goog.require('alk.VERSION');
goog.require('alk.color');
goog.require('alk.control.ContextMenu');
goog.require('alk.defaults');
goog.require('alk.format.FormatType');
goog.require('alk.format.HashedIdFactory');
goog.require('alk.format.JSONFeature');
goog.require('alk.format.POIJSON');
goog.require('alk.format.TrafficCamerasJSON');
goog.require('alk.format.TrafficIncidentsJSON');
goog.require('alk.format.WeatherAlertsJSON');
goog.require('alk.geocode.Geocoder');
goog.require('alk.geocode.ReverseGeocoder');
goog.require('alk.img.Hazmat');
goog.require('alk.img.Misc');
goog.require('alk.img.POI');
goog.require('alk.img.Traffic');
goog.require('alk.img.TruckRestr');
goog.require('alk.interaction.EditTrailRoutingLayerKeyShortCuts');
goog.require('alk.interaction.RouteModify');
goog.require('alk.interaction.SingleSearchPopupInteraction');
goog.require('alk.interaction.TrafficCameraPopupInteraction');
goog.require('alk.interaction.TrafficIncidentPopupInteraction');
goog.require('alk.interaction.ViaPointRouteModify');
goog.require('alk.interaction.WayPointRouteModify');
goog.require('alk.layer.BaseMapLayer');
goog.require('alk.layer.DriveTimeLayer');
goog.require('alk.layer.EditTrailRoutingLayer');
goog.require('alk.layer.ImageTileLayer');
goog.require('alk.layer.MapLayer');
goog.require('alk.layer.MultiRoutingLayer');
goog.require('alk.layer.POILayer');
goog.require('alk.layer.RoadSurfaceRouteLayer');
goog.require('alk.layer.RoadSurfaceTileLayer');
goog.require('alk.layer.RoutingLayer');
goog.require('alk.layer.SingleRoutingLayer');
goog.require('alk.layer.SingleSearchLayer');
goog.require('alk.layer.TrafficCamerasLayer');
goog.require('alk.layer.TrafficIncidentsLayer');
goog.require('alk.layer.TrafficLayer');
goog.require('alk.layer.WeatherAlertsLayer');
goog.require('alk.layer.WeatherLayer');
goog.require('alk.layer.WeatherRadarLayer');
goog.require('alk.layer.WeatherSatelliteLayer');
goog.require('alk.overlay.ListTooltipOverlay');
goog.require('alk.overlay.SingleSearchItemPopup');
goog.require('alk.overlay.TrafficCameraPopup');
goog.require('alk.overlay.TrafficIncidentPopup');
goog.require('alk.overlay.WeatherAlertPopup');
goog.require('alk.service');
goog.require('alk.service.AvoidFavorSetsService');
goog.require('alk.service.AvoidFavorsService');
goog.require('alk.service.CountriesSingleSearchService');
goog.require('alk.service.CustomCategoriesService');
goog.require('alk.service.CustomPlaceSetsService');
goog.require('alk.service.CustomPlacesService');
goog.require('alk.service.DriveTimePolygonService');
goog.require('alk.service.LocationsReverseService');
goog.require('alk.service.LocationsService');
goog.require('alk.service.MapTileService');
goog.require('alk.service.MultipleServiceRequestEngine');
goog.require('alk.service.POICategoriesSingleSearchService');
goog.require('alk.service.POIService');
goog.require('alk.service.PolygonsCountyService');
goog.require('alk.service.RestService');
goog.require('alk.service.RoadSurfaceRouteService');
goog.require('alk.service.RoadSurfaceTileService');
goog.require('alk.service.RoutePathService');
goog.require('alk.service.RouteReportsService');
goog.require('alk.service.RouteService');
goog.require('alk.service.SearchSingleSearchService');
goog.require('alk.service.SearchTypesSingleSearchService');
goog.require('alk.service.Service');
goog.require('alk.service.ServiceBase');
goog.require('alk.service.StatesSingleSearchService');
goog.require('alk.service.TrafficCameraMetadataService');
goog.require('alk.service.TrafficCamerasService');
goog.require('alk.service.TrafficIncidentsService');
goog.require('alk.service.TrafficTileService');
goog.require('alk.service.WeatherAlertsService');
goog.require('alk.service.WeatherImageTileService');
goog.require('alk.source.BaseMapSource');
goog.require('alk.source.DriveTimePolygon');
goog.require('alk.source.EditTrailRoute');
goog.require('alk.source.ImageTileSource');
goog.require('alk.source.LoadStrategy');
goog.require('alk.source.MultiRoute');
goog.require('alk.source.POISource');
goog.require('alk.source.PolygonsCountyCache');
goog.require('alk.source.RoadSurfaceRoute');
goog.require('alk.source.RoadSurfaceTileSource');
goog.require('alk.source.Route');
goog.require('alk.source.SingleRoadSurfaceRoute');
goog.require('alk.source.SingleRoute');
goog.require('alk.source.SingleSearch');
goog.require('alk.source.SubtractionLoadStrategy');
goog.require('alk.source.TrafficCameraMetadataCache');
goog.require('alk.source.TrafficCamerasSource');
goog.require('alk.source.TrafficIncidentsSource');
goog.require('alk.source.TrafficSource');
goog.require('alk.source.WeatherAlertsSource');
goog.require('alk.source.WeatherSource');
goog.require('alk.source.XYZSource');
goog.require('alk.style.Arrow');
goog.require('alk.style.ArrowsRouteStyle');
goog.require('alk.style.DriveTimeLayerStyle');
goog.require('alk.style.EditRouteStyle');
goog.require('alk.style.IconPOILayerStyle');
goog.require('alk.style.LineRouteStyle');
goog.require('alk.style.POIIconFactory');
goog.require('alk.style.POILayerStyle');
goog.require('alk.style.PolygonWeatherAlertsLayerStyle');
goog.require('alk.style.QueuedLineRouteStyle');
goog.require('alk.style.QueuedStyleLayerStyle');
goog.require('alk.style.RoadSurfaceStyle');
goog.require('alk.style.RoutingLayerStyle');
goog.require('alk.style.Shadow');
goog.require('alk.style.ShadowedCircle');
goog.require('alk.style.SingleSearchStyle');
goog.require('alk.style.StopsRouteStyle');
goog.require('alk.style.StrokeQueue');
goog.require('alk.style.StyleQueue');
goog.require('alk.style.TrafficCamerasLayerStyle');
goog.require('alk.style.TrafficIncidentsLayerStyle');
goog.require('alk.style.UpdatingLayerStyle');
goog.require('alk.style.WayPointsEditRouteStyle');
goog.require('alk.style.WeatherAlertsLayerStyle');
goog.require('alk.val.ArrowsType');
goog.require('alk.val.Certainty');
goog.require('alk.val.Dataset');
goog.require('alk.val.Display');
goog.require('alk.val.DistanceUnits');
goog.require('alk.val.DrawerGroup');
goog.require('alk.val.Format');
goog.require('alk.val.FuelUnits');
goog.require('alk.val.HazMat');
goog.require('alk.val.HistDay');
goog.require('alk.val.HosRuleType');
goog.require('alk.val.ImgOption');
goog.require('alk.val.ImgSrc');
goog.require('alk.val.Language');
goog.require('alk.val.OverrideClass');
goog.require('alk.val.POICategory');
goog.require('alk.val.Provider');
goog.require('alk.val.Region');
goog.require('alk.val.Report');
goog.require('alk.val.ReportFormat');
goog.require('alk.val.RouteOptimization');
goog.require('alk.val.RouteType');
goog.require('alk.val.SRS');
goog.require('alk.val.Severity');
goog.require('alk.val.StopType');
goog.require('alk.val.Style');
goog.require('alk.val.TollCurrency');
goog.require('alk.val.TollPlan');
goog.require('alk.val.TruckConfig');
goog.require('alk.val.Urgency');
goog.require('alk.val.VehicleDimensionUnits');
goog.require('alk.val.VehicleType');
goog.require('alk.val.WeatherAlertColor');
goog.require('alkx.AvoidFavorSetsServiceAddOptions');
goog.require('alkx.AvoidFavorSetsServiceDeleteOptions');
goog.require('alkx.AvoidFavorSetsServiceGetOptions');
goog.require('alkx.AvoidFavorSetsServiceUpdateOptions');
goog.require('alkx.AvoidFavorsServiceAddOptions');
goog.require('alkx.AvoidFavorsServiceDeleteOptions');
goog.require('alkx.BaseMapLayerOptions');
goog.require('alkx.BaseMapSourceOptions');
goog.require('alkx.ContextMenuOptions');
goog.require('alkx.CustomCategoriesServiceAddOptions');
goog.require('alkx.CustomCategoriesServiceDeleteOptions');
goog.require('alkx.CustomCategoriesServiceGetOptions');
goog.require('alkx.CustomCategoriesServiceUpdateOptions');
goog.require('alkx.CustomPlaceSetsServiceAddOptions');
goog.require('alkx.CustomPlaceSetsServiceDeleteOptions');
goog.require('alkx.CustomPlaceSetsServiceGetOptions');
goog.require('alkx.CustomPlaceSetsServiceUpdateOptions');
goog.require('alkx.CustomPlacesAddress');
goog.require('alkx.CustomPlacesCoords');
goog.require('alkx.CustomPlacesPlace');
goog.require('alkx.CustomPlacesServiceAddOptions');
goog.require('alkx.CustomPlacesServiceDeleteOptions');
goog.require('alkx.CustomPlacesServiceUpdateOptions');
goog.require('alkx.CustomPlacesSet');
goog.require('alkx.DefaultOptions');
goog.require('alkx.DriveTimeLayerOptions');
goog.require('alkx.DriveTimeLayerStyleOptions');
goog.require('alkx.DriveTimePolygonServiceResponse');
goog.require('alkx.DriveTimePolygonSourceOptions');
goog.require('alkx.EditTrailRoutingLayerKeyShortCutsOptions');
goog.require('alkx.GeocodeAddress');
goog.require('alkx.GeocoderGeocodeOptions');
goog.require('alkx.GeocoderOptions');
goog.require('alkx.HashedIdFactoryOptions');
goog.require('alkx.LayerOptions');
goog.require('alkx.ListTooltipOverlayOptions');
goog.require('alkx.LoadStrategyOptions');
goog.require('alkx.LocationsReverseServiceResponse');
goog.require('alkx.MapLayerOptions');
goog.require('alkx.MultiRoutingLayerAddRouteOptions');
goog.require('alkx.MultipleServiceRequestEngineOptions');
goog.require('alkx.NormalizedAddress');
goog.require('alkx.POILayerOptions');
goog.require('alkx.POISourceOptions');
goog.require('alkx.PolygonsCountyCacheOptions');
goog.require('alkx.ReverseGeocoderOptions');
goog.require('alkx.ReverseGeocoderReverseGeocodeOptions');
goog.require('alkx.RoadSurfaceLayerOptions');
goog.require('alkx.RoadSurfaceRouteLayerOptions');
goog.require('alkx.RoadSurfaceRouteServiceResponse');
goog.require('alkx.RoadSurfaceRouteSourceOptions');
goog.require('alkx.RoadSurfaceTileSourceOptions');
goog.require('alkx.RouteServiceResponse');
goog.require('alkx.RouteSourceOptions');
goog.require('alkx.RoutingLayerOptions');
goog.require('alkx.SearchTypesSingleSearchServiceResponse');
goog.require('alkx.SearchTypesSingleSearchServiceResult');
goog.require('alkx.ServiceOptions');
goog.require('alkx.SingleSearchItemPopupOptions');
goog.require('alkx.SingleSearchLayerOptions');
goog.require('alkx.SingleSearchSourceOptions');
goog.require('alkx.SourceOptions');
goog.require('alkx.SubtractionLoadStrategyOptions');
goog.require('alkx.TileLayerOptions');
goog.require('alkx.TrafficCameraMetadataCacheOptions');
goog.require('alkx.TrafficCameraPopupInteractionOptions');
goog.require('alkx.TrafficCameraPopupOptions');
goog.require('alkx.TrafficCamerasLayerOptions');
goog.require('alkx.TrafficCamerasSourceOptions');
goog.require('alkx.TrafficIncidentPopupOptions');
goog.require('alkx.TrafficIncidentsLayerOptions');
goog.require('alkx.TrafficIncidentsSourceOptions');
goog.require('alkx.TrafficLayerOptions');
goog.require('alkx.TrafficServiceOptions');
goog.require('alkx.TrafficSourceOptions');
goog.require('alkx.WeatherAlertPopupOptions');
goog.require('alkx.WeatherAlertsLayerOptions');
goog.require('alkx.WeatherAlertsSourceOptions');
goog.require('alkx.WeatherLayerOptions');
goog.require('alkx.WeatherSourceOptions');
goog.require('alkx.XYZSourceOptions');
goog.require('alkx.format.POIJSONOptions');
goog.require('alkx.format.TrafficCamerasJSONOptions');
goog.require('alkx.format.TrafficIncidentsJSONOptions');
goog.require('alkx.format.WeatherAlertsJSONOptions');
goog.require('alkx.interaction.RouteModifyOptions');
goog.require('alkx.style.ArrowOptions');
goog.require('pcmws.api.ContentServiceURL');
goog.require('pcmws.api.CountriesSingleSearchURL');
goog.require('pcmws.api.CustomCategoriesRestServiceURL');
goog.require('pcmws.api.CustomPlaceSetsRestServiceURL');
goog.require('pcmws.api.CustomPlacesRestServiceURL');
goog.require('pcmws.api.DriveTimePolygonURL');
goog.require('pcmws.api.LocationsReverseURL');
goog.require('pcmws.api.LocationsURL');
goog.require('pcmws.api.MapTileURL');
goog.require('pcmws.api.MapURL');
goog.require('pcmws.api.PCMServiceURL');
goog.require('pcmws.api.POICategoriesSingleSearchURL');
goog.require('pcmws.api.POIURL');
goog.require('pcmws.api.PolygonsCountyURL');
goog.require('pcmws.api.RestServiceURL');
goog.require('pcmws.api.RoadSurfaceRouteURL');
goog.require('pcmws.api.RouteReportsURL');
goog.require('pcmws.api.RouteURL');
goog.require('pcmws.api.SearchSingleSearchURL');
goog.require('pcmws.api.SearchTypesSingleSearchURL');
goog.require('pcmws.api.StatesSingleSearchURL');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.StaticServiceURL');
goog.require('pcmws.api.TrafficCameraImageURL');
goog.require('pcmws.api.TrafficCameraMetadataURL');
goog.require('pcmws.api.TrafficCamerasURL');
goog.require('pcmws.api.TrafficIncidentsURL');
goog.require('pcmws.api.TrafficURL');
goog.require('pcmws.api.TypeSingleSearchURL');
goog.require('pcmws.api.WeatherAlertsURL');
goog.require('pcmws.api.WeatherURL');



goog.exportSymbol(
    'alk.ATTRIBUTION',
    alk.ATTRIBUTION,
    ALKMAPS);

goog.exportSymbol(
    'alk.color.shadeColor',
    alk.color.shadeColor,
    ALKMAPS);

goog.exportSymbol(
    'alk.control.ContextMenu',
    alk.control.ContextMenu,
    ALKMAPS);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'handleRightClicks',
    alk.control.ContextMenu.prototype.handleRightClicks);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'autoActivate',
    alk.control.ContextMenu.prototype.autoActivate);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'ctxMenuItems',
    alk.control.ContextMenu.prototype.ctxMenuItems);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'items',
    alk.control.ContextMenu.prototype.items);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'setMap',
    alk.control.ContextMenu.prototype.setMap);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'render',
    alk.control.ContextMenu.prototype.render);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'positionContainer',
    alk.control.ContextMenu.prototype.positionContainer);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'openMenu',
    alk.control.ContextMenu.prototype.openMenu);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'closeMenu',
    alk.control.ContextMenu.prototype.closeMenu);

goog.exportSymbol(
    'alk.defaults.setApiKey',
    alk.defaults.setApiKey,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setProductionDefaults',
    alk.defaults.setProductionDefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setDevelopmentDefaults',
    alk.defaults.setDevelopmentDefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setQADefaults',
    alk.defaults.setQADefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setHermeticDefaults',
    alk.defaults.setHermeticDefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getMapTileUrl',
    alk.defaults.getMapTileUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getPCMServiceUrl',
    alk.defaults.getPCMServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getStaticServiceUrl',
    alk.defaults.getStaticServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getNewMapTileUrl',
    alk.defaults.getNewMapTileUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getNewPCMServiceUrl',
    alk.defaults.getNewPCMServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getNewStaticServiceUrl',
    alk.defaults.getNewStaticServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.ARRAY_BUFFER',
    alk.format.FormatType.ARRAY_BUFFER,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.JSON',
    alk.format.FormatType.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.TEXT',
    alk.format.FormatType.TEXT,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.XML',
    alk.format.FormatType.XML,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.HashedIdFactory',
    alk.format.HashedIdFactory,
    ALKMAPS);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'hashCollisionFix',
    alk.format.HashedIdFactory.prototype.hashCollisionFix);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'getIdForString',
    alk.format.HashedIdFactory.prototype.getIdForString);

goog.exportSymbol(
    'alk.format.JSONFeature',
    alk.format.JSONFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.POIJSON',
    alk.format.POIJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficCamerasJSON',
    alk.format.TrafficCamerasJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficIncidentsJSON',
    alk.format.TrafficIncidentsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.WeatherAlertsJSON',
    alk.format.WeatherAlertsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.geocode.Geocoder',
    alk.geocode.Geocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.Geocoder.prototype,
    'geocode',
    alk.geocode.Geocoder.prototype.geocode);

goog.exportSymbol(
    'alk.geocode.ReverseGeocoder',
    alk.geocode.ReverseGeocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.ReverseGeocoder.prototype,
    'reverseGeocode',
    alk.geocode.ReverseGeocoder.prototype.reverseGeocode);

goog.exportSymbol(
    'alk.img.Hazmat.Caustic',
    alk.img.Hazmat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Explosive',
    alk.img.Hazmat.Explosive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Flammable',
    alk.img.Hazmat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Inhalants',
    alk.img.Hazmat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Radioactive',
    alk.img.Hazmat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericEU',
    alk.img.Hazmat.GenericEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericUS',
    alk.img.Hazmat.GenericUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Water',
    alk.img.Hazmat.Water,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AllowRoad',
    alk.img.Misc.AllowRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AvoidRoad',
    alk.img.Misc.AvoidRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Check',
    alk.img.Misc.Check,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagEnd',
    alk.img.Misc.FlagEnd,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStart',
    alk.img.Misc.FlagStart,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStop',
    alk.img.Misc.FlagStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagWaypoint',
    alk.img.Misc.FlagWaypoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Help',
    alk.img.Misc.Help,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadBlue',
    alk.img.Misc.LoadBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGray',
    alk.img.Misc.LoadGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGreen',
    alk.img.Misc.LoadGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadRed',
    alk.img.Misc.LoadRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.No',
    alk.img.Misc.No,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.OilGas',
    alk.img.Misc.OilGas,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinGreen',
    alk.img.Misc.PinGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinRed',
    alk.img.Misc.PinRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Route',
    alk.img.Misc.Route,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckBlue',
    alk.img.Misc.TruckBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGray',
    alk.img.Misc.TruckGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGreen',
    alk.img.Misc.TruckGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckRed',
    alk.img.Misc.TruckRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Address',
    alk.img.POI.Address,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Airport',
    alk.img.POI.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Atm',
    alk.img.POI.Atm,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Attraction',
    alk.img.POI.Attraction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoDealer',
    alk.img.POI.AutoDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRental',
    alk.img.POI.AutoRental,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRepair',
    alk.img.POI.AutoRepair,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Bank',
    alk.img.POI.Bank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Blank',
    alk.img.POI.Blank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BorderCrossing',
    alk.img.POI.BorderCrossing,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BridgeTunnel',
    alk.img.POI.BridgeTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BusStop',
    alk.img.POI.BusStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CatScale',
    alk.img.POI.CatScale,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.City',
    alk.img.POI.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CommuterRail',
    alk.img.POI.CommuterRail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.DieselExhaustFluid',
    alk.img.POI.DieselExhaustFluid,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Entertainment',
    alk.img.POI.Entertainment,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Favorite',
    alk.img.POI.Favorite,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Ferry',
    alk.img.POI.Ferry,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Fuel',
    alk.img.POI.Fuel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GameVenues',
    alk.img.POI.GameVenues,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GenericResult',
    alk.img.POI.GenericResult,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GeographicFeature',
    alk.img.POI.GeographicFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Grocery',
    alk.img.POI.Grocery,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Home',
    alk.img.POI.Home,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Hotel',
    alk.img.POI.Hotel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.IndustrialEstate',
    alk.img.POI.IndustrialEstate,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveLink',
    alk.img.POI.LiveLink,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveSearch',
    alk.img.POI.LiveSearch,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marina',
    alk.img.POI.Marina,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marker',
    alk.img.POI.Marker,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Medical',
    alk.img.POI.Medical,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MotorcycleDealer',
    alk.img.POI.MotorcycleDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Municipal',
    alk.img.POI.Municipal,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MyCar',
    alk.img.POI.MyCar,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherAirport',
    alk.img.POI.OtherAirport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherLodging',
    alk.img.POI.OtherLodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Other',
    alk.img.POI.Other,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Park',
    alk.img.POI.Park,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Parking',
    alk.img.POI.Parking,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PlaceOfWorship',
    alk.img.POI.PlaceOfWorship,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PublicVenue',
    alk.img.POI.PublicVenue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recent',
    alk.img.POI.Recent,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recreation',
    alk.img.POI.Recreation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RestArea',
    alk.img.POI.RestArea,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Restaurant',
    alk.img.POI.Restaurant,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Retail',
    alk.img.POI.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RV',
    alk.img.POI.RV,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.SafetyCamera',
    alk.img.POI.SafetyCamera,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.School',
    alk.img.POI.School,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TandemTrailer',
    alk.img.POI.TandemTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TollBooth',
    alk.img.POI.TollBooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TrainStation',
    alk.img.POI.TrainStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Truck',
    alk.img.POI.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TruckStop',
    alk.img.POI.TruckStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.VehicleChargingStation',
    alk.img.POI.VehicleChargingStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Wikipedia',
    alk.img.POI.Wikipedia,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Work',
    alk.img.POI.Work,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapAccident',
    alk.img.Traffic.MapAccident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapConstruction',
    alk.img.Traffic.MapConstruction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapIncident',
    alk.img.Traffic.MapIncident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapTrafficJam',
    alk.img.Traffic.MapTrafficJam,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapWeather',
    alk.img.Traffic.MapWeather,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity1',
    alk.img.Traffic.Severity1,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity2',
    alk.img.Traffic.Severity2,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity3',
    alk.img.Traffic.Severity3,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightEU',
    alk.img.TruckRestr.HeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightNA',
    alk.img.TruckRestr.HeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthEU',
    alk.img.TruckRestr.LengthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthNA',
    alk.img.TruckRestr.LengthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiEU',
    alk.img.TruckRestr.MultiEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiNA',
    alk.img.TruckRestr.MultiNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckEU',
    alk.img.TruckRestr.NoTruckEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckNA',
    alk.img.TruckRestr.NoTruckNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightEU',
    alk.img.TruckRestr.WeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightNA',
    alk.img.TruckRestr.WeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleEU',
    alk.img.TruckRestr.WeightPerAxleEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleNA',
    alk.img.TruckRestr.WeightPerAxleNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthEU',
    alk.img.TruckRestr.WidthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthNA',
    alk.img.TruckRestr.WidthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.EditTrailRoutingLayerKeyShortCuts',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype,
    'handleMapBrowserEvent',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.handleMapBrowserEvent);

goog.exportSymbol(
    'alk.interaction.RouteModify',
    alk.interaction.RouteModify,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayer',
    alk.interaction.RouteModify.prototype.routingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'setRoutingLayer',
    alk.interaction.RouteModify.prototype.setRoutingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'shouldModify',
    alk.interaction.RouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedStops',
    alk.interaction.RouteModify.prototype.getModifiedStops);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedSegments',
    alk.interaction.RouteModify.prototype.getModifiedSegments);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiableStopTypes',
    alk.interaction.RouteModify.prototype.getModifiableStopTypes);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getCreationStopType',
    alk.interaction.RouteModify.prototype.getCreationStopType);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processEvent',
    alk.interaction.RouteModify.prototype.processEvent);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayerStyle',
    alk.interaction.RouteModify.prototype.routingLayerStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processStyle',
    alk.interaction.RouteModify.prototype.processStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'handleEvent',
    alk.interaction.RouteModify.prototype.handleEvent);

goog.exportSymbol(
    'alk.interaction.SingleSearchPopupInteraction',
    alk.interaction.SingleSearchPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.SingleSearchPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.SingleSearchPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficCameraPopupInteraction',
    alk.interaction.TrafficCameraPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficCameraPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficCameraPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficIncidentPopupInteraction',
    alk.interaction.TrafficIncidentPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficIncidentPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficIncidentPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.ViaPointRouteModify',
    alk.interaction.ViaPointRouteModify,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.WayPointRouteModify',
    alk.interaction.WayPointRouteModify,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.BaseMapLayer',
    alk.layer.BaseMapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.DriveTimeLayer',
    alk.layer.DriveTimeLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.DriveTimeLayer.prototype,
    'addDriveTimePolygon',
    alk.layer.DriveTimeLayer.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.layer.EditTrailRoutingLayer',
    alk.layer.EditTrailRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'pushRoute',
    alk.layer.EditTrailRoutingLayer.prototype.pushRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'prevRoute',
    alk.layer.EditTrailRoutingLayer.prototype.prevRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'nextRoute',
    alk.layer.EditTrailRoutingLayer.prototype.nextRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'resetEditTrail',
    alk.layer.EditTrailRoutingLayer.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.layer.ImageTileLayer',
    alk.layer.ImageTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MapLayer',
    alk.layer.MapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MultiRoutingLayer',
    alk.layer.MultiRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'addRoute',
    alk.layer.MultiRoutingLayer.prototype.addRoute);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'removeRoute',
    alk.layer.MultiRoutingLayer.prototype.removeRoute);

goog.exportSymbol(
    'alk.layer.POILayer',
    alk.layer.POILayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'getPOILayerStyle',
    alk.layer.POILayer.prototype.getPOILayerStyle);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'setStyle',
    alk.layer.POILayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceRouteLayer',
    alk.layer.RoadSurfaceRouteLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'getRoadSurfaceStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.getRoadSurfaceStyle);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'setStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceTileLayer',
    alk.layer.RoadSurfaceTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.RoutingLayer',
    alk.layer.RoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'getRoutingLayerStyle',
    alk.layer.RoutingLayer.prototype.getRoutingLayerStyle);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'setStyle',
    alk.layer.RoutingLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.SingleRoutingLayer',
    alk.layer.SingleRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'setRoute',
    alk.layer.SingleRoutingLayer.prototype.setRoute);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'getRoute',
    alk.layer.SingleRoutingLayer.prototype.getRoute);

goog.exportSymbol(
    'alk.layer.SingleSearchLayer',
    alk.layer.SingleSearchLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'getSingleSearchStyle',
    alk.layer.SingleSearchLayer.prototype.getSingleSearchStyle);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'setStyle',
    alk.layer.SingleSearchLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficCamerasLayer',
    alk.layer.TrafficCamerasLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'getTrafficCameraLayerStyle',
    alk.layer.TrafficCamerasLayer.prototype.getTrafficCameraLayerStyle);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'setStyle',
    alk.layer.TrafficCamerasLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficIncidentsLayer',
    alk.layer.TrafficIncidentsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'getTrafficIncidentLayerStyle',
    alk.layer.TrafficIncidentsLayer.prototype.getTrafficIncidentLayerStyle);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'setStyle',
    alk.layer.TrafficIncidentsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficLayer',
    alk.layer.TrafficLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherAlertsLayer',
    alk.layer.WeatherAlertsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'getWeatherAlertsLayerStyle',
    alk.layer.WeatherAlertsLayer.prototype.getWeatherAlertsLayerStyle);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'setStyle',
    alk.layer.WeatherAlertsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.WeatherLayer',
    alk.layer.WeatherLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherRadarLayer',
    alk.layer.WeatherRadarLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherSatelliteLayer',
    alk.layer.WeatherSatelliteLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.overlay.ListTooltipOverlay',
    alk.overlay.ListTooltipOverlay,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setAssigned',
    alk.overlay.ListTooltipOverlay.prototype.setAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'getAssigned',
    alk.overlay.ListTooltipOverlay.prototype.getAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'assigned',
    alk.overlay.ListTooltipOverlay.prototype.assigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'addListItem',
    alk.overlay.ListTooltipOverlay.prototype.addListItem);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'clear',
    alk.overlay.ListTooltipOverlay.prototype.clear);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setDisplay',
    alk.overlay.ListTooltipOverlay.prototype.setDisplay);

goog.exportSymbol(
    'alk.overlay.SingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'closeElement',
    alk.overlay.SingleSearchItemPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'setSingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup.prototype.setSingleSearchItemPopup);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'listFormat',
    alk.overlay.SingleSearchItemPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createListHTML',
    alk.overlay.SingleSearchItemPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createContentElement',
    alk.overlay.SingleSearchItemPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createPopupElement',
    alk.overlay.SingleSearchItemPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficCameraPopup',
    alk.overlay.TrafficCameraPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'closeElement',
    alk.overlay.TrafficCameraPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'setTrafficCamera',
    alk.overlay.TrafficCameraPopup.prototype.setTrafficCamera);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'listFormat',
    alk.overlay.TrafficCameraPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficCameraPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficCameraPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficCameraPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficIncidentPopup',
    alk.overlay.TrafficIncidentPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'closeElement',
    alk.overlay.TrafficIncidentPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'setTrafficIncident',
    alk.overlay.TrafficIncidentPopup.prototype.setTrafficIncident);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'listFormat',
    alk.overlay.TrafficIncidentPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficIncidentPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficIncidentPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficIncidentPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.WeatherAlertPopup',
    alk.overlay.WeatherAlertPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'closeElement',
    alk.overlay.WeatherAlertPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'setWeatherAlert',
    alk.overlay.WeatherAlertPopup.prototype.setWeatherAlert);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'listFormat',
    alk.overlay.WeatherAlertPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'itemFormat',
    alk.overlay.WeatherAlertPopup.prototype.itemFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createItemHTML',
    alk.overlay.WeatherAlertPopup.prototype.createItemHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createListHTML',
    alk.overlay.WeatherAlertPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'elements',
    alk.overlay.WeatherAlertPopup.prototype.elements);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createContentElement',
    alk.overlay.WeatherAlertPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createPopupElement',
    alk.overlay.WeatherAlertPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.service.AvoidFavorSetsService',
    alk.service.AvoidFavorSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'get',
    alk.service.AvoidFavorSetsService.prototype.get);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'add',
    alk.service.AvoidFavorSetsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'update',
    alk.service.AvoidFavorSetsService.prototype.update);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'delete',
    alk.service.AvoidFavorSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.AvoidFavorsService',
    alk.service.AvoidFavorsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'add',
    alk.service.AvoidFavorsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'delete',
    alk.service.AvoidFavorsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CountriesSingleSearchService',
    alk.service.CountriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.CustomCategoriesService',
    alk.service.CustomCategoriesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'get',
    alk.service.CustomCategoriesService.prototype.get);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'add',
    alk.service.CustomCategoriesService.prototype.add);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'update',
    alk.service.CustomCategoriesService.prototype.update);

goog.exportSymbol(
    'alk.service.CustomPlaceSetsService',
    alk.service.CustomPlaceSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'get',
    alk.service.CustomPlaceSetsService.prototype.get);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'add',
    alk.service.CustomPlaceSetsService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'update',
    alk.service.CustomPlaceSetsService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'delete',
    alk.service.CustomPlaceSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CustomPlacesService',
    alk.service.CustomPlacesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'add',
    alk.service.CustomPlacesService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'update',
    alk.service.CustomPlacesService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'delete',
    alk.service.CustomPlacesService.prototype.delete);

goog.exportSymbol(
    'alk.service.DriveTimePolygonService',
    alk.service.DriveTimePolygonService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsReverseService',
    alk.service.LocationsReverseService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsService',
    alk.service.LocationsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MapTileService',
    alk.service.MapTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MultipleServiceRequestEngine',
    alk.service.MultipleServiceRequestEngine,
    ALKMAPS);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'queueRequest',
    alk.service.MultipleServiceRequestEngine.prototype.queueRequest);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'processQueue',
    alk.service.MultipleServiceRequestEngine.prototype.processQueue);

goog.exportSymbol(
    'alk.service.POICategoriesSingleSearchService',
    alk.service.POICategoriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.POIService',
    alk.service.POIService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.PolygonsCountyService',
    alk.service.PolygonsCountyService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RestService',
    alk.service.RestService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceRouteService',
    alk.service.RoadSurfaceRouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceTileService',
    alk.service.RoadSurfaceTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoutePathService',
    alk.service.RoutePathService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteReportsService',
    alk.service.RouteReportsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteService',
    alk.service.RouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchSingleSearchService',
    alk.service.SearchSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchTypesSingleSearchService',
    alk.service.SearchTypesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.ServiceBase',
    alk.service.ServiceBase,
    ALKMAPS);

goog.exportProperty(
    alk.service.ServiceBase.prototype,
    'getServiceOptions',
    alk.service.ServiceBase.prototype.getServiceOptions);

goog.exportSymbol(
    'alk.service.Service',
    alk.service.Service,
    ALKMAPS);

goog.exportProperty(
    alk.service.Service.prototype,
    'getURL',
    alk.service.Service.prototype.getURL);

goog.exportProperty(
    alk.service.Service.prototype,
    'get',
    alk.service.Service.prototype.get);

goog.exportProperty(
    alk.service.Service.prototype,
    'processResponse',
    alk.service.Service.prototype.processResponse);

goog.exportProperty(
    alk.service.Service.prototype,
    'getAttribution',
    alk.service.Service.prototype.getAttribution);

goog.exportSymbol(
    'alk.service.StatesSingleSearchService',
    alk.service.StatesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCameraMetadataService',
    alk.service.TrafficCameraMetadataService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCamerasService',
    alk.service.TrafficCamerasService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficIncidentsService',
    alk.service.TrafficIncidentsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficTileService',
    alk.service.TrafficTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherAlertsService',
    alk.service.WeatherAlertsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherImageTileService',
    alk.service.WeatherImageTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgCheck',
    alk.service.setArgCheck,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgPermissive',
    alk.service.setArgPermissive,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.BaseMapSource',
    alk.source.BaseMapSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.DriveTimePolygon',
    alk.source.DriveTimePolygon,
    ALKMAPS);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'getDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.getDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'setDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.setDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'addDriveTimePolygon',
    alk.source.DriveTimePolygon.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.source.EditTrailRoute',
    alk.source.EditTrailRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'pushRoute',
    alk.source.EditTrailRoute.prototype.pushRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'prevRoute',
    alk.source.EditTrailRoute.prototype.prevRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'nextRoute',
    alk.source.EditTrailRoute.prototype.nextRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'resetEditTrail',
    alk.source.EditTrailRoute.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.source.ImageTileSource',
    alk.source.ImageTileSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.LoadStrategy',
    alk.source.LoadStrategy,
    ALKMAPS);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMinResolution',
    alk.source.LoadStrategy.prototype.getMinResolution);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMaxResolution',
    alk.source.LoadStrategy.prototype.getMaxResolution);

goog.exportSymbol(
    'alk.source.MultiRoute',
    alk.source.MultiRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceResponse',
    alk.source.MultiRoute.prototype.getRouteServiceResponse);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'addRoute',
    alk.source.MultiRoute.prototype.addRoute);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteFeatures',
    alk.source.MultiRoute.prototype.getRouteFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getLineFeatures',
    alk.source.MultiRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteIds',
    alk.source.MultiRoute.prototype.getRouteIds);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceOptions',
    alk.source.MultiRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'removeRoute',
    alk.source.MultiRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.POISource',
    alk.source.POISource,
    ALKMAPS);

goog.exportProperty(
    alk.source.POISource.prototype,
    'getPOIService',
    alk.source.POISource.prototype.getPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'setPOIService',
    alk.source.POISource.prototype.setPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'clonePOIServiceOptions',
    alk.source.POISource.prototype.clonePOIServiceOptions);

goog.exportProperty(
    alk.source.POISource.prototype,
    'processResponse',
    alk.source.POISource.prototype.processResponse);

goog.exportProperty(
    alk.source.POISource.prototype,
    'search',
    alk.source.POISource.prototype.search);

goog.exportSymbol(
    'alk.source.PolygonsCountyCache',
    alk.source.PolygonsCountyCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'getPolygonForCountyCode',
    alk.source.PolygonsCountyCache.prototype.getPolygonForCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'queueCountyCode',
    alk.source.PolygonsCountyCache.prototype.queueCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'processQueue',
    alk.source.PolygonsCountyCache.prototype.processQueue);

goog.exportSymbol(
    'alk.source.RoadSurfaceRoute',
    alk.source.RoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'getRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.getRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'setRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.setRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'cloneRoadSurfaceRouteServiceOptions',
    alk.source.RoadSurfaceRoute.prototype.cloneRoadSurfaceRouteServiceOptions);

goog.exportSymbol(
    'alk.source.RoadSurfaceTileSource',
    alk.source.RoadSurfaceTileSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'getRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.getRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'setRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.setRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'changeRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.changeRoadSurfaceTileService);

goog.exportSymbol(
    'alk.source.Route',
    alk.source.Route,
    ALKMAPS);

goog.exportProperty(
    alk.source.Route.prototype,
    'getRouteService',
    alk.source.Route.prototype.getRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'setRouteService',
    alk.source.Route.prototype.setRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'cloneRouteServiceOptions',
    alk.source.Route.prototype.cloneRouteServiceOptions);

goog.exportSymbol(
    'alk.source.SingleRoadSurfaceRoute',
    alk.source.SingleRoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'setRoute',
    alk.source.SingleRoadSurfaceRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'clear',
    alk.source.SingleRoadSurfaceRoute.prototype.clear);

goog.exportSymbol(
    'alk.source.SingleRoute',
    alk.source.SingleRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'setRoute',
    alk.source.SingleRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRoute',
    alk.source.SingleRoute.prototype.getRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getStopFeatures',
    alk.source.SingleRoute.prototype.getStopFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getLineFeatures',
    alk.source.SingleRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRouteServiceOptions',
    alk.source.SingleRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'removeRoute',
    alk.source.SingleRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.SingleSearch',
    alk.source.SingleSearch,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchSingleSearchService',
    alk.source.SingleSearch.prototype.getSearchSingleSearchService);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'search',
    alk.source.SingleSearch.prototype.search);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'searchResult',
    alk.source.SingleSearch.prototype.searchResult);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchResult',
    alk.source.SingleSearch.prototype.getSearchResult);

goog.exportSymbol(
    'alk.source.SubtractionLoadStrategy',
    alk.source.SubtractionLoadStrategy,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.TrafficCameraMetadataCache',
    alk.source.TrafficCameraMetadataCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'store',
    alk.source.TrafficCameraMetadataCache.prototype.store);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'retrieve',
    alk.source.TrafficCameraMetadataCache.prototype.retrieve);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'get',
    alk.source.TrafficCameraMetadataCache.prototype.get);

goog.exportSymbol(
    'alk.source.TrafficCamerasSource',
    alk.source.TrafficCamerasSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.getTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'setTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.setTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'changeTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.changeTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficCamerasSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCameras',
    alk.source.TrafficCamerasSource.prototype.getTrafficCameras);

goog.exportSymbol(
    'alk.source.TrafficIncidentsSource',
    alk.source.TrafficIncidentsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'setTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.setTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'changeTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.changeTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficIncidentsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidents',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidents);

goog.exportSymbol(
    'alk.source.TrafficSource',
    alk.source.TrafficSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.WeatherAlertsSource',
    alk.source.WeatherAlertsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'setWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.setWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'changeWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.changeWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'removeAllFeatures',
    alk.source.WeatherAlertsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlerts',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlerts);

goog.exportSymbol(
    'alk.source.WeatherSource',
    alk.source.WeatherSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.XYZSource',
    alk.source.XYZSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'setService',
    alk.source.XYZSource.prototype.setService);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'service',
    alk.source.XYZSource.prototype.service);

goog.exportSymbol(
    'alk.style.Arrow',
    alk.style.Arrow,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.ArrowsRouteStyle',
    alk.style.ArrowsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'getArrow',
    alk.style.ArrowsRouteStyle.prototype.getArrow);

goog.exportSymbol(
    'alk.style.DriveTimeLayerStyle',
    alk.style.DriveTimeLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.EditRouteStyle',
    alk.style.EditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.WayPointsEditRouteStyle',
    alk.style.WayPointsEditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.IconPOILayerStyle',
    alk.style.IconPOILayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.LineRouteStyle',
    alk.style.LineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setStrokeStyle',
    alk.style.LineRouteStyle.prototype.setStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.setUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.LineRouteStyle.prototype.getStrokeStyle);

goog.exportSymbol(
    'alk.style.POIIconFactory',
    alk.style.POIIconFactory,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.POILayerStyle',
    alk.style.POILayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'layer',
    alk.style.POILayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setLayer',
    alk.style.POILayerStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setUpdating',
    alk.style.POILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'styleFunction',
    alk.style.POILayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.PolygonWeatherAlertsLayerStyle',
    alk.style.PolygonWeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.QueuedLineRouteStyle',
    alk.style.QueuedLineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'setStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.setStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'clearStrokeForRouteId',
    alk.style.QueuedLineRouteStyle.prototype.clearStrokeForRouteId);

goog.exportSymbol(
    'alk.style.QueuedStyleLayerStyle',
    alk.style.QueuedStyleLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'setStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.setStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'getStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.getStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'clearStyleForId',
    alk.style.QueuedStyleLayerStyle.prototype.clearStyleForId);

goog.exportSymbol(
    'alk.style.RoadSurfaceStyle',
    alk.style.RoadSurfaceStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'layer',
    alk.style.RoadSurfaceStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'setUpdating',
    alk.style.RoadSurfaceStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'styleFunction',
    alk.style.RoadSurfaceStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.RoutingLayerStyle',
    alk.style.RoutingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'layer',
    alk.style.RoutingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'setUpdating',
    alk.style.RoutingLayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'styleFunction',
    alk.style.RoutingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.Shadow',
    alk.style.Shadow,
    ALKMAPS);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getOrigin',
    alk.style.Shadow.prototype.getOrigin);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getRadius',
    alk.style.Shadow.prototype.getRadius);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getHitDetectionImageSize',
    alk.style.Shadow.prototype.getHitDetectionImageSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getAnchor',
    alk.style.Shadow.prototype.getAnchor);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getSize',
    alk.style.Shadow.prototype.getSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getFill',
    alk.style.Shadow.prototype.getFill);

goog.exportSymbol(
    'alk.style.ShadowedCircle',
    alk.style.ShadowedCircle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.SingleSearchStyle',
    alk.style.SingleSearchStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'layer',
    alk.style.SingleSearchStyle.prototype.layer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setLayer',
    alk.style.SingleSearchStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setUpdating',
    alk.style.SingleSearchStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'styleFunction',
    alk.style.SingleSearchStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.StopsRouteStyle',
    alk.style.StopsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.StopsRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.StopsRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.StopsRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultWayPointImage',
    alk.style.StopsRouteStyle.prototype.defaultWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginImage',
    alk.style.StopsRouteStyle.prototype.getOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginStyleFunction',
    alk.style.StopsRouteStyle.prototype.getOriginStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointImage',
    alk.style.StopsRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointImage',
    alk.style.StopsRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getViaPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationImage',
    alk.style.StopsRouteStyle.prototype.getDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationStyleFunction',
    alk.style.StopsRouteStyle.prototype.getDestinationStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getStopStyle',
    alk.style.StopsRouteStyle.prototype.getStopStyle);

goog.exportSymbol(
    'alk.style.StrokeQueue',
    alk.style.StrokeQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'getWidth',
    alk.style.StrokeQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'setWidth',
    alk.style.StrokeQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'strokes',
    alk.style.StrokeQueue.prototype.strokes);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'next',
    alk.style.StrokeQueue.prototype.next);

goog.exportSymbol(
    'alk.style.StyleQueue',
    alk.style.StyleQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'getWidth',
    alk.style.StyleQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'setWidth',
    alk.style.StyleQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'styles',
    alk.style.StyleQueue.prototype.styles);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'next',
    alk.style.StyleQueue.prototype.next);

goog.exportSymbol(
    'alk.style.TrafficCamerasLayerStyle',
    alk.style.TrafficCamerasLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficCamerasLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficCamerasLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.TrafficIncidentsLayerStyle',
    alk.style.TrafficIncidentsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficIncidentsLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficIncidentsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.UpdatingLayerStyle',
    alk.style.UpdatingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'layer',
    alk.style.UpdatingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'styleFunction',
    alk.style.UpdatingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.WeatherAlertsLayerStyle',
    alk.style.WeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.WeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.WeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.val.ArrowsType.None',
    alk.val.ArrowsType.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.Line',
    alk.val.ArrowsType.Line,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.End',
    alk.val.ArrowsType.End,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.All',
    alk.val.Certainty.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Observed',
    alk.val.Certainty.Observed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Likely',
    alk.val.Certainty.Likely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Possible',
    alk.val.Certainty.Possible,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unlikely',
    alk.val.Certainty.Unlikely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unknown',
    alk.val.Certainty.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.Current',
    alk.val.Dataset.Current,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_EU',
    alk.val.Dataset.PCM_EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_OC',
    alk.val.Dataset.PCM_OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SA',
    alk.val.Dataset.PCM_SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_GT',
    alk.val.Dataset.PCM_GT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AF',
    alk.val.Dataset.PCM_AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AS',
    alk.val.Dataset.PCM_AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_ME',
    alk.val.Dataset.PCM_ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SE',
    alk.val.Dataset.PCM_SE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_NA',
    alk.val.Dataset.PCM_NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Radar',
    alk.val.Display.Radar,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Satellite',
    alk.val.Display.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Miles',
    alk.val.DistanceUnits.Miles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Kilometers',
    alk.val.DistanceUnits.Kilometers,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Cities',
    alk.val.DrawerGroup.Cities,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Labels',
    alk.val.DrawerGroup.Labels,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Roads',
    alk.val.DrawerGroup.Roads,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Commercial',
    alk.val.DrawerGroup.Commercial,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Borders',
    alk.val.DrawerGroup.Borders,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Areas',
    alk.val.DrawerGroup.Areas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Format.ImagePNG',
    alk.val.Format.ImagePNG,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Gallons',
    alk.val.FuelUnits.Gallons,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Liters',
    alk.val.FuelUnits.Liters,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.None',
    alk.val.HazMat.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.General',
    alk.val.HazMat.General,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Caustic',
    alk.val.HazMat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Explosives',
    alk.val.HazMat.Explosives,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Flammable',
    alk.val.HazMat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Inhalants',
    alk.val.HazMat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Radioactive',
    alk.val.HazMat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Monday',
    alk.val.HistDay.Monday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Tuesday',
    alk.val.HistDay.Tuesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Wednesday',
    alk.val.HistDay.Wednesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Thursday',
    alk.val.HistDay.Thursday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Friday',
    alk.val.HistDay.Friday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Saturday',
    alk.val.HistDay.Saturday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Sunday',
    alk.val.HistDay.Sunday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed607LH',
    alk.val.HosRuleType.USFed607LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed708LH',
    alk.val.HosRuleType.USFed708LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Background',
    alk.val.ImgOption.Background,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Foreground',
    alk.val.ImgOption.Foreground,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Both',
    alk.val.ImgOption.Both,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Default',
    alk.val.ImgSrc.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.ALKCurated',
    alk.val.ImgSrc.ALKCurated,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat1',
    alk.val.ImgSrc.Sat1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat2',
    alk.val.ImgSrc.Sat2,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat3',
    alk.val.ImgSrc.Sat3,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat4',
    alk.val.ImgSrc.Sat4,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat5',
    alk.val.ImgSrc.Sat5,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat6',
    alk.val.ImgSrc.Sat6,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENUS',
    alk.val.Language.ENUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENGB',
    alk.val.Language.ENGB,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.DE',
    alk.val.Language.DE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.FR',
    alk.val.Language.FR,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ES',
    alk.val.Language.ES,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.IT',
    alk.val.Language.IT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.NationalNetwork',
    alk.val.OverrideClass.NationalNetwork,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.FiftyThreeFoot',
    alk.val.OverrideClass.FiftyThreeFoot,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.All',
    alk.val.POICategory.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.City',
    alk.val.POICategory.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Zip',
    alk.val.POICategory.Zip,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Place',
    alk.val.POICategory.Place,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Airport',
    alk.val.POICategory.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Automotive',
    alk.val.POICategory.Automotive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.WeighStation',
    alk.val.POICategory.WeighStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Dining',
    alk.val.POICategory.Dining,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Education',
    alk.val.POICategory.Education,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Emergency',
    alk.val.POICategory.Emergency,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Government',
    alk.val.POICategory.Government,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Gas',
    alk.val.POICategory.Gas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Lodging',
    alk.val.POICategory.Lodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Parks',
    alk.val.POICategory.Parks,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Retail',
    alk.val.POICategory.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.SportsRec',
    alk.val.POICategory.SportsRec,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Travel',
    alk.val.POICategory.Travel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.TruckServices',
    alk.val.POICategory.TruckServices,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Attractions',
    alk.val.POICategory.Attractions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.Default',
    alk.val.Provider.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.RC1',
    alk.val.Provider.RC1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.NA',
    alk.val.Region.NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.EU',
    alk.val.Region.EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.OC',
    alk.val.Region.OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.SA',
    alk.val.Region.SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AF',
    alk.val.Region.AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AS',
    alk.val.Region.AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.ME',
    alk.val.Region.ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ReportFormat.JSON',
    alk.val.ReportFormat.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.CalcMiles',
    alk.val.Report.CalcMiles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Mileage',
    alk.val.Report.Mileage,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Directions',
    alk.val.Report.Directions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.State',
    alk.val.Report.State,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Detail',
    alk.val.Report.Detail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Road',
    alk.val.Report.Road,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.GeoTunnel',
    alk.val.Report.GeoTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.None',
    alk.val.RouteOptimization.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.ThruAll',
    alk.val.RouteOptimization.ThruAll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.DestinationFixed',
    alk.val.RouteOptimization.DestinationFixed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Practical',
    alk.val.RouteType.Practical,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Shortest',
    alk.val.RouteType.Shortest,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.All',
    alk.val.Severity.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Extreme',
    alk.val.Severity.Extreme,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Severe',
    alk.val.Severity.Severe,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Moderate',
    alk.val.Severity.Moderate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Minor',
    alk.val.Severity.Minor,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Unknown',
    alk.val.Severity.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG900913',
    alk.val.SRS.EPSG900913,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG4326',
    alk.val.SRS.EPSG4326,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG3857',
    alk.val.SRS.EPSG3857,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Origin',
    alk.val.StopType.Origin,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.WayPoint',
    alk.val.StopType.WayPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Destination',
    alk.val.StopType.Destination,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.ViaPoint',
    alk.val.StopType.ViaPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Transportation',
    alk.val.Style.Transportation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataDark',
    alk.val.Style.DataDark,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataLight',
    alk.val.Style.DataLight,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Basic',
    alk.val.Style.Basic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Default',
    alk.val.Style.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Classic',
    alk.val.Style.Classic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Monochrome',
    alk.val.Style.Monochrome,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.RoadAtlas',
    alk.val.Style.RoadAtlas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Night',
    alk.val.Style.Night,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Satellite',
    alk.val.Style.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Lightness',
    alk.val.Style.Lightness,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Smooth',
    alk.val.Style.Smooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Terrain',
    alk.val.Style.Terrain,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Modern',
    alk.val.Style.Modern,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.US',
    alk.val.TollCurrency.US,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.CDN',
    alk.val.TollCurrency.CDN,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.All',
    alk.val.TollPlan.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.C407ETRTransponder',
    alk.val.TollPlan.C407ETRTransponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.A25Transponder',
    alk.val.TollPlan.A25Transponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.BreezeBy',
    alk.val.TollPlan.BreezeBy,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CPass',
    alk.val.TollPlan.CPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CruiseCard',
    alk.val.TollPlan.CruiseCard,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPass',
    alk.val.TollPlan.EPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPassCanada',
    alk.val.TollPlan.EPassCanada,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EXpressToll',
    alk.val.TollPlan.EXpressToll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZTag',
    alk.val.TollPlan.EZTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPass',
    alk.val.TollPlan.EZPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassNJ',
    alk.val.TollPlan.EZPassNJ,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassWV',
    alk.val.TollPlan.EZPassWV,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FastLane',
    alk.val.TollPlan.FastLane,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FasTrak',
    alk.val.TollPlan.FasTrak,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GeauxPass',
    alk.val.TollPlan.GeauxPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GoodToGo',
    alk.val.TollPlan.GoodToGo,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GOPass',
    alk.val.TollPlan.GOPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IPass',
    alk.val.TollPlan.IPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IZoom',
    alk.val.TollPlan.IZoom,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.KTag',
    alk.val.TollPlan.KTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LaredoTradeTag',
    alk.val.TollPlan.LaredoTradeTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LeeWay',
    alk.val.TollPlan.LeeWay,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.MacPass',
    alk.val.TollPlan.MacPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NCQuickPass',
    alk.val.TollPlan.NCQuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NEXPress',
    alk.val.TollPlan.NEXPress,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PalmettoPass',
    alk.val.TollPlan.PalmettoPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PeachPass',
    alk.val.TollPlan.PeachPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PikePass',
    alk.val.TollPlan.PikePass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.QuickPass',
    alk.val.TollPlan.QuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SmartTag',
    alk.val.TollPlan.SmartTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.StraitPass',
    alk.val.TollPlan.StraitPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SunPass',
    alk.val.TollPlan.SunPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TollTag',
    alk.val.TollPlan.TollTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TxTag',
    alk.val.TollPlan.TxTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.WalbashPass',
    alk.val.TollPlan.WalbashPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentyEightDoubleTrailer',
    alk.val.TruckConfig.TwentyEightDoubleTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyStraightTruck',
    alk.val.TruckConfig.FortyStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyEightSemiTrailer',
    alk.val.TruckConfig.FortyEightSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FiftyThreeSemiTrailer',
    alk.val.TruckConfig.FiftyThreeSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FullSizeVan',
    alk.val.TruckConfig.FullSizeVan,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentySixStraightTruck',
    alk.val.TruckConfig.TwentySixStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.All',
    alk.val.Urgency.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Immediate',
    alk.val.Urgency.Immediate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Expected',
    alk.val.Urgency.Expected,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Future',
    alk.val.Urgency.Future,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Past',
    alk.val.Urgency.Past,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Unknown',
    alk.val.Urgency.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.English',
    alk.val.VehicleDimensionUnits.English,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.Metric',
    alk.val.VehicleDimensionUnits.Metric,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Truck',
    alk.val.VehicleType.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.LightTruck',
    alk.val.VehicleType.LightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Auto',
    alk.val.VehicleType.Auto,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.WeatherAlertColor',
    alk.val.WeatherAlertColor,
    ALKMAPS);

goog.exportSymbol(
    'alk.VERSION',
    alk.VERSION,
    ALKMAPS);

goog.exportSymbol(
    'alk.setURL',
    alk.setURL,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'shouldModify',
    alk.interaction.WayPointRouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'processStyle',
    alk.interaction.WayPointRouteModify.prototype.processStyle);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'get',
    alk.service.CountriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'processResponse',
    alk.service.CountriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'get',
    alk.service.DriveTimePolygonService.prototype.get);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'processResponse',
    alk.service.DriveTimePolygonService.prototype.processResponse);

goog.exportProperty(
    alk.service.LocationsReverseService.prototype,
    'get',
    alk.service.LocationsReverseService.prototype.get);

goog.exportProperty(
    alk.service.LocationsService.prototype,
    'get',
    alk.service.LocationsService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'get',
    alk.service.POICategoriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'processResponse',
    alk.service.POICategoriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.POIService.prototype,
    'get',
    alk.service.POIService.prototype.get);

goog.exportProperty(
    alk.service.POIService.prototype,
    'processResponse',
    alk.service.POIService.prototype.processResponse);

goog.exportProperty(
    alk.service.PolygonsCountyService.prototype,
    'get',
    alk.service.PolygonsCountyService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'get',
    alk.service.RoadSurfaceRouteService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'processResponse',
    alk.service.RoadSurfaceRouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.RouteReportsService.prototype,
    'get',
    alk.service.RouteReportsService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'get',
    alk.service.RouteService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'processResponse',
    alk.service.RouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'get',
    alk.service.SearchSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'get',
    alk.service.SearchTypesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchTypesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'get',
    alk.service.StatesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'processResponse',
    alk.service.StatesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficCameraMetadataService.prototype,
    'get',
    alk.service.TrafficCameraMetadataService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'get',
    alk.service.TrafficCamerasService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'processResponse',
    alk.service.TrafficCamerasService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'get',
    alk.service.TrafficIncidentsService.prototype.get);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'processResponse',
    alk.service.TrafficIncidentsService.prototype.processResponse);

goog.exportProperty(
    alk.service.WeatherAlertsService.prototype,
    'get',
    alk.service.WeatherAlertsService.prototype.get);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'setRoute',
    alk.source.EditTrailRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'getRouteServiceOptions',
    alk.source.EditTrailRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdating',
    alk.style.LineRouteStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'styleFunction',
    alk.style.LineRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeStyle);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'styleFunction',
    alk.style.StopsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'styleFunction',
    alk.style.ArrowsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'styleFunction',
    alk.style.QueuedStyleLayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.EditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.EditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.EditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'styleFunction',
    alk.style.EditRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'setUpdating',
    alk.style.IconPOILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'styleFunction',
    alk.style.IconPOILayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.PolygonWeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.PolygonWeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.control.ContextMenu',
    alk.control.ContextMenu,
    ALKMAPS);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'handleRightClicks',
    alk.control.ContextMenu.prototype.handleRightClicks);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'autoActivate',
    alk.control.ContextMenu.prototype.autoActivate);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'ctxMenuItems',
    alk.control.ContextMenu.prototype.ctxMenuItems);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'items',
    alk.control.ContextMenu.prototype.items);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'setMap',
    alk.control.ContextMenu.prototype.setMap);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'render',
    alk.control.ContextMenu.prototype.render);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'positionContainer',
    alk.control.ContextMenu.prototype.positionContainer);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'openMenu',
    alk.control.ContextMenu.prototype.openMenu);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'closeMenu',
    alk.control.ContextMenu.prototype.closeMenu);

goog.exportSymbol(
    'alk.format.FormatType.ARRAY_BUFFER',
    alk.format.FormatType.ARRAY_BUFFER,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.JSON',
    alk.format.FormatType.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.TEXT',
    alk.format.FormatType.TEXT,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.XML',
    alk.format.FormatType.XML,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.HashedIdFactory',
    alk.format.HashedIdFactory,
    ALKMAPS);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'hashCollisionFix',
    alk.format.HashedIdFactory.prototype.hashCollisionFix);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'getIdForString',
    alk.format.HashedIdFactory.prototype.getIdForString);

goog.exportSymbol(
    'alk.format.JSONFeature',
    alk.format.JSONFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.POIJSON',
    alk.format.POIJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficCamerasJSON',
    alk.format.TrafficCamerasJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficIncidentsJSON',
    alk.format.TrafficIncidentsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.WeatherAlertsJSON',
    alk.format.WeatherAlertsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.geocode.Geocoder',
    alk.geocode.Geocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.Geocoder.prototype,
    'geocode',
    alk.geocode.Geocoder.prototype.geocode);

goog.exportSymbol(
    'alk.geocode.ReverseGeocoder',
    alk.geocode.ReverseGeocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.ReverseGeocoder.prototype,
    'reverseGeocode',
    alk.geocode.ReverseGeocoder.prototype.reverseGeocode);

goog.exportSymbol(
    'alk.img.Hazmat.Caustic',
    alk.img.Hazmat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Explosive',
    alk.img.Hazmat.Explosive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Flammable',
    alk.img.Hazmat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Inhalants',
    alk.img.Hazmat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Radioactive',
    alk.img.Hazmat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericEU',
    alk.img.Hazmat.GenericEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericUS',
    alk.img.Hazmat.GenericUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Water',
    alk.img.Hazmat.Water,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AllowRoad',
    alk.img.Misc.AllowRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AvoidRoad',
    alk.img.Misc.AvoidRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Check',
    alk.img.Misc.Check,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagEnd',
    alk.img.Misc.FlagEnd,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStart',
    alk.img.Misc.FlagStart,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStop',
    alk.img.Misc.FlagStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagWaypoint',
    alk.img.Misc.FlagWaypoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Help',
    alk.img.Misc.Help,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadBlue',
    alk.img.Misc.LoadBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGray',
    alk.img.Misc.LoadGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGreen',
    alk.img.Misc.LoadGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadRed',
    alk.img.Misc.LoadRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.No',
    alk.img.Misc.No,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.OilGas',
    alk.img.Misc.OilGas,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinGreen',
    alk.img.Misc.PinGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinRed',
    alk.img.Misc.PinRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Route',
    alk.img.Misc.Route,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckBlue',
    alk.img.Misc.TruckBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGray',
    alk.img.Misc.TruckGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGreen',
    alk.img.Misc.TruckGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckRed',
    alk.img.Misc.TruckRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Address',
    alk.img.POI.Address,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Airport',
    alk.img.POI.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Atm',
    alk.img.POI.Atm,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Attraction',
    alk.img.POI.Attraction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoDealer',
    alk.img.POI.AutoDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRental',
    alk.img.POI.AutoRental,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRepair',
    alk.img.POI.AutoRepair,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Bank',
    alk.img.POI.Bank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Blank',
    alk.img.POI.Blank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BorderCrossing',
    alk.img.POI.BorderCrossing,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BridgeTunnel',
    alk.img.POI.BridgeTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BusStop',
    alk.img.POI.BusStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CatScale',
    alk.img.POI.CatScale,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.City',
    alk.img.POI.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CommuterRail',
    alk.img.POI.CommuterRail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.DieselExhaustFluid',
    alk.img.POI.DieselExhaustFluid,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Entertainment',
    alk.img.POI.Entertainment,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Favorite',
    alk.img.POI.Favorite,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Ferry',
    alk.img.POI.Ferry,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Fuel',
    alk.img.POI.Fuel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GameVenues',
    alk.img.POI.GameVenues,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GenericResult',
    alk.img.POI.GenericResult,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GeographicFeature',
    alk.img.POI.GeographicFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Grocery',
    alk.img.POI.Grocery,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Home',
    alk.img.POI.Home,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Hotel',
    alk.img.POI.Hotel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.IndustrialEstate',
    alk.img.POI.IndustrialEstate,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveLink',
    alk.img.POI.LiveLink,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveSearch',
    alk.img.POI.LiveSearch,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marina',
    alk.img.POI.Marina,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marker',
    alk.img.POI.Marker,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Medical',
    alk.img.POI.Medical,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MotorcycleDealer',
    alk.img.POI.MotorcycleDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Municipal',
    alk.img.POI.Municipal,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MyCar',
    alk.img.POI.MyCar,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherAirport',
    alk.img.POI.OtherAirport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherLodging',
    alk.img.POI.OtherLodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Other',
    alk.img.POI.Other,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Park',
    alk.img.POI.Park,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Parking',
    alk.img.POI.Parking,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PlaceOfWorship',
    alk.img.POI.PlaceOfWorship,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PublicVenue',
    alk.img.POI.PublicVenue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recent',
    alk.img.POI.Recent,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recreation',
    alk.img.POI.Recreation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RestArea',
    alk.img.POI.RestArea,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Restaurant',
    alk.img.POI.Restaurant,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Retail',
    alk.img.POI.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RV',
    alk.img.POI.RV,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.SafetyCamera',
    alk.img.POI.SafetyCamera,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.School',
    alk.img.POI.School,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TandemTrailer',
    alk.img.POI.TandemTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TollBooth',
    alk.img.POI.TollBooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TrainStation',
    alk.img.POI.TrainStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Truck',
    alk.img.POI.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TruckStop',
    alk.img.POI.TruckStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.VehicleChargingStation',
    alk.img.POI.VehicleChargingStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Wikipedia',
    alk.img.POI.Wikipedia,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Work',
    alk.img.POI.Work,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapAccident',
    alk.img.Traffic.MapAccident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapConstruction',
    alk.img.Traffic.MapConstruction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapIncident',
    alk.img.Traffic.MapIncident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapTrafficJam',
    alk.img.Traffic.MapTrafficJam,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapWeather',
    alk.img.Traffic.MapWeather,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity1',
    alk.img.Traffic.Severity1,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity2',
    alk.img.Traffic.Severity2,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity3',
    alk.img.Traffic.Severity3,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightEU',
    alk.img.TruckRestr.HeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightNA',
    alk.img.TruckRestr.HeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthEU',
    alk.img.TruckRestr.LengthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthNA',
    alk.img.TruckRestr.LengthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiEU',
    alk.img.TruckRestr.MultiEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiNA',
    alk.img.TruckRestr.MultiNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckEU',
    alk.img.TruckRestr.NoTruckEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckNA',
    alk.img.TruckRestr.NoTruckNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightEU',
    alk.img.TruckRestr.WeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightNA',
    alk.img.TruckRestr.WeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleEU',
    alk.img.TruckRestr.WeightPerAxleEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleNA',
    alk.img.TruckRestr.WeightPerAxleNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthEU',
    alk.img.TruckRestr.WidthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthNA',
    alk.img.TruckRestr.WidthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.EditTrailRoutingLayerKeyShortCuts',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype,
    'handleMapBrowserEvent',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.handleMapBrowserEvent);

goog.exportSymbol(
    'alk.interaction.RouteModify',
    alk.interaction.RouteModify,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayer',
    alk.interaction.RouteModify.prototype.routingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'setRoutingLayer',
    alk.interaction.RouteModify.prototype.setRoutingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'shouldModify',
    alk.interaction.RouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedStops',
    alk.interaction.RouteModify.prototype.getModifiedStops);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedSegments',
    alk.interaction.RouteModify.prototype.getModifiedSegments);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiableStopTypes',
    alk.interaction.RouteModify.prototype.getModifiableStopTypes);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getCreationStopType',
    alk.interaction.RouteModify.prototype.getCreationStopType);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processEvent',
    alk.interaction.RouteModify.prototype.processEvent);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayerStyle',
    alk.interaction.RouteModify.prototype.routingLayerStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processStyle',
    alk.interaction.RouteModify.prototype.processStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'handleEvent',
    alk.interaction.RouteModify.prototype.handleEvent);

goog.exportSymbol(
    'alk.interaction.SingleSearchPopupInteraction',
    alk.interaction.SingleSearchPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.SingleSearchPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.SingleSearchPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficCameraPopupInteraction',
    alk.interaction.TrafficCameraPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficCameraPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficCameraPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficIncidentPopupInteraction',
    alk.interaction.TrafficIncidentPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficIncidentPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficIncidentPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.ViaPointRouteModify',
    alk.interaction.ViaPointRouteModify,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.WayPointRouteModify',
    alk.interaction.WayPointRouteModify,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'shouldModify',
    alk.interaction.WayPointRouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'processStyle',
    alk.interaction.WayPointRouteModify.prototype.processStyle);

goog.exportSymbol(
    'alk.layer.BaseMapLayer',
    alk.layer.BaseMapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.DriveTimeLayer',
    alk.layer.DriveTimeLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.DriveTimeLayer.prototype,
    'addDriveTimePolygon',
    alk.layer.DriveTimeLayer.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.layer.EditTrailRoutingLayer',
    alk.layer.EditTrailRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'pushRoute',
    alk.layer.EditTrailRoutingLayer.prototype.pushRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'prevRoute',
    alk.layer.EditTrailRoutingLayer.prototype.prevRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'nextRoute',
    alk.layer.EditTrailRoutingLayer.prototype.nextRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'resetEditTrail',
    alk.layer.EditTrailRoutingLayer.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.layer.ImageTileLayer',
    alk.layer.ImageTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MapLayer',
    alk.layer.MapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MultiRoutingLayer',
    alk.layer.MultiRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'addRoute',
    alk.layer.MultiRoutingLayer.prototype.addRoute);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'removeRoute',
    alk.layer.MultiRoutingLayer.prototype.removeRoute);

goog.exportSymbol(
    'alk.layer.POILayer',
    alk.layer.POILayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'getPOILayerStyle',
    alk.layer.POILayer.prototype.getPOILayerStyle);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'setStyle',
    alk.layer.POILayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceRouteLayer',
    alk.layer.RoadSurfaceRouteLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'getRoadSurfaceStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.getRoadSurfaceStyle);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'setStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceTileLayer',
    alk.layer.RoadSurfaceTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.RoutingLayer',
    alk.layer.RoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'getRoutingLayerStyle',
    alk.layer.RoutingLayer.prototype.getRoutingLayerStyle);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'setStyle',
    alk.layer.RoutingLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.SingleRoutingLayer',
    alk.layer.SingleRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'setRoute',
    alk.layer.SingleRoutingLayer.prototype.setRoute);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'getRoute',
    alk.layer.SingleRoutingLayer.prototype.getRoute);

goog.exportSymbol(
    'alk.layer.SingleSearchLayer',
    alk.layer.SingleSearchLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'getSingleSearchStyle',
    alk.layer.SingleSearchLayer.prototype.getSingleSearchStyle);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'setStyle',
    alk.layer.SingleSearchLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficCamerasLayer',
    alk.layer.TrafficCamerasLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'getTrafficCameraLayerStyle',
    alk.layer.TrafficCamerasLayer.prototype.getTrafficCameraLayerStyle);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'setStyle',
    alk.layer.TrafficCamerasLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficIncidentsLayer',
    alk.layer.TrafficIncidentsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'getTrafficIncidentLayerStyle',
    alk.layer.TrafficIncidentsLayer.prototype.getTrafficIncidentLayerStyle);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'setStyle',
    alk.layer.TrafficIncidentsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficLayer',
    alk.layer.TrafficLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherAlertsLayer',
    alk.layer.WeatherAlertsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'getWeatherAlertsLayerStyle',
    alk.layer.WeatherAlertsLayer.prototype.getWeatherAlertsLayerStyle);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'setStyle',
    alk.layer.WeatherAlertsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.WeatherLayer',
    alk.layer.WeatherLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherRadarLayer',
    alk.layer.WeatherRadarLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherSatelliteLayer',
    alk.layer.WeatherSatelliteLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.overlay.ListTooltipOverlay',
    alk.overlay.ListTooltipOverlay,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setAssigned',
    alk.overlay.ListTooltipOverlay.prototype.setAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'getAssigned',
    alk.overlay.ListTooltipOverlay.prototype.getAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'assigned',
    alk.overlay.ListTooltipOverlay.prototype.assigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'addListItem',
    alk.overlay.ListTooltipOverlay.prototype.addListItem);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'clear',
    alk.overlay.ListTooltipOverlay.prototype.clear);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setDisplay',
    alk.overlay.ListTooltipOverlay.prototype.setDisplay);

goog.exportSymbol(
    'alk.overlay.SingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'closeElement',
    alk.overlay.SingleSearchItemPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'setSingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup.prototype.setSingleSearchItemPopup);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'listFormat',
    alk.overlay.SingleSearchItemPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createListHTML',
    alk.overlay.SingleSearchItemPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createContentElement',
    alk.overlay.SingleSearchItemPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createPopupElement',
    alk.overlay.SingleSearchItemPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficCameraPopup',
    alk.overlay.TrafficCameraPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'closeElement',
    alk.overlay.TrafficCameraPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'setTrafficCamera',
    alk.overlay.TrafficCameraPopup.prototype.setTrafficCamera);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'listFormat',
    alk.overlay.TrafficCameraPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficCameraPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficCameraPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficCameraPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficIncidentPopup',
    alk.overlay.TrafficIncidentPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'closeElement',
    alk.overlay.TrafficIncidentPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'setTrafficIncident',
    alk.overlay.TrafficIncidentPopup.prototype.setTrafficIncident);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'listFormat',
    alk.overlay.TrafficIncidentPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficIncidentPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficIncidentPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficIncidentPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.WeatherAlertPopup',
    alk.overlay.WeatherAlertPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'closeElement',
    alk.overlay.WeatherAlertPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'setWeatherAlert',
    alk.overlay.WeatherAlertPopup.prototype.setWeatherAlert);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'listFormat',
    alk.overlay.WeatherAlertPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'itemFormat',
    alk.overlay.WeatherAlertPopup.prototype.itemFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createItemHTML',
    alk.overlay.WeatherAlertPopup.prototype.createItemHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createListHTML',
    alk.overlay.WeatherAlertPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'elements',
    alk.overlay.WeatherAlertPopup.prototype.elements);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createContentElement',
    alk.overlay.WeatherAlertPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createPopupElement',
    alk.overlay.WeatherAlertPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.service.AvoidFavorSetsService',
    alk.service.AvoidFavorSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'get',
    alk.service.AvoidFavorSetsService.prototype.get);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'add',
    alk.service.AvoidFavorSetsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'update',
    alk.service.AvoidFavorSetsService.prototype.update);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'delete',
    alk.service.AvoidFavorSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.AvoidFavorsService',
    alk.service.AvoidFavorsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'add',
    alk.service.AvoidFavorsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'delete',
    alk.service.AvoidFavorsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CountriesSingleSearchService',
    alk.service.CountriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.CustomCategoriesService',
    alk.service.CustomCategoriesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'get',
    alk.service.CustomCategoriesService.prototype.get);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'add',
    alk.service.CustomCategoriesService.prototype.add);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'update',
    alk.service.CustomCategoriesService.prototype.update);

goog.exportSymbol(
    'alk.service.CustomPlaceSetsService',
    alk.service.CustomPlaceSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'get',
    alk.service.CustomPlaceSetsService.prototype.get);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'add',
    alk.service.CustomPlaceSetsService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'update',
    alk.service.CustomPlaceSetsService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'delete',
    alk.service.CustomPlaceSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CustomPlacesService',
    alk.service.CustomPlacesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'add',
    alk.service.CustomPlacesService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'update',
    alk.service.CustomPlacesService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'delete',
    alk.service.CustomPlacesService.prototype.delete);

goog.exportSymbol(
    'alk.service.DriveTimePolygonService',
    alk.service.DriveTimePolygonService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsReverseService',
    alk.service.LocationsReverseService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsService',
    alk.service.LocationsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MapTileService',
    alk.service.MapTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MultipleServiceRequestEngine',
    alk.service.MultipleServiceRequestEngine,
    ALKMAPS);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'queueRequest',
    alk.service.MultipleServiceRequestEngine.prototype.queueRequest);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'processQueue',
    alk.service.MultipleServiceRequestEngine.prototype.processQueue);

goog.exportSymbol(
    'alk.service.POICategoriesSingleSearchService',
    alk.service.POICategoriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.POIService',
    alk.service.POIService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.PolygonsCountyService',
    alk.service.PolygonsCountyService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RestService',
    alk.service.RestService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceRouteService',
    alk.service.RoadSurfaceRouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceTileService',
    alk.service.RoadSurfaceTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoutePathService',
    alk.service.RoutePathService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteReportsService',
    alk.service.RouteReportsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteService',
    alk.service.RouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchSingleSearchService',
    alk.service.SearchSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchTypesSingleSearchService',
    alk.service.SearchTypesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.ServiceBase',
    alk.service.ServiceBase,
    ALKMAPS);

goog.exportProperty(
    alk.service.ServiceBase.prototype,
    'getServiceOptions',
    alk.service.ServiceBase.prototype.getServiceOptions);

goog.exportSymbol(
    'alk.service.Service',
    alk.service.Service,
    ALKMAPS);

goog.exportProperty(
    alk.service.Service.prototype,
    'getURL',
    alk.service.Service.prototype.getURL);

goog.exportProperty(
    alk.service.Service.prototype,
    'get',
    alk.service.Service.prototype.get);

goog.exportProperty(
    alk.service.Service.prototype,
    'processResponse',
    alk.service.Service.prototype.processResponse);

goog.exportProperty(
    alk.service.Service.prototype,
    'getAttribution',
    alk.service.Service.prototype.getAttribution);

goog.exportSymbol(
    'alk.service.StatesSingleSearchService',
    alk.service.StatesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCameraMetadataService',
    alk.service.TrafficCameraMetadataService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCamerasService',
    alk.service.TrafficCamerasService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficIncidentsService',
    alk.service.TrafficIncidentsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficTileService',
    alk.service.TrafficTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherAlertsService',
    alk.service.WeatherAlertsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherImageTileService',
    alk.service.WeatherImageTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgCheck',
    alk.service.setArgCheck,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgPermissive',
    alk.service.setArgPermissive,
    ALKMAPS);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'get',
    alk.service.CountriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'processResponse',
    alk.service.CountriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'get',
    alk.service.DriveTimePolygonService.prototype.get);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'processResponse',
    alk.service.DriveTimePolygonService.prototype.processResponse);

goog.exportProperty(
    alk.service.LocationsReverseService.prototype,
    'get',
    alk.service.LocationsReverseService.prototype.get);

goog.exportProperty(
    alk.service.LocationsService.prototype,
    'get',
    alk.service.LocationsService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'get',
    alk.service.POICategoriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'processResponse',
    alk.service.POICategoriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.POIService.prototype,
    'get',
    alk.service.POIService.prototype.get);

goog.exportProperty(
    alk.service.POIService.prototype,
    'processResponse',
    alk.service.POIService.prototype.processResponse);

goog.exportProperty(
    alk.service.PolygonsCountyService.prototype,
    'get',
    alk.service.PolygonsCountyService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'get',
    alk.service.RoadSurfaceRouteService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'processResponse',
    alk.service.RoadSurfaceRouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.RouteReportsService.prototype,
    'get',
    alk.service.RouteReportsService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'get',
    alk.service.RouteService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'processResponse',
    alk.service.RouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'get',
    alk.service.SearchSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'get',
    alk.service.SearchTypesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchTypesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'get',
    alk.service.StatesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'processResponse',
    alk.service.StatesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficCameraMetadataService.prototype,
    'get',
    alk.service.TrafficCameraMetadataService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'get',
    alk.service.TrafficCamerasService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'processResponse',
    alk.service.TrafficCamerasService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'get',
    alk.service.TrafficIncidentsService.prototype.get);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'processResponse',
    alk.service.TrafficIncidentsService.prototype.processResponse);

goog.exportProperty(
    alk.service.WeatherAlertsService.prototype,
    'get',
    alk.service.WeatherAlertsService.prototype.get);

goog.exportSymbol(
    'alk.source.BaseMapSource',
    alk.source.BaseMapSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.DriveTimePolygon',
    alk.source.DriveTimePolygon,
    ALKMAPS);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'getDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.getDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'setDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.setDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'addDriveTimePolygon',
    alk.source.DriveTimePolygon.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.source.EditTrailRoute',
    alk.source.EditTrailRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'pushRoute',
    alk.source.EditTrailRoute.prototype.pushRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'prevRoute',
    alk.source.EditTrailRoute.prototype.prevRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'nextRoute',
    alk.source.EditTrailRoute.prototype.nextRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'resetEditTrail',
    alk.source.EditTrailRoute.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.source.ImageTileSource',
    alk.source.ImageTileSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.LoadStrategy',
    alk.source.LoadStrategy,
    ALKMAPS);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMinResolution',
    alk.source.LoadStrategy.prototype.getMinResolution);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMaxResolution',
    alk.source.LoadStrategy.prototype.getMaxResolution);

goog.exportSymbol(
    'alk.source.MultiRoute',
    alk.source.MultiRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceResponse',
    alk.source.MultiRoute.prototype.getRouteServiceResponse);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'addRoute',
    alk.source.MultiRoute.prototype.addRoute);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteFeatures',
    alk.source.MultiRoute.prototype.getRouteFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getLineFeatures',
    alk.source.MultiRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteIds',
    alk.source.MultiRoute.prototype.getRouteIds);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceOptions',
    alk.source.MultiRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'removeRoute',
    alk.source.MultiRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.POISource',
    alk.source.POISource,
    ALKMAPS);

goog.exportProperty(
    alk.source.POISource.prototype,
    'getPOIService',
    alk.source.POISource.prototype.getPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'setPOIService',
    alk.source.POISource.prototype.setPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'clonePOIServiceOptions',
    alk.source.POISource.prototype.clonePOIServiceOptions);

goog.exportProperty(
    alk.source.POISource.prototype,
    'processResponse',
    alk.source.POISource.prototype.processResponse);

goog.exportProperty(
    alk.source.POISource.prototype,
    'search',
    alk.source.POISource.prototype.search);

goog.exportSymbol(
    'alk.source.PolygonsCountyCache',
    alk.source.PolygonsCountyCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'getPolygonForCountyCode',
    alk.source.PolygonsCountyCache.prototype.getPolygonForCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'queueCountyCode',
    alk.source.PolygonsCountyCache.prototype.queueCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'processQueue',
    alk.source.PolygonsCountyCache.prototype.processQueue);

goog.exportSymbol(
    'alk.source.RoadSurfaceRoute',
    alk.source.RoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'getRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.getRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'setRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.setRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'cloneRoadSurfaceRouteServiceOptions',
    alk.source.RoadSurfaceRoute.prototype.cloneRoadSurfaceRouteServiceOptions);

goog.exportSymbol(
    'alk.source.RoadSurfaceTileSource',
    alk.source.RoadSurfaceTileSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'getRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.getRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'setRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.setRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'changeRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.changeRoadSurfaceTileService);

goog.exportSymbol(
    'alk.source.Route',
    alk.source.Route,
    ALKMAPS);

goog.exportProperty(
    alk.source.Route.prototype,
    'getRouteService',
    alk.source.Route.prototype.getRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'setRouteService',
    alk.source.Route.prototype.setRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'cloneRouteServiceOptions',
    alk.source.Route.prototype.cloneRouteServiceOptions);

goog.exportSymbol(
    'alk.source.SingleRoadSurfaceRoute',
    alk.source.SingleRoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'setRoute',
    alk.source.SingleRoadSurfaceRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'clear',
    alk.source.SingleRoadSurfaceRoute.prototype.clear);

goog.exportSymbol(
    'alk.source.SingleRoute',
    alk.source.SingleRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'setRoute',
    alk.source.SingleRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRoute',
    alk.source.SingleRoute.prototype.getRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getStopFeatures',
    alk.source.SingleRoute.prototype.getStopFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getLineFeatures',
    alk.source.SingleRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRouteServiceOptions',
    alk.source.SingleRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'removeRoute',
    alk.source.SingleRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.SingleSearch',
    alk.source.SingleSearch,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchSingleSearchService',
    alk.source.SingleSearch.prototype.getSearchSingleSearchService);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'search',
    alk.source.SingleSearch.prototype.search);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'searchResult',
    alk.source.SingleSearch.prototype.searchResult);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchResult',
    alk.source.SingleSearch.prototype.getSearchResult);

goog.exportSymbol(
    'alk.source.SubtractionLoadStrategy',
    alk.source.SubtractionLoadStrategy,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.TrafficCameraMetadataCache',
    alk.source.TrafficCameraMetadataCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'store',
    alk.source.TrafficCameraMetadataCache.prototype.store);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'retrieve',
    alk.source.TrafficCameraMetadataCache.prototype.retrieve);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'get',
    alk.source.TrafficCameraMetadataCache.prototype.get);

goog.exportSymbol(
    'alk.source.TrafficCamerasSource',
    alk.source.TrafficCamerasSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.getTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'setTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.setTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'changeTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.changeTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficCamerasSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCameras',
    alk.source.TrafficCamerasSource.prototype.getTrafficCameras);

goog.exportSymbol(
    'alk.source.TrafficIncidentsSource',
    alk.source.TrafficIncidentsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'setTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.setTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'changeTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.changeTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficIncidentsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidents',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidents);

goog.exportSymbol(
    'alk.source.TrafficSource',
    alk.source.TrafficSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.WeatherAlertsSource',
    alk.source.WeatherAlertsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'setWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.setWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'changeWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.changeWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'removeAllFeatures',
    alk.source.WeatherAlertsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlerts',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlerts);

goog.exportSymbol(
    'alk.source.WeatherSource',
    alk.source.WeatherSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.XYZSource',
    alk.source.XYZSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'setService',
    alk.source.XYZSource.prototype.setService);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'service',
    alk.source.XYZSource.prototype.service);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'setRoute',
    alk.source.EditTrailRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'getRouteServiceOptions',
    alk.source.EditTrailRoute.prototype.getRouteServiceOptions);

goog.exportSymbol(
    'alk.style.Arrow',
    alk.style.Arrow,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.ArrowsRouteStyle',
    alk.style.ArrowsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'getArrow',
    alk.style.ArrowsRouteStyle.prototype.getArrow);

goog.exportSymbol(
    'alk.style.DriveTimeLayerStyle',
    alk.style.DriveTimeLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.EditRouteStyle',
    alk.style.EditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.WayPointsEditRouteStyle',
    alk.style.WayPointsEditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.IconPOILayerStyle',
    alk.style.IconPOILayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.LineRouteStyle',
    alk.style.LineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setStrokeStyle',
    alk.style.LineRouteStyle.prototype.setStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.setUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.LineRouteStyle.prototype.getStrokeStyle);

goog.exportSymbol(
    'alk.style.POIIconFactory',
    alk.style.POIIconFactory,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.POILayerStyle',
    alk.style.POILayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'layer',
    alk.style.POILayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setLayer',
    alk.style.POILayerStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setUpdating',
    alk.style.POILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'styleFunction',
    alk.style.POILayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.PolygonWeatherAlertsLayerStyle',
    alk.style.PolygonWeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.QueuedLineRouteStyle',
    alk.style.QueuedLineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'setStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.setStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'clearStrokeForRouteId',
    alk.style.QueuedLineRouteStyle.prototype.clearStrokeForRouteId);

goog.exportSymbol(
    'alk.style.QueuedStyleLayerStyle',
    alk.style.QueuedStyleLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'setStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.setStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'getStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.getStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'clearStyleForId',
    alk.style.QueuedStyleLayerStyle.prototype.clearStyleForId);

goog.exportSymbol(
    'alk.style.RoadSurfaceStyle',
    alk.style.RoadSurfaceStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'layer',
    alk.style.RoadSurfaceStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'setUpdating',
    alk.style.RoadSurfaceStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'styleFunction',
    alk.style.RoadSurfaceStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.RoutingLayerStyle',
    alk.style.RoutingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'layer',
    alk.style.RoutingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'setUpdating',
    alk.style.RoutingLayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'styleFunction',
    alk.style.RoutingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.Shadow',
    alk.style.Shadow,
    ALKMAPS);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getOrigin',
    alk.style.Shadow.prototype.getOrigin);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getRadius',
    alk.style.Shadow.prototype.getRadius);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getHitDetectionImageSize',
    alk.style.Shadow.prototype.getHitDetectionImageSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getAnchor',
    alk.style.Shadow.prototype.getAnchor);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getSize',
    alk.style.Shadow.prototype.getSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getFill',
    alk.style.Shadow.prototype.getFill);

goog.exportSymbol(
    'alk.style.ShadowedCircle',
    alk.style.ShadowedCircle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.SingleSearchStyle',
    alk.style.SingleSearchStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'layer',
    alk.style.SingleSearchStyle.prototype.layer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setLayer',
    alk.style.SingleSearchStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setUpdating',
    alk.style.SingleSearchStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'styleFunction',
    alk.style.SingleSearchStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.StopsRouteStyle',
    alk.style.StopsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.StopsRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.StopsRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.StopsRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultWayPointImage',
    alk.style.StopsRouteStyle.prototype.defaultWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginImage',
    alk.style.StopsRouteStyle.prototype.getOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginStyleFunction',
    alk.style.StopsRouteStyle.prototype.getOriginStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointImage',
    alk.style.StopsRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointImage',
    alk.style.StopsRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getViaPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationImage',
    alk.style.StopsRouteStyle.prototype.getDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationStyleFunction',
    alk.style.StopsRouteStyle.prototype.getDestinationStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getStopStyle',
    alk.style.StopsRouteStyle.prototype.getStopStyle);

goog.exportSymbol(
    'alk.style.StrokeQueue',
    alk.style.StrokeQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'getWidth',
    alk.style.StrokeQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'setWidth',
    alk.style.StrokeQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'strokes',
    alk.style.StrokeQueue.prototype.strokes);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'next',
    alk.style.StrokeQueue.prototype.next);

goog.exportSymbol(
    'alk.style.StyleQueue',
    alk.style.StyleQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'getWidth',
    alk.style.StyleQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'setWidth',
    alk.style.StyleQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'styles',
    alk.style.StyleQueue.prototype.styles);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'next',
    alk.style.StyleQueue.prototype.next);

goog.exportSymbol(
    'alk.style.TrafficCamerasLayerStyle',
    alk.style.TrafficCamerasLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficCamerasLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficCamerasLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.TrafficIncidentsLayerStyle',
    alk.style.TrafficIncidentsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficIncidentsLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficIncidentsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.UpdatingLayerStyle',
    alk.style.UpdatingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'layer',
    alk.style.UpdatingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'styleFunction',
    alk.style.UpdatingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.WeatherAlertsLayerStyle',
    alk.style.WeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.WeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.WeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdating',
    alk.style.LineRouteStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'styleFunction',
    alk.style.LineRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeStyle);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'styleFunction',
    alk.style.StopsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'styleFunction',
    alk.style.ArrowsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'styleFunction',
    alk.style.QueuedStyleLayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.EditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.EditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.EditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'styleFunction',
    alk.style.EditRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'setUpdating',
    alk.style.IconPOILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'styleFunction',
    alk.style.IconPOILayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.PolygonWeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.PolygonWeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.val.ArrowsType.None',
    alk.val.ArrowsType.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.Line',
    alk.val.ArrowsType.Line,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.End',
    alk.val.ArrowsType.End,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.All',
    alk.val.Certainty.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Observed',
    alk.val.Certainty.Observed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Likely',
    alk.val.Certainty.Likely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Possible',
    alk.val.Certainty.Possible,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unlikely',
    alk.val.Certainty.Unlikely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unknown',
    alk.val.Certainty.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.Current',
    alk.val.Dataset.Current,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_EU',
    alk.val.Dataset.PCM_EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_OC',
    alk.val.Dataset.PCM_OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SA',
    alk.val.Dataset.PCM_SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_GT',
    alk.val.Dataset.PCM_GT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AF',
    alk.val.Dataset.PCM_AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AS',
    alk.val.Dataset.PCM_AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_ME',
    alk.val.Dataset.PCM_ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SE',
    alk.val.Dataset.PCM_SE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_NA',
    alk.val.Dataset.PCM_NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Radar',
    alk.val.Display.Radar,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Satellite',
    alk.val.Display.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Miles',
    alk.val.DistanceUnits.Miles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Kilometers',
    alk.val.DistanceUnits.Kilometers,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Cities',
    alk.val.DrawerGroup.Cities,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Labels',
    alk.val.DrawerGroup.Labels,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Roads',
    alk.val.DrawerGroup.Roads,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Commercial',
    alk.val.DrawerGroup.Commercial,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Borders',
    alk.val.DrawerGroup.Borders,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Areas',
    alk.val.DrawerGroup.Areas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Format.ImagePNG',
    alk.val.Format.ImagePNG,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Gallons',
    alk.val.FuelUnits.Gallons,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Liters',
    alk.val.FuelUnits.Liters,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.None',
    alk.val.HazMat.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.General',
    alk.val.HazMat.General,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Caustic',
    alk.val.HazMat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Explosives',
    alk.val.HazMat.Explosives,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Flammable',
    alk.val.HazMat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Inhalants',
    alk.val.HazMat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Radioactive',
    alk.val.HazMat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Monday',
    alk.val.HistDay.Monday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Tuesday',
    alk.val.HistDay.Tuesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Wednesday',
    alk.val.HistDay.Wednesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Thursday',
    alk.val.HistDay.Thursday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Friday',
    alk.val.HistDay.Friday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Saturday',
    alk.val.HistDay.Saturday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Sunday',
    alk.val.HistDay.Sunday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed607LH',
    alk.val.HosRuleType.USFed607LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed708LH',
    alk.val.HosRuleType.USFed708LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Background',
    alk.val.ImgOption.Background,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Foreground',
    alk.val.ImgOption.Foreground,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Both',
    alk.val.ImgOption.Both,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Default',
    alk.val.ImgSrc.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.ALKCurated',
    alk.val.ImgSrc.ALKCurated,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat1',
    alk.val.ImgSrc.Sat1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat2',
    alk.val.ImgSrc.Sat2,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat3',
    alk.val.ImgSrc.Sat3,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat4',
    alk.val.ImgSrc.Sat4,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat5',
    alk.val.ImgSrc.Sat5,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat6',
    alk.val.ImgSrc.Sat6,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENUS',
    alk.val.Language.ENUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENGB',
    alk.val.Language.ENGB,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.DE',
    alk.val.Language.DE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.FR',
    alk.val.Language.FR,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ES',
    alk.val.Language.ES,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.IT',
    alk.val.Language.IT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.NationalNetwork',
    alk.val.OverrideClass.NationalNetwork,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.FiftyThreeFoot',
    alk.val.OverrideClass.FiftyThreeFoot,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.All',
    alk.val.POICategory.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.City',
    alk.val.POICategory.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Zip',
    alk.val.POICategory.Zip,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Place',
    alk.val.POICategory.Place,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Airport',
    alk.val.POICategory.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Automotive',
    alk.val.POICategory.Automotive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.WeighStation',
    alk.val.POICategory.WeighStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Dining',
    alk.val.POICategory.Dining,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Education',
    alk.val.POICategory.Education,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Emergency',
    alk.val.POICategory.Emergency,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Government',
    alk.val.POICategory.Government,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Gas',
    alk.val.POICategory.Gas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Lodging',
    alk.val.POICategory.Lodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Parks',
    alk.val.POICategory.Parks,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Retail',
    alk.val.POICategory.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.SportsRec',
    alk.val.POICategory.SportsRec,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Travel',
    alk.val.POICategory.Travel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.TruckServices',
    alk.val.POICategory.TruckServices,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Attractions',
    alk.val.POICategory.Attractions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.Default',
    alk.val.Provider.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.RC1',
    alk.val.Provider.RC1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.NA',
    alk.val.Region.NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.EU',
    alk.val.Region.EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.OC',
    alk.val.Region.OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.SA',
    alk.val.Region.SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AF',
    alk.val.Region.AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AS',
    alk.val.Region.AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.ME',
    alk.val.Region.ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ReportFormat.JSON',
    alk.val.ReportFormat.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.CalcMiles',
    alk.val.Report.CalcMiles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Mileage',
    alk.val.Report.Mileage,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Directions',
    alk.val.Report.Directions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.State',
    alk.val.Report.State,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Detail',
    alk.val.Report.Detail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Road',
    alk.val.Report.Road,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.GeoTunnel',
    alk.val.Report.GeoTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.None',
    alk.val.RouteOptimization.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.ThruAll',
    alk.val.RouteOptimization.ThruAll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.DestinationFixed',
    alk.val.RouteOptimization.DestinationFixed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Practical',
    alk.val.RouteType.Practical,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Shortest',
    alk.val.RouteType.Shortest,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.All',
    alk.val.Severity.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Extreme',
    alk.val.Severity.Extreme,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Severe',
    alk.val.Severity.Severe,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Moderate',
    alk.val.Severity.Moderate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Minor',
    alk.val.Severity.Minor,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Unknown',
    alk.val.Severity.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG900913',
    alk.val.SRS.EPSG900913,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG4326',
    alk.val.SRS.EPSG4326,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG3857',
    alk.val.SRS.EPSG3857,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Origin',
    alk.val.StopType.Origin,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.WayPoint',
    alk.val.StopType.WayPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Destination',
    alk.val.StopType.Destination,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.ViaPoint',
    alk.val.StopType.ViaPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Transportation',
    alk.val.Style.Transportation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataDark',
    alk.val.Style.DataDark,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataLight',
    alk.val.Style.DataLight,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Basic',
    alk.val.Style.Basic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Default',
    alk.val.Style.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Classic',
    alk.val.Style.Classic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Monochrome',
    alk.val.Style.Monochrome,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.RoadAtlas',
    alk.val.Style.RoadAtlas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Night',
    alk.val.Style.Night,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Satellite',
    alk.val.Style.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Lightness',
    alk.val.Style.Lightness,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Smooth',
    alk.val.Style.Smooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Terrain',
    alk.val.Style.Terrain,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Modern',
    alk.val.Style.Modern,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.US',
    alk.val.TollCurrency.US,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.CDN',
    alk.val.TollCurrency.CDN,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.All',
    alk.val.TollPlan.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.C407ETRTransponder',
    alk.val.TollPlan.C407ETRTransponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.A25Transponder',
    alk.val.TollPlan.A25Transponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.BreezeBy',
    alk.val.TollPlan.BreezeBy,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CPass',
    alk.val.TollPlan.CPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CruiseCard',
    alk.val.TollPlan.CruiseCard,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPass',
    alk.val.TollPlan.EPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPassCanada',
    alk.val.TollPlan.EPassCanada,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EXpressToll',
    alk.val.TollPlan.EXpressToll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZTag',
    alk.val.TollPlan.EZTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPass',
    alk.val.TollPlan.EZPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassNJ',
    alk.val.TollPlan.EZPassNJ,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassWV',
    alk.val.TollPlan.EZPassWV,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FastLane',
    alk.val.TollPlan.FastLane,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FasTrak',
    alk.val.TollPlan.FasTrak,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GeauxPass',
    alk.val.TollPlan.GeauxPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GoodToGo',
    alk.val.TollPlan.GoodToGo,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GOPass',
    alk.val.TollPlan.GOPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IPass',
    alk.val.TollPlan.IPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IZoom',
    alk.val.TollPlan.IZoom,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.KTag',
    alk.val.TollPlan.KTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LaredoTradeTag',
    alk.val.TollPlan.LaredoTradeTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LeeWay',
    alk.val.TollPlan.LeeWay,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.MacPass',
    alk.val.TollPlan.MacPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NCQuickPass',
    alk.val.TollPlan.NCQuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NEXPress',
    alk.val.TollPlan.NEXPress,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PalmettoPass',
    alk.val.TollPlan.PalmettoPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PeachPass',
    alk.val.TollPlan.PeachPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PikePass',
    alk.val.TollPlan.PikePass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.QuickPass',
    alk.val.TollPlan.QuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SmartTag',
    alk.val.TollPlan.SmartTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.StraitPass',
    alk.val.TollPlan.StraitPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SunPass',
    alk.val.TollPlan.SunPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TollTag',
    alk.val.TollPlan.TollTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TxTag',
    alk.val.TollPlan.TxTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.WalbashPass',
    alk.val.TollPlan.WalbashPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentyEightDoubleTrailer',
    alk.val.TruckConfig.TwentyEightDoubleTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyStraightTruck',
    alk.val.TruckConfig.FortyStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyEightSemiTrailer',
    alk.val.TruckConfig.FortyEightSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FiftyThreeSemiTrailer',
    alk.val.TruckConfig.FiftyThreeSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FullSizeVan',
    alk.val.TruckConfig.FullSizeVan,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentySixStraightTruck',
    alk.val.TruckConfig.TwentySixStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.All',
    alk.val.Urgency.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Immediate',
    alk.val.Urgency.Immediate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Expected',
    alk.val.Urgency.Expected,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Future',
    alk.val.Urgency.Future,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Past',
    alk.val.Urgency.Past,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Unknown',
    alk.val.Urgency.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.English',
    alk.val.VehicleDimensionUnits.English,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.Metric',
    alk.val.VehicleDimensionUnits.Metric,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Truck',
    alk.val.VehicleType.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.LightTruck',
    alk.val.VehicleType.LightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Auto',
    alk.val.VehicleType.Auto,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.WeatherAlertColor',
    alk.val.WeatherAlertColor,
    ALKMAPS);
// Copyright 2009 The Closure Library Authors.
// All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file has been auto-generated by GenJsDeps, please do not edit.

goog.addDependency(
    'demos/editor/equationeditor.js', ['goog.demos.editor.EquationEditor'],
    ['goog.ui.equation.EquationEditorDialog']);
goog.addDependency(
    'demos/editor/helloworld.js', ['goog.demos.editor.HelloWorld'],
    ['goog.dom', 'goog.dom.TagName', 'goog.editor.Plugin']);
goog.addDependency(
    'demos/editor/helloworlddialog.js',
    [
      'goog.demos.editor.HelloWorldDialog',
      'goog.demos.editor.HelloWorldDialog.OkEvent'
    ],
    [
      'goog.dom.TagName', 'goog.events.Event', 'goog.string',
      'goog.ui.editor.AbstractDialog', 'goog.ui.editor.AbstractDialog.Builder',
      'goog.ui.editor.AbstractDialog.EventType'
    ]);
goog.addDependency(
    'demos/editor/helloworlddialogplugin.js',
    [
      'goog.demos.editor.HelloWorldDialogPlugin',
      'goog.demos.editor.HelloWorldDialogPlugin.Command'
    ],
    [
      'goog.demos.editor.HelloWorldDialog', 'goog.dom.TagName',
      'goog.editor.plugins.AbstractDialogPlugin', 'goog.editor.range',
      'goog.functions', 'goog.ui.editor.AbstractDialog.EventType'
    ]);
/**
 * @fileoverview Custom exports file.
 * @suppress {checkVars,extraRequire}
 */

goog.require('alk');
goog.require('alk.ATTRIBUTION');
goog.require('alk.VERSION');
goog.require('alk.color');
goog.require('alk.control.ContextMenu');
goog.require('alk.defaults');
goog.require('alk.format.FormatType');
goog.require('alk.format.HashedIdFactory');
goog.require('alk.format.JSONFeature');
goog.require('alk.format.POIJSON');
goog.require('alk.format.TrafficCamerasJSON');
goog.require('alk.format.TrafficIncidentsJSON');
goog.require('alk.format.WeatherAlertsJSON');
goog.require('alk.geocode.Geocoder');
goog.require('alk.geocode.ReverseGeocoder');
goog.require('alk.img.Hazmat');
goog.require('alk.img.Misc');
goog.require('alk.img.POI');
goog.require('alk.img.Traffic');
goog.require('alk.img.TruckRestr');
goog.require('alk.interaction.EditTrailRoutingLayerKeyShortCuts');
goog.require('alk.interaction.RouteModify');
goog.require('alk.interaction.SingleSearchPopupInteraction');
goog.require('alk.interaction.TrafficCameraPopupInteraction');
goog.require('alk.interaction.TrafficIncidentPopupInteraction');
goog.require('alk.interaction.ViaPointRouteModify');
goog.require('alk.interaction.WayPointRouteModify');
goog.require('alk.layer.BaseMapLayer');
goog.require('alk.layer.DriveTimeLayer');
goog.require('alk.layer.EditTrailRoutingLayer');
goog.require('alk.layer.ImageTileLayer');
goog.require('alk.layer.MapLayer');
goog.require('alk.layer.MultiRoutingLayer');
goog.require('alk.layer.POILayer');
goog.require('alk.layer.RoadSurfaceRouteLayer');
goog.require('alk.layer.RoadSurfaceTileLayer');
goog.require('alk.layer.RoutingLayer');
goog.require('alk.layer.SingleRoutingLayer');
goog.require('alk.layer.SingleSearchLayer');
goog.require('alk.layer.TrafficCamerasLayer');
goog.require('alk.layer.TrafficIncidentsLayer');
goog.require('alk.layer.TrafficLayer');
goog.require('alk.layer.WeatherAlertsLayer');
goog.require('alk.layer.WeatherLayer');
goog.require('alk.layer.WeatherRadarLayer');
goog.require('alk.layer.WeatherSatelliteLayer');
goog.require('alk.overlay.ListTooltipOverlay');
goog.require('alk.overlay.SingleSearchItemPopup');
goog.require('alk.overlay.TrafficCameraPopup');
goog.require('alk.overlay.TrafficIncidentPopup');
goog.require('alk.overlay.WeatherAlertPopup');
goog.require('alk.service');
goog.require('alk.service.AvoidFavorSetsService');
goog.require('alk.service.AvoidFavorsService');
goog.require('alk.service.CountriesSingleSearchService');
goog.require('alk.service.CustomCategoriesService');
goog.require('alk.service.CustomPlaceSetsService');
goog.require('alk.service.CustomPlacesService');
goog.require('alk.service.DriveTimePolygonService');
goog.require('alk.service.LocationsReverseService');
goog.require('alk.service.LocationsService');
goog.require('alk.service.MapTileService');
goog.require('alk.service.MultipleServiceRequestEngine');
goog.require('alk.service.POICategoriesSingleSearchService');
goog.require('alk.service.POIService');
goog.require('alk.service.PolygonsCountyService');
goog.require('alk.service.RestService');
goog.require('alk.service.RoadSurfaceRouteService');
goog.require('alk.service.RoadSurfaceTileService');
goog.require('alk.service.RoutePathService');
goog.require('alk.service.RouteReportsService');
goog.require('alk.service.RouteService');
goog.require('alk.service.SearchSingleSearchService');
goog.require('alk.service.SearchTypesSingleSearchService');
goog.require('alk.service.Service');
goog.require('alk.service.ServiceBase');
goog.require('alk.service.StatesSingleSearchService');
goog.require('alk.service.TrafficCameraMetadataService');
goog.require('alk.service.TrafficCamerasService');
goog.require('alk.service.TrafficIncidentsService');
goog.require('alk.service.TrafficTileService');
goog.require('alk.service.WeatherAlertsService');
goog.require('alk.service.WeatherImageTileService');
goog.require('alk.source.BaseMapSource');
goog.require('alk.source.DriveTimePolygon');
goog.require('alk.source.EditTrailRoute');
goog.require('alk.source.ImageTileSource');
goog.require('alk.source.LoadStrategy');
goog.require('alk.source.MultiRoute');
goog.require('alk.source.POISource');
goog.require('alk.source.PolygonsCountyCache');
goog.require('alk.source.RoadSurfaceRoute');
goog.require('alk.source.RoadSurfaceTileSource');
goog.require('alk.source.Route');
goog.require('alk.source.SingleRoadSurfaceRoute');
goog.require('alk.source.SingleRoute');
goog.require('alk.source.SingleSearch');
goog.require('alk.source.SubtractionLoadStrategy');
goog.require('alk.source.TrafficCameraMetadataCache');
goog.require('alk.source.TrafficCamerasSource');
goog.require('alk.source.TrafficIncidentsSource');
goog.require('alk.source.TrafficSource');
goog.require('alk.source.WeatherAlertsSource');
goog.require('alk.source.WeatherSource');
goog.require('alk.source.XYZSource');
goog.require('alk.style.Arrow');
goog.require('alk.style.ArrowsRouteStyle');
goog.require('alk.style.DriveTimeLayerStyle');
goog.require('alk.style.EditRouteStyle');
goog.require('alk.style.IconPOILayerStyle');
goog.require('alk.style.LineRouteStyle');
goog.require('alk.style.POIIconFactory');
goog.require('alk.style.POILayerStyle');
goog.require('alk.style.PolygonWeatherAlertsLayerStyle');
goog.require('alk.style.QueuedLineRouteStyle');
goog.require('alk.style.QueuedStyleLayerStyle');
goog.require('alk.style.RoadSurfaceStyle');
goog.require('alk.style.RoutingLayerStyle');
goog.require('alk.style.Shadow');
goog.require('alk.style.ShadowedCircle');
goog.require('alk.style.SingleSearchStyle');
goog.require('alk.style.StopsRouteStyle');
goog.require('alk.style.StrokeQueue');
goog.require('alk.style.StyleQueue');
goog.require('alk.style.TrafficCamerasLayerStyle');
goog.require('alk.style.TrafficIncidentsLayerStyle');
goog.require('alk.style.UpdatingLayerStyle');
goog.require('alk.style.WayPointsEditRouteStyle');
goog.require('alk.style.WeatherAlertsLayerStyle');
goog.require('alk.val.ArrowsType');
goog.require('alk.val.Certainty');
goog.require('alk.val.Dataset');
goog.require('alk.val.Display');
goog.require('alk.val.DistanceUnits');
goog.require('alk.val.DrawerGroup');
goog.require('alk.val.Format');
goog.require('alk.val.FuelUnits');
goog.require('alk.val.HazMat');
goog.require('alk.val.HistDay');
goog.require('alk.val.HosRuleType');
goog.require('alk.val.ImgOption');
goog.require('alk.val.ImgSrc');
goog.require('alk.val.Language');
goog.require('alk.val.OverrideClass');
goog.require('alk.val.POICategory');
goog.require('alk.val.Provider');
goog.require('alk.val.Region');
goog.require('alk.val.Report');
goog.require('alk.val.ReportFormat');
goog.require('alk.val.RouteOptimization');
goog.require('alk.val.RouteType');
goog.require('alk.val.SRS');
goog.require('alk.val.Severity');
goog.require('alk.val.StopType');
goog.require('alk.val.Style');
goog.require('alk.val.TollCurrency');
goog.require('alk.val.TollPlan');
goog.require('alk.val.TruckConfig');
goog.require('alk.val.Urgency');
goog.require('alk.val.VehicleDimensionUnits');
goog.require('alk.val.VehicleType');
goog.require('alk.val.WeatherAlertColor');
goog.require('alkx.AvoidFavorSetsServiceAddOptions');
goog.require('alkx.AvoidFavorSetsServiceDeleteOptions');
goog.require('alkx.AvoidFavorSetsServiceGetOptions');
goog.require('alkx.AvoidFavorSetsServiceUpdateOptions');
goog.require('alkx.AvoidFavorsServiceAddOptions');
goog.require('alkx.AvoidFavorsServiceDeleteOptions');
goog.require('alkx.BaseMapLayerOptions');
goog.require('alkx.BaseMapSourceOptions');
goog.require('alkx.ContextMenuOptions');
goog.require('alkx.CustomCategoriesServiceAddOptions');
goog.require('alkx.CustomCategoriesServiceDeleteOptions');
goog.require('alkx.CustomCategoriesServiceGetOptions');
goog.require('alkx.CustomCategoriesServiceUpdateOptions');
goog.require('alkx.CustomPlaceSetsServiceAddOptions');
goog.require('alkx.CustomPlaceSetsServiceDeleteOptions');
goog.require('alkx.CustomPlaceSetsServiceGetOptions');
goog.require('alkx.CustomPlaceSetsServiceUpdateOptions');
goog.require('alkx.CustomPlacesAddress');
goog.require('alkx.CustomPlacesCoords');
goog.require('alkx.CustomPlacesPlace');
goog.require('alkx.CustomPlacesServiceAddOptions');
goog.require('alkx.CustomPlacesServiceDeleteOptions');
goog.require('alkx.CustomPlacesServiceUpdateOptions');
goog.require('alkx.CustomPlacesSet');
goog.require('alkx.DefaultOptions');
goog.require('alkx.DriveTimeLayerOptions');
goog.require('alkx.DriveTimeLayerStyleOptions');
goog.require('alkx.DriveTimePolygonServiceResponse');
goog.require('alkx.DriveTimePolygonSourceOptions');
goog.require('alkx.EditTrailRoutingLayerKeyShortCutsOptions');
goog.require('alkx.GeocodeAddress');
goog.require('alkx.GeocoderGeocodeOptions');
goog.require('alkx.GeocoderOptions');
goog.require('alkx.HashedIdFactoryOptions');
goog.require('alkx.LayerOptions');
goog.require('alkx.ListTooltipOverlayOptions');
goog.require('alkx.LoadStrategyOptions');
goog.require('alkx.LocationsReverseServiceResponse');
goog.require('alkx.MapLayerOptions');
goog.require('alkx.MultiRoutingLayerAddRouteOptions');
goog.require('alkx.MultipleServiceRequestEngineOptions');
goog.require('alkx.NormalizedAddress');
goog.require('alkx.POILayerOptions');
goog.require('alkx.POISourceOptions');
goog.require('alkx.PolygonsCountyCacheOptions');
goog.require('alkx.ReverseGeocoderOptions');
goog.require('alkx.ReverseGeocoderReverseGeocodeOptions');
goog.require('alkx.RoadSurfaceLayerOptions');
goog.require('alkx.RoadSurfaceRouteLayerOptions');
goog.require('alkx.RoadSurfaceRouteServiceResponse');
goog.require('alkx.RoadSurfaceRouteSourceOptions');
goog.require('alkx.RoadSurfaceTileSourceOptions');
goog.require('alkx.RouteServiceResponse');
goog.require('alkx.RouteSourceOptions');
goog.require('alkx.RoutingLayerOptions');
goog.require('alkx.SearchTypesSingleSearchServiceResponse');
goog.require('alkx.SearchTypesSingleSearchServiceResult');
goog.require('alkx.ServiceOptions');
goog.require('alkx.SingleSearchItemPopupOptions');
goog.require('alkx.SingleSearchLayerOptions');
goog.require('alkx.SingleSearchSourceOptions');
goog.require('alkx.SourceOptions');
goog.require('alkx.SubtractionLoadStrategyOptions');
goog.require('alkx.TileLayerOptions');
goog.require('alkx.TrafficCameraMetadataCacheOptions');
goog.require('alkx.TrafficCameraPopupInteractionOptions');
goog.require('alkx.TrafficCameraPopupOptions');
goog.require('alkx.TrafficCamerasLayerOptions');
goog.require('alkx.TrafficCamerasSourceOptions');
goog.require('alkx.TrafficIncidentPopupOptions');
goog.require('alkx.TrafficIncidentsLayerOptions');
goog.require('alkx.TrafficIncidentsSourceOptions');
goog.require('alkx.TrafficLayerOptions');
goog.require('alkx.TrafficServiceOptions');
goog.require('alkx.TrafficSourceOptions');
goog.require('alkx.WeatherAlertPopupOptions');
goog.require('alkx.WeatherAlertsLayerOptions');
goog.require('alkx.WeatherAlertsSourceOptions');
goog.require('alkx.WeatherLayerOptions');
goog.require('alkx.WeatherSourceOptions');
goog.require('alkx.XYZSourceOptions');
goog.require('alkx.format.POIJSONOptions');
goog.require('alkx.format.TrafficCamerasJSONOptions');
goog.require('alkx.format.TrafficIncidentsJSONOptions');
goog.require('alkx.format.WeatherAlertsJSONOptions');
goog.require('alkx.interaction.RouteModifyOptions');
goog.require('alkx.style.ArrowOptions');
goog.require('pcmws.api.ContentServiceURL');
goog.require('pcmws.api.CountriesSingleSearchURL');
goog.require('pcmws.api.CustomCategoriesRestServiceURL');
goog.require('pcmws.api.CustomPlaceSetsRestServiceURL');
goog.require('pcmws.api.CustomPlacesRestServiceURL');
goog.require('pcmws.api.DriveTimePolygonURL');
goog.require('pcmws.api.LocationsReverseURL');
goog.require('pcmws.api.LocationsURL');
goog.require('pcmws.api.MapTileURL');
goog.require('pcmws.api.MapURL');
goog.require('pcmws.api.PCMServiceURL');
goog.require('pcmws.api.POICategoriesSingleSearchURL');
goog.require('pcmws.api.POIURL');
goog.require('pcmws.api.PolygonsCountyURL');
goog.require('pcmws.api.RestServiceURL');
goog.require('pcmws.api.RoadSurfaceRouteURL');
goog.require('pcmws.api.RouteReportsURL');
goog.require('pcmws.api.RouteURL');
goog.require('pcmws.api.SearchSingleSearchURL');
goog.require('pcmws.api.SearchTypesSingleSearchURL');
goog.require('pcmws.api.StatesSingleSearchURL');
goog.require('pcmws.api.StaticService');
goog.require('pcmws.api.StaticServiceURL');
goog.require('pcmws.api.TrafficCameraImageURL');
goog.require('pcmws.api.TrafficCameraMetadataURL');
goog.require('pcmws.api.TrafficCamerasURL');
goog.require('pcmws.api.TrafficIncidentsURL');
goog.require('pcmws.api.TrafficURL');
goog.require('pcmws.api.TypeSingleSearchURL');
goog.require('pcmws.api.WeatherAlertsURL');
goog.require('pcmws.api.WeatherURL');



goog.exportSymbol(
    'alk.ATTRIBUTION',
    alk.ATTRIBUTION,
    ALKMAPS);

goog.exportSymbol(
    'alk.color.shadeColor',
    alk.color.shadeColor,
    ALKMAPS);

goog.exportSymbol(
    'alk.control.ContextMenu',
    alk.control.ContextMenu,
    ALKMAPS);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'handleRightClicks',
    alk.control.ContextMenu.prototype.handleRightClicks);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'autoActivate',
    alk.control.ContextMenu.prototype.autoActivate);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'ctxMenuItems',
    alk.control.ContextMenu.prototype.ctxMenuItems);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'items',
    alk.control.ContextMenu.prototype.items);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'setMap',
    alk.control.ContextMenu.prototype.setMap);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'render',
    alk.control.ContextMenu.prototype.render);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'positionContainer',
    alk.control.ContextMenu.prototype.positionContainer);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'openMenu',
    alk.control.ContextMenu.prototype.openMenu);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'closeMenu',
    alk.control.ContextMenu.prototype.closeMenu);

goog.exportSymbol(
    'alk.defaults.setApiKey',
    alk.defaults.setApiKey,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setProductionDefaults',
    alk.defaults.setProductionDefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setDevelopmentDefaults',
    alk.defaults.setDevelopmentDefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setQADefaults',
    alk.defaults.setQADefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.setHermeticDefaults',
    alk.defaults.setHermeticDefaults,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getMapTileUrl',
    alk.defaults.getMapTileUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getPCMServiceUrl',
    alk.defaults.getPCMServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getStaticServiceUrl',
    alk.defaults.getStaticServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getNewMapTileUrl',
    alk.defaults.getNewMapTileUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getNewPCMServiceUrl',
    alk.defaults.getNewPCMServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.defaults.getNewStaticServiceUrl',
    alk.defaults.getNewStaticServiceUrl,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.ARRAY_BUFFER',
    alk.format.FormatType.ARRAY_BUFFER,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.JSON',
    alk.format.FormatType.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.TEXT',
    alk.format.FormatType.TEXT,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.XML',
    alk.format.FormatType.XML,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.HashedIdFactory',
    alk.format.HashedIdFactory,
    ALKMAPS);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'hashCollisionFix',
    alk.format.HashedIdFactory.prototype.hashCollisionFix);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'getIdForString',
    alk.format.HashedIdFactory.prototype.getIdForString);

goog.exportSymbol(
    'alk.format.JSONFeature',
    alk.format.JSONFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.POIJSON',
    alk.format.POIJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficCamerasJSON',
    alk.format.TrafficCamerasJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficIncidentsJSON',
    alk.format.TrafficIncidentsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.WeatherAlertsJSON',
    alk.format.WeatherAlertsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.geocode.Geocoder',
    alk.geocode.Geocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.Geocoder.prototype,
    'geocode',
    alk.geocode.Geocoder.prototype.geocode);

goog.exportSymbol(
    'alk.geocode.ReverseGeocoder',
    alk.geocode.ReverseGeocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.ReverseGeocoder.prototype,
    'reverseGeocode',
    alk.geocode.ReverseGeocoder.prototype.reverseGeocode);

goog.exportSymbol(
    'alk.img.Hazmat.Caustic',
    alk.img.Hazmat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Explosive',
    alk.img.Hazmat.Explosive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Flammable',
    alk.img.Hazmat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Inhalants',
    alk.img.Hazmat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Radioactive',
    alk.img.Hazmat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericEU',
    alk.img.Hazmat.GenericEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericUS',
    alk.img.Hazmat.GenericUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Water',
    alk.img.Hazmat.Water,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AllowRoad',
    alk.img.Misc.AllowRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AvoidRoad',
    alk.img.Misc.AvoidRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Check',
    alk.img.Misc.Check,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagEnd',
    alk.img.Misc.FlagEnd,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStart',
    alk.img.Misc.FlagStart,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStop',
    alk.img.Misc.FlagStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagWaypoint',
    alk.img.Misc.FlagWaypoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Help',
    alk.img.Misc.Help,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadBlue',
    alk.img.Misc.LoadBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGray',
    alk.img.Misc.LoadGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGreen',
    alk.img.Misc.LoadGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadRed',
    alk.img.Misc.LoadRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.No',
    alk.img.Misc.No,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.OilGas',
    alk.img.Misc.OilGas,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinGreen',
    alk.img.Misc.PinGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinRed',
    alk.img.Misc.PinRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Route',
    alk.img.Misc.Route,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckBlue',
    alk.img.Misc.TruckBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGray',
    alk.img.Misc.TruckGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGreen',
    alk.img.Misc.TruckGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckRed',
    alk.img.Misc.TruckRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Address',
    alk.img.POI.Address,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Airport',
    alk.img.POI.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Atm',
    alk.img.POI.Atm,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Attraction',
    alk.img.POI.Attraction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoDealer',
    alk.img.POI.AutoDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRental',
    alk.img.POI.AutoRental,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRepair',
    alk.img.POI.AutoRepair,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Bank',
    alk.img.POI.Bank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Blank',
    alk.img.POI.Blank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BorderCrossing',
    alk.img.POI.BorderCrossing,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BridgeTunnel',
    alk.img.POI.BridgeTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BusStop',
    alk.img.POI.BusStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CatScale',
    alk.img.POI.CatScale,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.City',
    alk.img.POI.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CommuterRail',
    alk.img.POI.CommuterRail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.DieselExhaustFluid',
    alk.img.POI.DieselExhaustFluid,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Entertainment',
    alk.img.POI.Entertainment,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Favorite',
    alk.img.POI.Favorite,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Ferry',
    alk.img.POI.Ferry,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Fuel',
    alk.img.POI.Fuel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GameVenues',
    alk.img.POI.GameVenues,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GenericResult',
    alk.img.POI.GenericResult,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GeographicFeature',
    alk.img.POI.GeographicFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Grocery',
    alk.img.POI.Grocery,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Home',
    alk.img.POI.Home,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Hotel',
    alk.img.POI.Hotel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.IndustrialEstate',
    alk.img.POI.IndustrialEstate,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveLink',
    alk.img.POI.LiveLink,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveSearch',
    alk.img.POI.LiveSearch,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marina',
    alk.img.POI.Marina,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marker',
    alk.img.POI.Marker,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Medical',
    alk.img.POI.Medical,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MotorcycleDealer',
    alk.img.POI.MotorcycleDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Municipal',
    alk.img.POI.Municipal,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MyCar',
    alk.img.POI.MyCar,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherAirport',
    alk.img.POI.OtherAirport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherLodging',
    alk.img.POI.OtherLodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Other',
    alk.img.POI.Other,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Park',
    alk.img.POI.Park,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Parking',
    alk.img.POI.Parking,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PlaceOfWorship',
    alk.img.POI.PlaceOfWorship,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PublicVenue',
    alk.img.POI.PublicVenue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recent',
    alk.img.POI.Recent,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recreation',
    alk.img.POI.Recreation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RestArea',
    alk.img.POI.RestArea,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Restaurant',
    alk.img.POI.Restaurant,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Retail',
    alk.img.POI.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RV',
    alk.img.POI.RV,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.SafetyCamera',
    alk.img.POI.SafetyCamera,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.School',
    alk.img.POI.School,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TandemTrailer',
    alk.img.POI.TandemTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TollBooth',
    alk.img.POI.TollBooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TrainStation',
    alk.img.POI.TrainStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Truck',
    alk.img.POI.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TruckStop',
    alk.img.POI.TruckStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.VehicleChargingStation',
    alk.img.POI.VehicleChargingStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Wikipedia',
    alk.img.POI.Wikipedia,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Work',
    alk.img.POI.Work,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapAccident',
    alk.img.Traffic.MapAccident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapConstruction',
    alk.img.Traffic.MapConstruction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapIncident',
    alk.img.Traffic.MapIncident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapTrafficJam',
    alk.img.Traffic.MapTrafficJam,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapWeather',
    alk.img.Traffic.MapWeather,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity1',
    alk.img.Traffic.Severity1,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity2',
    alk.img.Traffic.Severity2,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity3',
    alk.img.Traffic.Severity3,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightEU',
    alk.img.TruckRestr.HeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightNA',
    alk.img.TruckRestr.HeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthEU',
    alk.img.TruckRestr.LengthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthNA',
    alk.img.TruckRestr.LengthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiEU',
    alk.img.TruckRestr.MultiEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiNA',
    alk.img.TruckRestr.MultiNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckEU',
    alk.img.TruckRestr.NoTruckEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckNA',
    alk.img.TruckRestr.NoTruckNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightEU',
    alk.img.TruckRestr.WeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightNA',
    alk.img.TruckRestr.WeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleEU',
    alk.img.TruckRestr.WeightPerAxleEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleNA',
    alk.img.TruckRestr.WeightPerAxleNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthEU',
    alk.img.TruckRestr.WidthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthNA',
    alk.img.TruckRestr.WidthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.EditTrailRoutingLayerKeyShortCuts',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype,
    'handleMapBrowserEvent',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.handleMapBrowserEvent);

goog.exportSymbol(
    'alk.interaction.RouteModify',
    alk.interaction.RouteModify,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayer',
    alk.interaction.RouteModify.prototype.routingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'setRoutingLayer',
    alk.interaction.RouteModify.prototype.setRoutingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'shouldModify',
    alk.interaction.RouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedStops',
    alk.interaction.RouteModify.prototype.getModifiedStops);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedSegments',
    alk.interaction.RouteModify.prototype.getModifiedSegments);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiableStopTypes',
    alk.interaction.RouteModify.prototype.getModifiableStopTypes);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getCreationStopType',
    alk.interaction.RouteModify.prototype.getCreationStopType);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processEvent',
    alk.interaction.RouteModify.prototype.processEvent);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayerStyle',
    alk.interaction.RouteModify.prototype.routingLayerStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processStyle',
    alk.interaction.RouteModify.prototype.processStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'handleEvent',
    alk.interaction.RouteModify.prototype.handleEvent);

goog.exportSymbol(
    'alk.interaction.SingleSearchPopupInteraction',
    alk.interaction.SingleSearchPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.SingleSearchPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.SingleSearchPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficCameraPopupInteraction',
    alk.interaction.TrafficCameraPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficCameraPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficCameraPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficIncidentPopupInteraction',
    alk.interaction.TrafficIncidentPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficIncidentPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficIncidentPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.ViaPointRouteModify',
    alk.interaction.ViaPointRouteModify,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.WayPointRouteModify',
    alk.interaction.WayPointRouteModify,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.BaseMapLayer',
    alk.layer.BaseMapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.DriveTimeLayer',
    alk.layer.DriveTimeLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.DriveTimeLayer.prototype,
    'addDriveTimePolygon',
    alk.layer.DriveTimeLayer.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.layer.EditTrailRoutingLayer',
    alk.layer.EditTrailRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'pushRoute',
    alk.layer.EditTrailRoutingLayer.prototype.pushRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'prevRoute',
    alk.layer.EditTrailRoutingLayer.prototype.prevRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'nextRoute',
    alk.layer.EditTrailRoutingLayer.prototype.nextRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'resetEditTrail',
    alk.layer.EditTrailRoutingLayer.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.layer.ImageTileLayer',
    alk.layer.ImageTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MapLayer',
    alk.layer.MapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MultiRoutingLayer',
    alk.layer.MultiRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'addRoute',
    alk.layer.MultiRoutingLayer.prototype.addRoute);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'removeRoute',
    alk.layer.MultiRoutingLayer.prototype.removeRoute);

goog.exportSymbol(
    'alk.layer.POILayer',
    alk.layer.POILayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'getPOILayerStyle',
    alk.layer.POILayer.prototype.getPOILayerStyle);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'setStyle',
    alk.layer.POILayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceRouteLayer',
    alk.layer.RoadSurfaceRouteLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'getRoadSurfaceStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.getRoadSurfaceStyle);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'setStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceTileLayer',
    alk.layer.RoadSurfaceTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.RoutingLayer',
    alk.layer.RoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'getRoutingLayerStyle',
    alk.layer.RoutingLayer.prototype.getRoutingLayerStyle);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'setStyle',
    alk.layer.RoutingLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.SingleRoutingLayer',
    alk.layer.SingleRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'setRoute',
    alk.layer.SingleRoutingLayer.prototype.setRoute);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'getRoute',
    alk.layer.SingleRoutingLayer.prototype.getRoute);

goog.exportSymbol(
    'alk.layer.SingleSearchLayer',
    alk.layer.SingleSearchLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'getSingleSearchStyle',
    alk.layer.SingleSearchLayer.prototype.getSingleSearchStyle);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'setStyle',
    alk.layer.SingleSearchLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficCamerasLayer',
    alk.layer.TrafficCamerasLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'getTrafficCameraLayerStyle',
    alk.layer.TrafficCamerasLayer.prototype.getTrafficCameraLayerStyle);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'setStyle',
    alk.layer.TrafficCamerasLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficIncidentsLayer',
    alk.layer.TrafficIncidentsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'getTrafficIncidentLayerStyle',
    alk.layer.TrafficIncidentsLayer.prototype.getTrafficIncidentLayerStyle);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'setStyle',
    alk.layer.TrafficIncidentsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficLayer',
    alk.layer.TrafficLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherAlertsLayer',
    alk.layer.WeatherAlertsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'getWeatherAlertsLayerStyle',
    alk.layer.WeatherAlertsLayer.prototype.getWeatherAlertsLayerStyle);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'setStyle',
    alk.layer.WeatherAlertsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.WeatherLayer',
    alk.layer.WeatherLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherRadarLayer',
    alk.layer.WeatherRadarLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherSatelliteLayer',
    alk.layer.WeatherSatelliteLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.overlay.ListTooltipOverlay',
    alk.overlay.ListTooltipOverlay,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setAssigned',
    alk.overlay.ListTooltipOverlay.prototype.setAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'getAssigned',
    alk.overlay.ListTooltipOverlay.prototype.getAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'assigned',
    alk.overlay.ListTooltipOverlay.prototype.assigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'addListItem',
    alk.overlay.ListTooltipOverlay.prototype.addListItem);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'clear',
    alk.overlay.ListTooltipOverlay.prototype.clear);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setDisplay',
    alk.overlay.ListTooltipOverlay.prototype.setDisplay);

goog.exportSymbol(
    'alk.overlay.SingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'closeElement',
    alk.overlay.SingleSearchItemPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'setSingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup.prototype.setSingleSearchItemPopup);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'listFormat',
    alk.overlay.SingleSearchItemPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createListHTML',
    alk.overlay.SingleSearchItemPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createContentElement',
    alk.overlay.SingleSearchItemPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createPopupElement',
    alk.overlay.SingleSearchItemPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficCameraPopup',
    alk.overlay.TrafficCameraPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'closeElement',
    alk.overlay.TrafficCameraPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'setTrafficCamera',
    alk.overlay.TrafficCameraPopup.prototype.setTrafficCamera);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'listFormat',
    alk.overlay.TrafficCameraPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficCameraPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficCameraPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficCameraPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficIncidentPopup',
    alk.overlay.TrafficIncidentPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'closeElement',
    alk.overlay.TrafficIncidentPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'setTrafficIncident',
    alk.overlay.TrafficIncidentPopup.prototype.setTrafficIncident);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'listFormat',
    alk.overlay.TrafficIncidentPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficIncidentPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficIncidentPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficIncidentPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.WeatherAlertPopup',
    alk.overlay.WeatherAlertPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'closeElement',
    alk.overlay.WeatherAlertPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'setWeatherAlert',
    alk.overlay.WeatherAlertPopup.prototype.setWeatherAlert);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'listFormat',
    alk.overlay.WeatherAlertPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'itemFormat',
    alk.overlay.WeatherAlertPopup.prototype.itemFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createItemHTML',
    alk.overlay.WeatherAlertPopup.prototype.createItemHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createListHTML',
    alk.overlay.WeatherAlertPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'elements',
    alk.overlay.WeatherAlertPopup.prototype.elements);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createContentElement',
    alk.overlay.WeatherAlertPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createPopupElement',
    alk.overlay.WeatherAlertPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.service.AvoidFavorSetsService',
    alk.service.AvoidFavorSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'get',
    alk.service.AvoidFavorSetsService.prototype.get);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'add',
    alk.service.AvoidFavorSetsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'update',
    alk.service.AvoidFavorSetsService.prototype.update);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'delete',
    alk.service.AvoidFavorSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.AvoidFavorsService',
    alk.service.AvoidFavorsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'add',
    alk.service.AvoidFavorsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'delete',
    alk.service.AvoidFavorsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CountriesSingleSearchService',
    alk.service.CountriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.CustomCategoriesService',
    alk.service.CustomCategoriesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'get',
    alk.service.CustomCategoriesService.prototype.get);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'add',
    alk.service.CustomCategoriesService.prototype.add);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'update',
    alk.service.CustomCategoriesService.prototype.update);

goog.exportSymbol(
    'alk.service.CustomPlaceSetsService',
    alk.service.CustomPlaceSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'get',
    alk.service.CustomPlaceSetsService.prototype.get);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'add',
    alk.service.CustomPlaceSetsService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'update',
    alk.service.CustomPlaceSetsService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'delete',
    alk.service.CustomPlaceSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CustomPlacesService',
    alk.service.CustomPlacesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'add',
    alk.service.CustomPlacesService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'update',
    alk.service.CustomPlacesService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'delete',
    alk.service.CustomPlacesService.prototype.delete);

goog.exportSymbol(
    'alk.service.DriveTimePolygonService',
    alk.service.DriveTimePolygonService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsReverseService',
    alk.service.LocationsReverseService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsService',
    alk.service.LocationsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MapTileService',
    alk.service.MapTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MultipleServiceRequestEngine',
    alk.service.MultipleServiceRequestEngine,
    ALKMAPS);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'queueRequest',
    alk.service.MultipleServiceRequestEngine.prototype.queueRequest);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'processQueue',
    alk.service.MultipleServiceRequestEngine.prototype.processQueue);

goog.exportSymbol(
    'alk.service.POICategoriesSingleSearchService',
    alk.service.POICategoriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.POIService',
    alk.service.POIService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.PolygonsCountyService',
    alk.service.PolygonsCountyService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RestService',
    alk.service.RestService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceRouteService',
    alk.service.RoadSurfaceRouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceTileService',
    alk.service.RoadSurfaceTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoutePathService',
    alk.service.RoutePathService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteReportsService',
    alk.service.RouteReportsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteService',
    alk.service.RouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchSingleSearchService',
    alk.service.SearchSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchTypesSingleSearchService',
    alk.service.SearchTypesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.ServiceBase',
    alk.service.ServiceBase,
    ALKMAPS);

goog.exportProperty(
    alk.service.ServiceBase.prototype,
    'getServiceOptions',
    alk.service.ServiceBase.prototype.getServiceOptions);

goog.exportSymbol(
    'alk.service.Service',
    alk.service.Service,
    ALKMAPS);

goog.exportProperty(
    alk.service.Service.prototype,
    'getURL',
    alk.service.Service.prototype.getURL);

goog.exportProperty(
    alk.service.Service.prototype,
    'get',
    alk.service.Service.prototype.get);

goog.exportProperty(
    alk.service.Service.prototype,
    'processResponse',
    alk.service.Service.prototype.processResponse);

goog.exportProperty(
    alk.service.Service.prototype,
    'getAttribution',
    alk.service.Service.prototype.getAttribution);

goog.exportSymbol(
    'alk.service.StatesSingleSearchService',
    alk.service.StatesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCameraMetadataService',
    alk.service.TrafficCameraMetadataService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCamerasService',
    alk.service.TrafficCamerasService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficIncidentsService',
    alk.service.TrafficIncidentsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficTileService',
    alk.service.TrafficTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherAlertsService',
    alk.service.WeatherAlertsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherImageTileService',
    alk.service.WeatherImageTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgCheck',
    alk.service.setArgCheck,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgPermissive',
    alk.service.setArgPermissive,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.BaseMapSource',
    alk.source.BaseMapSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.DriveTimePolygon',
    alk.source.DriveTimePolygon,
    ALKMAPS);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'getDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.getDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'setDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.setDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'addDriveTimePolygon',
    alk.source.DriveTimePolygon.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.source.EditTrailRoute',
    alk.source.EditTrailRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'pushRoute',
    alk.source.EditTrailRoute.prototype.pushRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'prevRoute',
    alk.source.EditTrailRoute.prototype.prevRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'nextRoute',
    alk.source.EditTrailRoute.prototype.nextRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'resetEditTrail',
    alk.source.EditTrailRoute.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.source.ImageTileSource',
    alk.source.ImageTileSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.LoadStrategy',
    alk.source.LoadStrategy,
    ALKMAPS);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMinResolution',
    alk.source.LoadStrategy.prototype.getMinResolution);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMaxResolution',
    alk.source.LoadStrategy.prototype.getMaxResolution);

goog.exportSymbol(
    'alk.source.MultiRoute',
    alk.source.MultiRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceResponse',
    alk.source.MultiRoute.prototype.getRouteServiceResponse);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'addRoute',
    alk.source.MultiRoute.prototype.addRoute);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteFeatures',
    alk.source.MultiRoute.prototype.getRouteFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getLineFeatures',
    alk.source.MultiRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteIds',
    alk.source.MultiRoute.prototype.getRouteIds);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceOptions',
    alk.source.MultiRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'removeRoute',
    alk.source.MultiRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.POISource',
    alk.source.POISource,
    ALKMAPS);

goog.exportProperty(
    alk.source.POISource.prototype,
    'getPOIService',
    alk.source.POISource.prototype.getPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'setPOIService',
    alk.source.POISource.prototype.setPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'clonePOIServiceOptions',
    alk.source.POISource.prototype.clonePOIServiceOptions);

goog.exportProperty(
    alk.source.POISource.prototype,
    'processResponse',
    alk.source.POISource.prototype.processResponse);

goog.exportProperty(
    alk.source.POISource.prototype,
    'search',
    alk.source.POISource.prototype.search);

goog.exportSymbol(
    'alk.source.PolygonsCountyCache',
    alk.source.PolygonsCountyCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'getPolygonForCountyCode',
    alk.source.PolygonsCountyCache.prototype.getPolygonForCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'queueCountyCode',
    alk.source.PolygonsCountyCache.prototype.queueCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'processQueue',
    alk.source.PolygonsCountyCache.prototype.processQueue);

goog.exportSymbol(
    'alk.source.RoadSurfaceRoute',
    alk.source.RoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'getRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.getRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'setRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.setRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'cloneRoadSurfaceRouteServiceOptions',
    alk.source.RoadSurfaceRoute.prototype.cloneRoadSurfaceRouteServiceOptions);

goog.exportSymbol(
    'alk.source.RoadSurfaceTileSource',
    alk.source.RoadSurfaceTileSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'getRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.getRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'setRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.setRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'changeRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.changeRoadSurfaceTileService);

goog.exportSymbol(
    'alk.source.Route',
    alk.source.Route,
    ALKMAPS);

goog.exportProperty(
    alk.source.Route.prototype,
    'getRouteService',
    alk.source.Route.prototype.getRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'setRouteService',
    alk.source.Route.prototype.setRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'cloneRouteServiceOptions',
    alk.source.Route.prototype.cloneRouteServiceOptions);

goog.exportSymbol(
    'alk.source.SingleRoadSurfaceRoute',
    alk.source.SingleRoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'setRoute',
    alk.source.SingleRoadSurfaceRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'clear',
    alk.source.SingleRoadSurfaceRoute.prototype.clear);

goog.exportSymbol(
    'alk.source.SingleRoute',
    alk.source.SingleRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'setRoute',
    alk.source.SingleRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRoute',
    alk.source.SingleRoute.prototype.getRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getStopFeatures',
    alk.source.SingleRoute.prototype.getStopFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getLineFeatures',
    alk.source.SingleRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRouteServiceOptions',
    alk.source.SingleRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'removeRoute',
    alk.source.SingleRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.SingleSearch',
    alk.source.SingleSearch,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchSingleSearchService',
    alk.source.SingleSearch.prototype.getSearchSingleSearchService);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'search',
    alk.source.SingleSearch.prototype.search);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'searchResult',
    alk.source.SingleSearch.prototype.searchResult);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchResult',
    alk.source.SingleSearch.prototype.getSearchResult);

goog.exportSymbol(
    'alk.source.SubtractionLoadStrategy',
    alk.source.SubtractionLoadStrategy,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.TrafficCameraMetadataCache',
    alk.source.TrafficCameraMetadataCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'store',
    alk.source.TrafficCameraMetadataCache.prototype.store);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'retrieve',
    alk.source.TrafficCameraMetadataCache.prototype.retrieve);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'get',
    alk.source.TrafficCameraMetadataCache.prototype.get);

goog.exportSymbol(
    'alk.source.TrafficCamerasSource',
    alk.source.TrafficCamerasSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.getTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'setTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.setTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'changeTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.changeTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficCamerasSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCameras',
    alk.source.TrafficCamerasSource.prototype.getTrafficCameras);

goog.exportSymbol(
    'alk.source.TrafficIncidentsSource',
    alk.source.TrafficIncidentsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'setTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.setTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'changeTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.changeTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficIncidentsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidents',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidents);

goog.exportSymbol(
    'alk.source.TrafficSource',
    alk.source.TrafficSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.WeatherAlertsSource',
    alk.source.WeatherAlertsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'setWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.setWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'changeWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.changeWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'removeAllFeatures',
    alk.source.WeatherAlertsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlerts',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlerts);

goog.exportSymbol(
    'alk.source.WeatherSource',
    alk.source.WeatherSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.XYZSource',
    alk.source.XYZSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'setService',
    alk.source.XYZSource.prototype.setService);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'service',
    alk.source.XYZSource.prototype.service);

goog.exportSymbol(
    'alk.style.Arrow',
    alk.style.Arrow,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.ArrowsRouteStyle',
    alk.style.ArrowsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'getArrow',
    alk.style.ArrowsRouteStyle.prototype.getArrow);

goog.exportSymbol(
    'alk.style.DriveTimeLayerStyle',
    alk.style.DriveTimeLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.EditRouteStyle',
    alk.style.EditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.WayPointsEditRouteStyle',
    alk.style.WayPointsEditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.IconPOILayerStyle',
    alk.style.IconPOILayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.LineRouteStyle',
    alk.style.LineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setStrokeStyle',
    alk.style.LineRouteStyle.prototype.setStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.setUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.LineRouteStyle.prototype.getStrokeStyle);

goog.exportSymbol(
    'alk.style.POIIconFactory',
    alk.style.POIIconFactory,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.POILayerStyle',
    alk.style.POILayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'layer',
    alk.style.POILayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setLayer',
    alk.style.POILayerStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setUpdating',
    alk.style.POILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'styleFunction',
    alk.style.POILayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.PolygonWeatherAlertsLayerStyle',
    alk.style.PolygonWeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.QueuedLineRouteStyle',
    alk.style.QueuedLineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'setStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.setStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'clearStrokeForRouteId',
    alk.style.QueuedLineRouteStyle.prototype.clearStrokeForRouteId);

goog.exportSymbol(
    'alk.style.QueuedStyleLayerStyle',
    alk.style.QueuedStyleLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'setStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.setStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'getStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.getStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'clearStyleForId',
    alk.style.QueuedStyleLayerStyle.prototype.clearStyleForId);

goog.exportSymbol(
    'alk.style.RoadSurfaceStyle',
    alk.style.RoadSurfaceStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'layer',
    alk.style.RoadSurfaceStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'setUpdating',
    alk.style.RoadSurfaceStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'styleFunction',
    alk.style.RoadSurfaceStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.RoutingLayerStyle',
    alk.style.RoutingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'layer',
    alk.style.RoutingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'setUpdating',
    alk.style.RoutingLayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'styleFunction',
    alk.style.RoutingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.Shadow',
    alk.style.Shadow,
    ALKMAPS);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getOrigin',
    alk.style.Shadow.prototype.getOrigin);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getRadius',
    alk.style.Shadow.prototype.getRadius);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getHitDetectionImageSize',
    alk.style.Shadow.prototype.getHitDetectionImageSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getAnchor',
    alk.style.Shadow.prototype.getAnchor);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getSize',
    alk.style.Shadow.prototype.getSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getFill',
    alk.style.Shadow.prototype.getFill);

goog.exportSymbol(
    'alk.style.ShadowedCircle',
    alk.style.ShadowedCircle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.SingleSearchStyle',
    alk.style.SingleSearchStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'layer',
    alk.style.SingleSearchStyle.prototype.layer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setLayer',
    alk.style.SingleSearchStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setUpdating',
    alk.style.SingleSearchStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'styleFunction',
    alk.style.SingleSearchStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.StopsRouteStyle',
    alk.style.StopsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.StopsRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.StopsRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.StopsRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultWayPointImage',
    alk.style.StopsRouteStyle.prototype.defaultWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginImage',
    alk.style.StopsRouteStyle.prototype.getOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginStyleFunction',
    alk.style.StopsRouteStyle.prototype.getOriginStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointImage',
    alk.style.StopsRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointImage',
    alk.style.StopsRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getViaPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationImage',
    alk.style.StopsRouteStyle.prototype.getDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationStyleFunction',
    alk.style.StopsRouteStyle.prototype.getDestinationStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getStopStyle',
    alk.style.StopsRouteStyle.prototype.getStopStyle);

goog.exportSymbol(
    'alk.style.StrokeQueue',
    alk.style.StrokeQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'getWidth',
    alk.style.StrokeQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'setWidth',
    alk.style.StrokeQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'strokes',
    alk.style.StrokeQueue.prototype.strokes);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'next',
    alk.style.StrokeQueue.prototype.next);

goog.exportSymbol(
    'alk.style.StyleQueue',
    alk.style.StyleQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'getWidth',
    alk.style.StyleQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'setWidth',
    alk.style.StyleQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'styles',
    alk.style.StyleQueue.prototype.styles);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'next',
    alk.style.StyleQueue.prototype.next);

goog.exportSymbol(
    'alk.style.TrafficCamerasLayerStyle',
    alk.style.TrafficCamerasLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficCamerasLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficCamerasLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.TrafficIncidentsLayerStyle',
    alk.style.TrafficIncidentsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficIncidentsLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficIncidentsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.UpdatingLayerStyle',
    alk.style.UpdatingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'layer',
    alk.style.UpdatingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'styleFunction',
    alk.style.UpdatingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.WeatherAlertsLayerStyle',
    alk.style.WeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.WeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.WeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.val.ArrowsType.None',
    alk.val.ArrowsType.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.Line',
    alk.val.ArrowsType.Line,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.End',
    alk.val.ArrowsType.End,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.All',
    alk.val.Certainty.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Observed',
    alk.val.Certainty.Observed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Likely',
    alk.val.Certainty.Likely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Possible',
    alk.val.Certainty.Possible,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unlikely',
    alk.val.Certainty.Unlikely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unknown',
    alk.val.Certainty.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.Current',
    alk.val.Dataset.Current,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_EU',
    alk.val.Dataset.PCM_EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_OC',
    alk.val.Dataset.PCM_OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SA',
    alk.val.Dataset.PCM_SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_GT',
    alk.val.Dataset.PCM_GT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AF',
    alk.val.Dataset.PCM_AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AS',
    alk.val.Dataset.PCM_AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_ME',
    alk.val.Dataset.PCM_ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SE',
    alk.val.Dataset.PCM_SE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_NA',
    alk.val.Dataset.PCM_NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Radar',
    alk.val.Display.Radar,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Satellite',
    alk.val.Display.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Miles',
    alk.val.DistanceUnits.Miles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Kilometers',
    alk.val.DistanceUnits.Kilometers,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Cities',
    alk.val.DrawerGroup.Cities,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Labels',
    alk.val.DrawerGroup.Labels,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Roads',
    alk.val.DrawerGroup.Roads,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Commercial',
    alk.val.DrawerGroup.Commercial,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Borders',
    alk.val.DrawerGroup.Borders,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Areas',
    alk.val.DrawerGroup.Areas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Format.ImagePNG',
    alk.val.Format.ImagePNG,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Gallons',
    alk.val.FuelUnits.Gallons,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Liters',
    alk.val.FuelUnits.Liters,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.None',
    alk.val.HazMat.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.General',
    alk.val.HazMat.General,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Caustic',
    alk.val.HazMat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Explosives',
    alk.val.HazMat.Explosives,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Flammable',
    alk.val.HazMat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Inhalants',
    alk.val.HazMat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Radioactive',
    alk.val.HazMat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Monday',
    alk.val.HistDay.Monday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Tuesday',
    alk.val.HistDay.Tuesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Wednesday',
    alk.val.HistDay.Wednesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Thursday',
    alk.val.HistDay.Thursday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Friday',
    alk.val.HistDay.Friday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Saturday',
    alk.val.HistDay.Saturday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Sunday',
    alk.val.HistDay.Sunday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed607LH',
    alk.val.HosRuleType.USFed607LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed708LH',
    alk.val.HosRuleType.USFed708LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Background',
    alk.val.ImgOption.Background,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Foreground',
    alk.val.ImgOption.Foreground,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Both',
    alk.val.ImgOption.Both,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Default',
    alk.val.ImgSrc.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.ALKCurated',
    alk.val.ImgSrc.ALKCurated,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat1',
    alk.val.ImgSrc.Sat1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat2',
    alk.val.ImgSrc.Sat2,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat3',
    alk.val.ImgSrc.Sat3,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat4',
    alk.val.ImgSrc.Sat4,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat5',
    alk.val.ImgSrc.Sat5,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat6',
    alk.val.ImgSrc.Sat6,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENUS',
    alk.val.Language.ENUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENGB',
    alk.val.Language.ENGB,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.DE',
    alk.val.Language.DE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.FR',
    alk.val.Language.FR,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ES',
    alk.val.Language.ES,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.IT',
    alk.val.Language.IT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.NationalNetwork',
    alk.val.OverrideClass.NationalNetwork,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.FiftyThreeFoot',
    alk.val.OverrideClass.FiftyThreeFoot,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.All',
    alk.val.POICategory.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.City',
    alk.val.POICategory.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Zip',
    alk.val.POICategory.Zip,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Place',
    alk.val.POICategory.Place,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Airport',
    alk.val.POICategory.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Automotive',
    alk.val.POICategory.Automotive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.WeighStation',
    alk.val.POICategory.WeighStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Dining',
    alk.val.POICategory.Dining,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Education',
    alk.val.POICategory.Education,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Emergency',
    alk.val.POICategory.Emergency,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Government',
    alk.val.POICategory.Government,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Gas',
    alk.val.POICategory.Gas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Lodging',
    alk.val.POICategory.Lodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Parks',
    alk.val.POICategory.Parks,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Retail',
    alk.val.POICategory.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.SportsRec',
    alk.val.POICategory.SportsRec,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Travel',
    alk.val.POICategory.Travel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.TruckServices',
    alk.val.POICategory.TruckServices,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Attractions',
    alk.val.POICategory.Attractions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.Default',
    alk.val.Provider.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.RC1',
    alk.val.Provider.RC1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.NA',
    alk.val.Region.NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.EU',
    alk.val.Region.EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.OC',
    alk.val.Region.OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.SA',
    alk.val.Region.SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AF',
    alk.val.Region.AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AS',
    alk.val.Region.AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.ME',
    alk.val.Region.ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ReportFormat.JSON',
    alk.val.ReportFormat.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.CalcMiles',
    alk.val.Report.CalcMiles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Mileage',
    alk.val.Report.Mileage,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Directions',
    alk.val.Report.Directions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.State',
    alk.val.Report.State,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Detail',
    alk.val.Report.Detail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Road',
    alk.val.Report.Road,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.GeoTunnel',
    alk.val.Report.GeoTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.None',
    alk.val.RouteOptimization.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.ThruAll',
    alk.val.RouteOptimization.ThruAll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.DestinationFixed',
    alk.val.RouteOptimization.DestinationFixed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Practical',
    alk.val.RouteType.Practical,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Shortest',
    alk.val.RouteType.Shortest,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.All',
    alk.val.Severity.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Extreme',
    alk.val.Severity.Extreme,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Severe',
    alk.val.Severity.Severe,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Moderate',
    alk.val.Severity.Moderate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Minor',
    alk.val.Severity.Minor,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Unknown',
    alk.val.Severity.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG900913',
    alk.val.SRS.EPSG900913,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG4326',
    alk.val.SRS.EPSG4326,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG3857',
    alk.val.SRS.EPSG3857,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Origin',
    alk.val.StopType.Origin,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.WayPoint',
    alk.val.StopType.WayPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Destination',
    alk.val.StopType.Destination,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.ViaPoint',
    alk.val.StopType.ViaPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Transportation',
    alk.val.Style.Transportation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataDark',
    alk.val.Style.DataDark,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataLight',
    alk.val.Style.DataLight,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Basic',
    alk.val.Style.Basic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Default',
    alk.val.Style.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Classic',
    alk.val.Style.Classic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Monochrome',
    alk.val.Style.Monochrome,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.RoadAtlas',
    alk.val.Style.RoadAtlas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Night',
    alk.val.Style.Night,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Satellite',
    alk.val.Style.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Lightness',
    alk.val.Style.Lightness,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Smooth',
    alk.val.Style.Smooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Terrain',
    alk.val.Style.Terrain,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Modern',
    alk.val.Style.Modern,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.US',
    alk.val.TollCurrency.US,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.CDN',
    alk.val.TollCurrency.CDN,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.All',
    alk.val.TollPlan.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.C407ETRTransponder',
    alk.val.TollPlan.C407ETRTransponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.A25Transponder',
    alk.val.TollPlan.A25Transponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.BreezeBy',
    alk.val.TollPlan.BreezeBy,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CPass',
    alk.val.TollPlan.CPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CruiseCard',
    alk.val.TollPlan.CruiseCard,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPass',
    alk.val.TollPlan.EPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPassCanada',
    alk.val.TollPlan.EPassCanada,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EXpressToll',
    alk.val.TollPlan.EXpressToll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZTag',
    alk.val.TollPlan.EZTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPass',
    alk.val.TollPlan.EZPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassNJ',
    alk.val.TollPlan.EZPassNJ,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassWV',
    alk.val.TollPlan.EZPassWV,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FastLane',
    alk.val.TollPlan.FastLane,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FasTrak',
    alk.val.TollPlan.FasTrak,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GeauxPass',
    alk.val.TollPlan.GeauxPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GoodToGo',
    alk.val.TollPlan.GoodToGo,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GOPass',
    alk.val.TollPlan.GOPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IPass',
    alk.val.TollPlan.IPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IZoom',
    alk.val.TollPlan.IZoom,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.KTag',
    alk.val.TollPlan.KTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LaredoTradeTag',
    alk.val.TollPlan.LaredoTradeTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LeeWay',
    alk.val.TollPlan.LeeWay,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.MacPass',
    alk.val.TollPlan.MacPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NCQuickPass',
    alk.val.TollPlan.NCQuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NEXPress',
    alk.val.TollPlan.NEXPress,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PalmettoPass',
    alk.val.TollPlan.PalmettoPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PeachPass',
    alk.val.TollPlan.PeachPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PikePass',
    alk.val.TollPlan.PikePass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.QuickPass',
    alk.val.TollPlan.QuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SmartTag',
    alk.val.TollPlan.SmartTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.StraitPass',
    alk.val.TollPlan.StraitPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SunPass',
    alk.val.TollPlan.SunPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TollTag',
    alk.val.TollPlan.TollTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TxTag',
    alk.val.TollPlan.TxTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.WalbashPass',
    alk.val.TollPlan.WalbashPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentyEightDoubleTrailer',
    alk.val.TruckConfig.TwentyEightDoubleTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyStraightTruck',
    alk.val.TruckConfig.FortyStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyEightSemiTrailer',
    alk.val.TruckConfig.FortyEightSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FiftyThreeSemiTrailer',
    alk.val.TruckConfig.FiftyThreeSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FullSizeVan',
    alk.val.TruckConfig.FullSizeVan,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentySixStraightTruck',
    alk.val.TruckConfig.TwentySixStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.All',
    alk.val.Urgency.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Immediate',
    alk.val.Urgency.Immediate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Expected',
    alk.val.Urgency.Expected,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Future',
    alk.val.Urgency.Future,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Past',
    alk.val.Urgency.Past,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Unknown',
    alk.val.Urgency.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.English',
    alk.val.VehicleDimensionUnits.English,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.Metric',
    alk.val.VehicleDimensionUnits.Metric,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Truck',
    alk.val.VehicleType.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.LightTruck',
    alk.val.VehicleType.LightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Auto',
    alk.val.VehicleType.Auto,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.WeatherAlertColor',
    alk.val.WeatherAlertColor,
    ALKMAPS);

goog.exportSymbol(
    'alk.VERSION',
    alk.VERSION,
    ALKMAPS);

goog.exportSymbol(
    'alk.setURL',
    alk.setURL,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'shouldModify',
    alk.interaction.WayPointRouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'processStyle',
    alk.interaction.WayPointRouteModify.prototype.processStyle);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'get',
    alk.service.CountriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'processResponse',
    alk.service.CountriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'get',
    alk.service.DriveTimePolygonService.prototype.get);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'processResponse',
    alk.service.DriveTimePolygonService.prototype.processResponse);

goog.exportProperty(
    alk.service.LocationsReverseService.prototype,
    'get',
    alk.service.LocationsReverseService.prototype.get);

goog.exportProperty(
    alk.service.LocationsService.prototype,
    'get',
    alk.service.LocationsService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'get',
    alk.service.POICategoriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'processResponse',
    alk.service.POICategoriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.POIService.prototype,
    'get',
    alk.service.POIService.prototype.get);

goog.exportProperty(
    alk.service.POIService.prototype,
    'processResponse',
    alk.service.POIService.prototype.processResponse);

goog.exportProperty(
    alk.service.PolygonsCountyService.prototype,
    'get',
    alk.service.PolygonsCountyService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'get',
    alk.service.RoadSurfaceRouteService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'processResponse',
    alk.service.RoadSurfaceRouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.RouteReportsService.prototype,
    'get',
    alk.service.RouteReportsService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'get',
    alk.service.RouteService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'processResponse',
    alk.service.RouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'get',
    alk.service.SearchSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'get',
    alk.service.SearchTypesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchTypesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'get',
    alk.service.StatesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'processResponse',
    alk.service.StatesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficCameraMetadataService.prototype,
    'get',
    alk.service.TrafficCameraMetadataService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'get',
    alk.service.TrafficCamerasService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'processResponse',
    alk.service.TrafficCamerasService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'get',
    alk.service.TrafficIncidentsService.prototype.get);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'processResponse',
    alk.service.TrafficIncidentsService.prototype.processResponse);

goog.exportProperty(
    alk.service.WeatherAlertsService.prototype,
    'get',
    alk.service.WeatherAlertsService.prototype.get);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'setRoute',
    alk.source.EditTrailRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'getRouteServiceOptions',
    alk.source.EditTrailRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdating',
    alk.style.LineRouteStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'styleFunction',
    alk.style.LineRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeStyle);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'styleFunction',
    alk.style.StopsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'styleFunction',
    alk.style.ArrowsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'styleFunction',
    alk.style.QueuedStyleLayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.EditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.EditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.EditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'styleFunction',
    alk.style.EditRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'setUpdating',
    alk.style.IconPOILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'styleFunction',
    alk.style.IconPOILayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.PolygonWeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.PolygonWeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.control.ContextMenu',
    alk.control.ContextMenu,
    ALKMAPS);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'handleRightClicks',
    alk.control.ContextMenu.prototype.handleRightClicks);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'autoActivate',
    alk.control.ContextMenu.prototype.autoActivate);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'ctxMenuItems',
    alk.control.ContextMenu.prototype.ctxMenuItems);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'items',
    alk.control.ContextMenu.prototype.items);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'setMap',
    alk.control.ContextMenu.prototype.setMap);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'render',
    alk.control.ContextMenu.prototype.render);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'positionContainer',
    alk.control.ContextMenu.prototype.positionContainer);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'openMenu',
    alk.control.ContextMenu.prototype.openMenu);

goog.exportProperty(
    alk.control.ContextMenu.prototype,
    'closeMenu',
    alk.control.ContextMenu.prototype.closeMenu);

goog.exportSymbol(
    'alk.format.FormatType.ARRAY_BUFFER',
    alk.format.FormatType.ARRAY_BUFFER,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.JSON',
    alk.format.FormatType.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.TEXT',
    alk.format.FormatType.TEXT,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.FormatType.XML',
    alk.format.FormatType.XML,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.HashedIdFactory',
    alk.format.HashedIdFactory,
    ALKMAPS);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'hashCollisionFix',
    alk.format.HashedIdFactory.prototype.hashCollisionFix);

goog.exportProperty(
    alk.format.HashedIdFactory.prototype,
    'getIdForString',
    alk.format.HashedIdFactory.prototype.getIdForString);

goog.exportSymbol(
    'alk.format.JSONFeature',
    alk.format.JSONFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.POIJSON',
    alk.format.POIJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficCamerasJSON',
    alk.format.TrafficCamerasJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.TrafficIncidentsJSON',
    alk.format.TrafficIncidentsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.format.WeatherAlertsJSON',
    alk.format.WeatherAlertsJSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.geocode.Geocoder',
    alk.geocode.Geocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.Geocoder.prototype,
    'geocode',
    alk.geocode.Geocoder.prototype.geocode);

goog.exportSymbol(
    'alk.geocode.ReverseGeocoder',
    alk.geocode.ReverseGeocoder,
    ALKMAPS);

goog.exportProperty(
    alk.geocode.ReverseGeocoder.prototype,
    'reverseGeocode',
    alk.geocode.ReverseGeocoder.prototype.reverseGeocode);

goog.exportSymbol(
    'alk.img.Hazmat.Caustic',
    alk.img.Hazmat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Explosive',
    alk.img.Hazmat.Explosive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Flammable',
    alk.img.Hazmat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Inhalants',
    alk.img.Hazmat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Radioactive',
    alk.img.Hazmat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericEU',
    alk.img.Hazmat.GenericEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.GenericUS',
    alk.img.Hazmat.GenericUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Hazmat.Water',
    alk.img.Hazmat.Water,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AllowRoad',
    alk.img.Misc.AllowRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.AvoidRoad',
    alk.img.Misc.AvoidRoad,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Check',
    alk.img.Misc.Check,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagEnd',
    alk.img.Misc.FlagEnd,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStart',
    alk.img.Misc.FlagStart,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagStop',
    alk.img.Misc.FlagStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.FlagWaypoint',
    alk.img.Misc.FlagWaypoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Help',
    alk.img.Misc.Help,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadBlue',
    alk.img.Misc.LoadBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGray',
    alk.img.Misc.LoadGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadGreen',
    alk.img.Misc.LoadGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.LoadRed',
    alk.img.Misc.LoadRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.No',
    alk.img.Misc.No,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.OilGas',
    alk.img.Misc.OilGas,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinGreen',
    alk.img.Misc.PinGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.PinRed',
    alk.img.Misc.PinRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.Route',
    alk.img.Misc.Route,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckBlue',
    alk.img.Misc.TruckBlue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGray',
    alk.img.Misc.TruckGray,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckGreen',
    alk.img.Misc.TruckGreen,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Misc.TruckRed',
    alk.img.Misc.TruckRed,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Address',
    alk.img.POI.Address,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Airport',
    alk.img.POI.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Atm',
    alk.img.POI.Atm,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Attraction',
    alk.img.POI.Attraction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoDealer',
    alk.img.POI.AutoDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRental',
    alk.img.POI.AutoRental,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.AutoRepair',
    alk.img.POI.AutoRepair,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Bank',
    alk.img.POI.Bank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Blank',
    alk.img.POI.Blank,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BorderCrossing',
    alk.img.POI.BorderCrossing,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BridgeTunnel',
    alk.img.POI.BridgeTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.BusStop',
    alk.img.POI.BusStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CatScale',
    alk.img.POI.CatScale,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.City',
    alk.img.POI.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.CommuterRail',
    alk.img.POI.CommuterRail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.DieselExhaustFluid',
    alk.img.POI.DieselExhaustFluid,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Entertainment',
    alk.img.POI.Entertainment,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Favorite',
    alk.img.POI.Favorite,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Ferry',
    alk.img.POI.Ferry,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Fuel',
    alk.img.POI.Fuel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GameVenues',
    alk.img.POI.GameVenues,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GenericResult',
    alk.img.POI.GenericResult,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.GeographicFeature',
    alk.img.POI.GeographicFeature,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Grocery',
    alk.img.POI.Grocery,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Home',
    alk.img.POI.Home,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Hotel',
    alk.img.POI.Hotel,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.IndustrialEstate',
    alk.img.POI.IndustrialEstate,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveLink',
    alk.img.POI.LiveLink,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.LiveSearch',
    alk.img.POI.LiveSearch,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marina',
    alk.img.POI.Marina,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Marker',
    alk.img.POI.Marker,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Medical',
    alk.img.POI.Medical,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MotorcycleDealer',
    alk.img.POI.MotorcycleDealer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Municipal',
    alk.img.POI.Municipal,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.MyCar',
    alk.img.POI.MyCar,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherAirport',
    alk.img.POI.OtherAirport,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.OtherLodging',
    alk.img.POI.OtherLodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Other',
    alk.img.POI.Other,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Park',
    alk.img.POI.Park,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Parking',
    alk.img.POI.Parking,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PlaceOfWorship',
    alk.img.POI.PlaceOfWorship,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.PublicVenue',
    alk.img.POI.PublicVenue,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recent',
    alk.img.POI.Recent,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Recreation',
    alk.img.POI.Recreation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RestArea',
    alk.img.POI.RestArea,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Restaurant',
    alk.img.POI.Restaurant,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Retail',
    alk.img.POI.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.RV',
    alk.img.POI.RV,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.SafetyCamera',
    alk.img.POI.SafetyCamera,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.School',
    alk.img.POI.School,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TandemTrailer',
    alk.img.POI.TandemTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TollBooth',
    alk.img.POI.TollBooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TrainStation',
    alk.img.POI.TrainStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Truck',
    alk.img.POI.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.TruckStop',
    alk.img.POI.TruckStop,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.VehicleChargingStation',
    alk.img.POI.VehicleChargingStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Wikipedia',
    alk.img.POI.Wikipedia,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.POI.Work',
    alk.img.POI.Work,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapAccident',
    alk.img.Traffic.MapAccident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapConstruction',
    alk.img.Traffic.MapConstruction,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapIncident',
    alk.img.Traffic.MapIncident,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapTrafficJam',
    alk.img.Traffic.MapTrafficJam,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.MapWeather',
    alk.img.Traffic.MapWeather,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity1',
    alk.img.Traffic.Severity1,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity2',
    alk.img.Traffic.Severity2,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.Traffic.Severity3',
    alk.img.Traffic.Severity3,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightEU',
    alk.img.TruckRestr.HeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.HeightNA',
    alk.img.TruckRestr.HeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthEU',
    alk.img.TruckRestr.LengthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.LengthNA',
    alk.img.TruckRestr.LengthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiEU',
    alk.img.TruckRestr.MultiEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.MultiNA',
    alk.img.TruckRestr.MultiNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckEU',
    alk.img.TruckRestr.NoTruckEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.NoTruckNA',
    alk.img.TruckRestr.NoTruckNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightEU',
    alk.img.TruckRestr.WeightEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightNA',
    alk.img.TruckRestr.WeightNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleEU',
    alk.img.TruckRestr.WeightPerAxleEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WeightPerAxleNA',
    alk.img.TruckRestr.WeightPerAxleNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthEU',
    alk.img.TruckRestr.WidthEU,
    ALKMAPS);

goog.exportSymbol(
    'alk.img.TruckRestr.WidthNA',
    alk.img.TruckRestr.WidthNA,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.EditTrailRoutingLayerKeyShortCuts',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype,
    'handleMapBrowserEvent',
    alk.interaction.EditTrailRoutingLayerKeyShortCuts.prototype.handleMapBrowserEvent);

goog.exportSymbol(
    'alk.interaction.RouteModify',
    alk.interaction.RouteModify,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayer',
    alk.interaction.RouteModify.prototype.routingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'setRoutingLayer',
    alk.interaction.RouteModify.prototype.setRoutingLayer);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'shouldModify',
    alk.interaction.RouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedStops',
    alk.interaction.RouteModify.prototype.getModifiedStops);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiedSegments',
    alk.interaction.RouteModify.prototype.getModifiedSegments);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getModifiableStopTypes',
    alk.interaction.RouteModify.prototype.getModifiableStopTypes);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'getCreationStopType',
    alk.interaction.RouteModify.prototype.getCreationStopType);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processEvent',
    alk.interaction.RouteModify.prototype.processEvent);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'routingLayerStyle',
    alk.interaction.RouteModify.prototype.routingLayerStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'processStyle',
    alk.interaction.RouteModify.prototype.processStyle);

goog.exportProperty(
    alk.interaction.RouteModify.prototype,
    'handleEvent',
    alk.interaction.RouteModify.prototype.handleEvent);

goog.exportSymbol(
    'alk.interaction.SingleSearchPopupInteraction',
    alk.interaction.SingleSearchPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.SingleSearchPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.SingleSearchPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficCameraPopupInteraction',
    alk.interaction.TrafficCameraPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficCameraPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficCameraPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.TrafficIncidentPopupInteraction',
    alk.interaction.TrafficIncidentPopupInteraction,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.TrafficIncidentPopupInteraction.prototype,
    'removeOverlays',
    alk.interaction.TrafficIncidentPopupInteraction.prototype.removeOverlays);

goog.exportSymbol(
    'alk.interaction.ViaPointRouteModify',
    alk.interaction.ViaPointRouteModify,
    ALKMAPS);

goog.exportSymbol(
    'alk.interaction.WayPointRouteModify',
    alk.interaction.WayPointRouteModify,
    ALKMAPS);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'shouldModify',
    alk.interaction.WayPointRouteModify.prototype.shouldModify);

goog.exportProperty(
    alk.interaction.WayPointRouteModify.prototype,
    'processStyle',
    alk.interaction.WayPointRouteModify.prototype.processStyle);

goog.exportSymbol(
    'alk.layer.BaseMapLayer',
    alk.layer.BaseMapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.DriveTimeLayer',
    alk.layer.DriveTimeLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.DriveTimeLayer.prototype,
    'addDriveTimePolygon',
    alk.layer.DriveTimeLayer.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.layer.EditTrailRoutingLayer',
    alk.layer.EditTrailRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'pushRoute',
    alk.layer.EditTrailRoutingLayer.prototype.pushRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'prevRoute',
    alk.layer.EditTrailRoutingLayer.prototype.prevRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'nextRoute',
    alk.layer.EditTrailRoutingLayer.prototype.nextRoute);

goog.exportProperty(
    alk.layer.EditTrailRoutingLayer.prototype,
    'resetEditTrail',
    alk.layer.EditTrailRoutingLayer.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.layer.ImageTileLayer',
    alk.layer.ImageTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MapLayer',
    alk.layer.MapLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.MultiRoutingLayer',
    alk.layer.MultiRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'addRoute',
    alk.layer.MultiRoutingLayer.prototype.addRoute);

goog.exportProperty(
    alk.layer.MultiRoutingLayer.prototype,
    'removeRoute',
    alk.layer.MultiRoutingLayer.prototype.removeRoute);

goog.exportSymbol(
    'alk.layer.POILayer',
    alk.layer.POILayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'getPOILayerStyle',
    alk.layer.POILayer.prototype.getPOILayerStyle);

goog.exportProperty(
    alk.layer.POILayer.prototype,
    'setStyle',
    alk.layer.POILayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceRouteLayer',
    alk.layer.RoadSurfaceRouteLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'getRoadSurfaceStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.getRoadSurfaceStyle);

goog.exportProperty(
    alk.layer.RoadSurfaceRouteLayer.prototype,
    'setStyle',
    alk.layer.RoadSurfaceRouteLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.RoadSurfaceTileLayer',
    alk.layer.RoadSurfaceTileLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.RoutingLayer',
    alk.layer.RoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'getRoutingLayerStyle',
    alk.layer.RoutingLayer.prototype.getRoutingLayerStyle);

goog.exportProperty(
    alk.layer.RoutingLayer.prototype,
    'setStyle',
    alk.layer.RoutingLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.SingleRoutingLayer',
    alk.layer.SingleRoutingLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'setRoute',
    alk.layer.SingleRoutingLayer.prototype.setRoute);

goog.exportProperty(
    alk.layer.SingleRoutingLayer.prototype,
    'getRoute',
    alk.layer.SingleRoutingLayer.prototype.getRoute);

goog.exportSymbol(
    'alk.layer.SingleSearchLayer',
    alk.layer.SingleSearchLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'getSingleSearchStyle',
    alk.layer.SingleSearchLayer.prototype.getSingleSearchStyle);

goog.exportProperty(
    alk.layer.SingleSearchLayer.prototype,
    'setStyle',
    alk.layer.SingleSearchLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficCamerasLayer',
    alk.layer.TrafficCamerasLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'getTrafficCameraLayerStyle',
    alk.layer.TrafficCamerasLayer.prototype.getTrafficCameraLayerStyle);

goog.exportProperty(
    alk.layer.TrafficCamerasLayer.prototype,
    'setStyle',
    alk.layer.TrafficCamerasLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficIncidentsLayer',
    alk.layer.TrafficIncidentsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'getTrafficIncidentLayerStyle',
    alk.layer.TrafficIncidentsLayer.prototype.getTrafficIncidentLayerStyle);

goog.exportProperty(
    alk.layer.TrafficIncidentsLayer.prototype,
    'setStyle',
    alk.layer.TrafficIncidentsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.TrafficLayer',
    alk.layer.TrafficLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherAlertsLayer',
    alk.layer.WeatherAlertsLayer,
    ALKMAPS);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'getWeatherAlertsLayerStyle',
    alk.layer.WeatherAlertsLayer.prototype.getWeatherAlertsLayerStyle);

goog.exportProperty(
    alk.layer.WeatherAlertsLayer.prototype,
    'setStyle',
    alk.layer.WeatherAlertsLayer.prototype.setStyle);

goog.exportSymbol(
    'alk.layer.WeatherLayer',
    alk.layer.WeatherLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherRadarLayer',
    alk.layer.WeatherRadarLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.layer.WeatherSatelliteLayer',
    alk.layer.WeatherSatelliteLayer,
    ALKMAPS);

goog.exportSymbol(
    'alk.overlay.ListTooltipOverlay',
    alk.overlay.ListTooltipOverlay,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setAssigned',
    alk.overlay.ListTooltipOverlay.prototype.setAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'getAssigned',
    alk.overlay.ListTooltipOverlay.prototype.getAssigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'assigned',
    alk.overlay.ListTooltipOverlay.prototype.assigned);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'addListItem',
    alk.overlay.ListTooltipOverlay.prototype.addListItem);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'clear',
    alk.overlay.ListTooltipOverlay.prototype.clear);

goog.exportProperty(
    alk.overlay.ListTooltipOverlay.prototype,
    'setDisplay',
    alk.overlay.ListTooltipOverlay.prototype.setDisplay);

goog.exportSymbol(
    'alk.overlay.SingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'closeElement',
    alk.overlay.SingleSearchItemPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'setSingleSearchItemPopup',
    alk.overlay.SingleSearchItemPopup.prototype.setSingleSearchItemPopup);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'listFormat',
    alk.overlay.SingleSearchItemPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createListHTML',
    alk.overlay.SingleSearchItemPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createContentElement',
    alk.overlay.SingleSearchItemPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.SingleSearchItemPopup.prototype,
    'createPopupElement',
    alk.overlay.SingleSearchItemPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficCameraPopup',
    alk.overlay.TrafficCameraPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'closeElement',
    alk.overlay.TrafficCameraPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'setTrafficCamera',
    alk.overlay.TrafficCameraPopup.prototype.setTrafficCamera);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'listFormat',
    alk.overlay.TrafficCameraPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficCameraPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficCameraPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficCameraPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficCameraPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.TrafficIncidentPopup',
    alk.overlay.TrafficIncidentPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'closeElement',
    alk.overlay.TrafficIncidentPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'setTrafficIncident',
    alk.overlay.TrafficIncidentPopup.prototype.setTrafficIncident);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'listFormat',
    alk.overlay.TrafficIncidentPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createListHTML',
    alk.overlay.TrafficIncidentPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createContentElement',
    alk.overlay.TrafficIncidentPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.TrafficIncidentPopup.prototype,
    'createPopupElement',
    alk.overlay.TrafficIncidentPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.overlay.WeatherAlertPopup',
    alk.overlay.WeatherAlertPopup,
    ALKMAPS);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'closeElement',
    alk.overlay.WeatherAlertPopup.prototype.closeElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'setWeatherAlert',
    alk.overlay.WeatherAlertPopup.prototype.setWeatherAlert);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'listFormat',
    alk.overlay.WeatherAlertPopup.prototype.listFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'itemFormat',
    alk.overlay.WeatherAlertPopup.prototype.itemFormat);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createItemHTML',
    alk.overlay.WeatherAlertPopup.prototype.createItemHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createListHTML',
    alk.overlay.WeatherAlertPopup.prototype.createListHTML);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'elements',
    alk.overlay.WeatherAlertPopup.prototype.elements);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createContentElement',
    alk.overlay.WeatherAlertPopup.prototype.createContentElement);

goog.exportProperty(
    alk.overlay.WeatherAlertPopup.prototype,
    'createPopupElement',
    alk.overlay.WeatherAlertPopup.prototype.createPopupElement);

goog.exportSymbol(
    'alk.service.AvoidFavorSetsService',
    alk.service.AvoidFavorSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'get',
    alk.service.AvoidFavorSetsService.prototype.get);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'add',
    alk.service.AvoidFavorSetsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'update',
    alk.service.AvoidFavorSetsService.prototype.update);

goog.exportProperty(
    alk.service.AvoidFavorSetsService.prototype,
    'delete',
    alk.service.AvoidFavorSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.AvoidFavorsService',
    alk.service.AvoidFavorsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'add',
    alk.service.AvoidFavorsService.prototype.add);

goog.exportProperty(
    alk.service.AvoidFavorsService.prototype,
    'delete',
    alk.service.AvoidFavorsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CountriesSingleSearchService',
    alk.service.CountriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.CustomCategoriesService',
    alk.service.CustomCategoriesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'get',
    alk.service.CustomCategoriesService.prototype.get);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'add',
    alk.service.CustomCategoriesService.prototype.add);

goog.exportProperty(
    alk.service.CustomCategoriesService.prototype,
    'update',
    alk.service.CustomCategoriesService.prototype.update);

goog.exportSymbol(
    'alk.service.CustomPlaceSetsService',
    alk.service.CustomPlaceSetsService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'get',
    alk.service.CustomPlaceSetsService.prototype.get);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'add',
    alk.service.CustomPlaceSetsService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'update',
    alk.service.CustomPlaceSetsService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlaceSetsService.prototype,
    'delete',
    alk.service.CustomPlaceSetsService.prototype.delete);

goog.exportSymbol(
    'alk.service.CustomPlacesService',
    alk.service.CustomPlacesService,
    ALKMAPS);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'add',
    alk.service.CustomPlacesService.prototype.add);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'update',
    alk.service.CustomPlacesService.prototype.update);

goog.exportProperty(
    alk.service.CustomPlacesService.prototype,
    'delete',
    alk.service.CustomPlacesService.prototype.delete);

goog.exportSymbol(
    'alk.service.DriveTimePolygonService',
    alk.service.DriveTimePolygonService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsReverseService',
    alk.service.LocationsReverseService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.LocationsService',
    alk.service.LocationsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MapTileService',
    alk.service.MapTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.MultipleServiceRequestEngine',
    alk.service.MultipleServiceRequestEngine,
    ALKMAPS);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'queueRequest',
    alk.service.MultipleServiceRequestEngine.prototype.queueRequest);

goog.exportProperty(
    alk.service.MultipleServiceRequestEngine.prototype,
    'processQueue',
    alk.service.MultipleServiceRequestEngine.prototype.processQueue);

goog.exportSymbol(
    'alk.service.POICategoriesSingleSearchService',
    alk.service.POICategoriesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.POIService',
    alk.service.POIService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.PolygonsCountyService',
    alk.service.PolygonsCountyService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RestService',
    alk.service.RestService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceRouteService',
    alk.service.RoadSurfaceRouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoadSurfaceTileService',
    alk.service.RoadSurfaceTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RoutePathService',
    alk.service.RoutePathService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteReportsService',
    alk.service.RouteReportsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.RouteService',
    alk.service.RouteService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchSingleSearchService',
    alk.service.SearchSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.SearchTypesSingleSearchService',
    alk.service.SearchTypesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.ServiceBase',
    alk.service.ServiceBase,
    ALKMAPS);

goog.exportProperty(
    alk.service.ServiceBase.prototype,
    'getServiceOptions',
    alk.service.ServiceBase.prototype.getServiceOptions);

goog.exportSymbol(
    'alk.service.Service',
    alk.service.Service,
    ALKMAPS);

goog.exportProperty(
    alk.service.Service.prototype,
    'getURL',
    alk.service.Service.prototype.getURL);

goog.exportProperty(
    alk.service.Service.prototype,
    'get',
    alk.service.Service.prototype.get);

goog.exportProperty(
    alk.service.Service.prototype,
    'processResponse',
    alk.service.Service.prototype.processResponse);

goog.exportProperty(
    alk.service.Service.prototype,
    'getAttribution',
    alk.service.Service.prototype.getAttribution);

goog.exportSymbol(
    'alk.service.StatesSingleSearchService',
    alk.service.StatesSingleSearchService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCameraMetadataService',
    alk.service.TrafficCameraMetadataService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficCamerasService',
    alk.service.TrafficCamerasService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficIncidentsService',
    alk.service.TrafficIncidentsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.TrafficTileService',
    alk.service.TrafficTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherAlertsService',
    alk.service.WeatherAlertsService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.WeatherImageTileService',
    alk.service.WeatherImageTileService,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgCheck',
    alk.service.setArgCheck,
    ALKMAPS);

goog.exportSymbol(
    'alk.service.setArgPermissive',
    alk.service.setArgPermissive,
    ALKMAPS);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'get',
    alk.service.CountriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.CountriesSingleSearchService.prototype,
    'processResponse',
    alk.service.CountriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'get',
    alk.service.DriveTimePolygonService.prototype.get);

goog.exportProperty(
    alk.service.DriveTimePolygonService.prototype,
    'processResponse',
    alk.service.DriveTimePolygonService.prototype.processResponse);

goog.exportProperty(
    alk.service.LocationsReverseService.prototype,
    'get',
    alk.service.LocationsReverseService.prototype.get);

goog.exportProperty(
    alk.service.LocationsService.prototype,
    'get',
    alk.service.LocationsService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'get',
    alk.service.POICategoriesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.POICategoriesSingleSearchService.prototype,
    'processResponse',
    alk.service.POICategoriesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.POIService.prototype,
    'get',
    alk.service.POIService.prototype.get);

goog.exportProperty(
    alk.service.POIService.prototype,
    'processResponse',
    alk.service.POIService.prototype.processResponse);

goog.exportProperty(
    alk.service.PolygonsCountyService.prototype,
    'get',
    alk.service.PolygonsCountyService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'get',
    alk.service.RoadSurfaceRouteService.prototype.get);

goog.exportProperty(
    alk.service.RoadSurfaceRouteService.prototype,
    'processResponse',
    alk.service.RoadSurfaceRouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.RouteReportsService.prototype,
    'get',
    alk.service.RouteReportsService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'get',
    alk.service.RouteService.prototype.get);

goog.exportProperty(
    alk.service.RouteService.prototype,
    'processResponse',
    alk.service.RouteService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'get',
    alk.service.SearchSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'get',
    alk.service.SearchTypesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.SearchTypesSingleSearchService.prototype,
    'processResponse',
    alk.service.SearchTypesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'get',
    alk.service.StatesSingleSearchService.prototype.get);

goog.exportProperty(
    alk.service.StatesSingleSearchService.prototype,
    'processResponse',
    alk.service.StatesSingleSearchService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficCameraMetadataService.prototype,
    'get',
    alk.service.TrafficCameraMetadataService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'get',
    alk.service.TrafficCamerasService.prototype.get);

goog.exportProperty(
    alk.service.TrafficCamerasService.prototype,
    'processResponse',
    alk.service.TrafficCamerasService.prototype.processResponse);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'get',
    alk.service.TrafficIncidentsService.prototype.get);

goog.exportProperty(
    alk.service.TrafficIncidentsService.prototype,
    'processResponse',
    alk.service.TrafficIncidentsService.prototype.processResponse);

goog.exportProperty(
    alk.service.WeatherAlertsService.prototype,
    'get',
    alk.service.WeatherAlertsService.prototype.get);

goog.exportSymbol(
    'alk.source.BaseMapSource',
    alk.source.BaseMapSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.DriveTimePolygon',
    alk.source.DriveTimePolygon,
    ALKMAPS);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'getDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.getDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'setDriveTimePolygonService',
    alk.source.DriveTimePolygon.prototype.setDriveTimePolygonService);

goog.exportProperty(
    alk.source.DriveTimePolygon.prototype,
    'addDriveTimePolygon',
    alk.source.DriveTimePolygon.prototype.addDriveTimePolygon);

goog.exportSymbol(
    'alk.source.EditTrailRoute',
    alk.source.EditTrailRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'pushRoute',
    alk.source.EditTrailRoute.prototype.pushRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'prevRoute',
    alk.source.EditTrailRoute.prototype.prevRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'nextRoute',
    alk.source.EditTrailRoute.prototype.nextRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'resetEditTrail',
    alk.source.EditTrailRoute.prototype.resetEditTrail);

goog.exportSymbol(
    'alk.source.ImageTileSource',
    alk.source.ImageTileSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.LoadStrategy',
    alk.source.LoadStrategy,
    ALKMAPS);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMinResolution',
    alk.source.LoadStrategy.prototype.getMinResolution);

goog.exportProperty(
    alk.source.LoadStrategy.prototype,
    'getMaxResolution',
    alk.source.LoadStrategy.prototype.getMaxResolution);

goog.exportSymbol(
    'alk.source.MultiRoute',
    alk.source.MultiRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceResponse',
    alk.source.MultiRoute.prototype.getRouteServiceResponse);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'addRoute',
    alk.source.MultiRoute.prototype.addRoute);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteFeatures',
    alk.source.MultiRoute.prototype.getRouteFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getLineFeatures',
    alk.source.MultiRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteIds',
    alk.source.MultiRoute.prototype.getRouteIds);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'getRouteServiceOptions',
    alk.source.MultiRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.MultiRoute.prototype,
    'removeRoute',
    alk.source.MultiRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.POISource',
    alk.source.POISource,
    ALKMAPS);

goog.exportProperty(
    alk.source.POISource.prototype,
    'getPOIService',
    alk.source.POISource.prototype.getPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'setPOIService',
    alk.source.POISource.prototype.setPOIService);

goog.exportProperty(
    alk.source.POISource.prototype,
    'clonePOIServiceOptions',
    alk.source.POISource.prototype.clonePOIServiceOptions);

goog.exportProperty(
    alk.source.POISource.prototype,
    'processResponse',
    alk.source.POISource.prototype.processResponse);

goog.exportProperty(
    alk.source.POISource.prototype,
    'search',
    alk.source.POISource.prototype.search);

goog.exportSymbol(
    'alk.source.PolygonsCountyCache',
    alk.source.PolygonsCountyCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'getPolygonForCountyCode',
    alk.source.PolygonsCountyCache.prototype.getPolygonForCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'queueCountyCode',
    alk.source.PolygonsCountyCache.prototype.queueCountyCode);

goog.exportProperty(
    alk.source.PolygonsCountyCache.prototype,
    'processQueue',
    alk.source.PolygonsCountyCache.prototype.processQueue);

goog.exportSymbol(
    'alk.source.RoadSurfaceRoute',
    alk.source.RoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'getRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.getRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'setRoadSurfaceRouteService',
    alk.source.RoadSurfaceRoute.prototype.setRoadSurfaceRouteService);

goog.exportProperty(
    alk.source.RoadSurfaceRoute.prototype,
    'cloneRoadSurfaceRouteServiceOptions',
    alk.source.RoadSurfaceRoute.prototype.cloneRoadSurfaceRouteServiceOptions);

goog.exportSymbol(
    'alk.source.RoadSurfaceTileSource',
    alk.source.RoadSurfaceTileSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'getRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.getRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'setRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.setRoadSurfaceTileService);

goog.exportProperty(
    alk.source.RoadSurfaceTileSource.prototype,
    'changeRoadSurfaceTileService',
    alk.source.RoadSurfaceTileSource.prototype.changeRoadSurfaceTileService);

goog.exportSymbol(
    'alk.source.Route',
    alk.source.Route,
    ALKMAPS);

goog.exportProperty(
    alk.source.Route.prototype,
    'getRouteService',
    alk.source.Route.prototype.getRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'setRouteService',
    alk.source.Route.prototype.setRouteService);

goog.exportProperty(
    alk.source.Route.prototype,
    'cloneRouteServiceOptions',
    alk.source.Route.prototype.cloneRouteServiceOptions);

goog.exportSymbol(
    'alk.source.SingleRoadSurfaceRoute',
    alk.source.SingleRoadSurfaceRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'setRoute',
    alk.source.SingleRoadSurfaceRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoadSurfaceRoute.prototype,
    'clear',
    alk.source.SingleRoadSurfaceRoute.prototype.clear);

goog.exportSymbol(
    'alk.source.SingleRoute',
    alk.source.SingleRoute,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'setRoute',
    alk.source.SingleRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRoute',
    alk.source.SingleRoute.prototype.getRoute);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getStopFeatures',
    alk.source.SingleRoute.prototype.getStopFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getLineFeatures',
    alk.source.SingleRoute.prototype.getLineFeatures);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'getRouteServiceOptions',
    alk.source.SingleRoute.prototype.getRouteServiceOptions);

goog.exportProperty(
    alk.source.SingleRoute.prototype,
    'removeRoute',
    alk.source.SingleRoute.prototype.removeRoute);

goog.exportSymbol(
    'alk.source.SingleSearch',
    alk.source.SingleSearch,
    ALKMAPS);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchSingleSearchService',
    alk.source.SingleSearch.prototype.getSearchSingleSearchService);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'search',
    alk.source.SingleSearch.prototype.search);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'searchResult',
    alk.source.SingleSearch.prototype.searchResult);

goog.exportProperty(
    alk.source.SingleSearch.prototype,
    'getSearchResult',
    alk.source.SingleSearch.prototype.getSearchResult);

goog.exportSymbol(
    'alk.source.SubtractionLoadStrategy',
    alk.source.SubtractionLoadStrategy,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.TrafficCameraMetadataCache',
    alk.source.TrafficCameraMetadataCache,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'store',
    alk.source.TrafficCameraMetadataCache.prototype.store);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'retrieve',
    alk.source.TrafficCameraMetadataCache.prototype.retrieve);

goog.exportProperty(
    alk.source.TrafficCameraMetadataCache.prototype,
    'get',
    alk.source.TrafficCameraMetadataCache.prototype.get);

goog.exportSymbol(
    'alk.source.TrafficCamerasSource',
    alk.source.TrafficCamerasSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.getTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'setTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.setTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'changeTrafficCamerasService',
    alk.source.TrafficCamerasSource.prototype.changeTrafficCamerasService);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficCamerasSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficCamerasSource.prototype,
    'getTrafficCameras',
    alk.source.TrafficCamerasSource.prototype.getTrafficCameras);

goog.exportSymbol(
    'alk.source.TrafficIncidentsSource',
    alk.source.TrafficIncidentsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'setTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.setTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'changeTrafficIncidentsService',
    alk.source.TrafficIncidentsSource.prototype.changeTrafficIncidentsService);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'removeAllFeatures',
    alk.source.TrafficIncidentsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.TrafficIncidentsSource.prototype,
    'getTrafficIncidents',
    alk.source.TrafficIncidentsSource.prototype.getTrafficIncidents);

goog.exportSymbol(
    'alk.source.TrafficSource',
    alk.source.TrafficSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.WeatherAlertsSource',
    alk.source.WeatherAlertsSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'setWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.setWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'changeWeatherAlertsService',
    alk.source.WeatherAlertsSource.prototype.changeWeatherAlertsService);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'removeAllFeatures',
    alk.source.WeatherAlertsSource.prototype.removeAllFeatures);

goog.exportProperty(
    alk.source.WeatherAlertsSource.prototype,
    'getWeatherAlerts',
    alk.source.WeatherAlertsSource.prototype.getWeatherAlerts);

goog.exportSymbol(
    'alk.source.WeatherSource',
    alk.source.WeatherSource,
    ALKMAPS);

goog.exportSymbol(
    'alk.source.XYZSource',
    alk.source.XYZSource,
    ALKMAPS);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'setService',
    alk.source.XYZSource.prototype.setService);

goog.exportProperty(
    alk.source.XYZSource.prototype,
    'service',
    alk.source.XYZSource.prototype.service);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'setRoute',
    alk.source.EditTrailRoute.prototype.setRoute);

goog.exportProperty(
    alk.source.EditTrailRoute.prototype,
    'getRouteServiceOptions',
    alk.source.EditTrailRoute.prototype.getRouteServiceOptions);

goog.exportSymbol(
    'alk.style.Arrow',
    alk.style.Arrow,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.ArrowsRouteStyle',
    alk.style.ArrowsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'getArrow',
    alk.style.ArrowsRouteStyle.prototype.getArrow);

goog.exportSymbol(
    'alk.style.DriveTimeLayerStyle',
    alk.style.DriveTimeLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.EditRouteStyle',
    alk.style.EditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.WayPointsEditRouteStyle',
    alk.style.WayPointsEditRouteStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.IconPOILayerStyle',
    alk.style.IconPOILayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.LineRouteStyle',
    alk.style.LineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setStrokeStyle',
    alk.style.LineRouteStyle.prototype.setStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.setUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.LineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.LineRouteStyle.prototype.getStrokeStyle);

goog.exportSymbol(
    'alk.style.POIIconFactory',
    alk.style.POIIconFactory,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.POILayerStyle',
    alk.style.POILayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'layer',
    alk.style.POILayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setLayer',
    alk.style.POILayerStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'setUpdating',
    alk.style.POILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.POILayerStyle.prototype,
    'styleFunction',
    alk.style.POILayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.PolygonWeatherAlertsLayerStyle',
    alk.style.PolygonWeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.QueuedLineRouteStyle',
    alk.style.QueuedLineRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'setStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.setStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeQueue',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeQueue);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'clearStrokeForRouteId',
    alk.style.QueuedLineRouteStyle.prototype.clearStrokeForRouteId);

goog.exportSymbol(
    'alk.style.QueuedStyleLayerStyle',
    alk.style.QueuedStyleLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'setStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.setStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'getStyleQueue',
    alk.style.QueuedStyleLayerStyle.prototype.getStyleQueue);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'clearStyleForId',
    alk.style.QueuedStyleLayerStyle.prototype.clearStyleForId);

goog.exportSymbol(
    'alk.style.RoadSurfaceStyle',
    alk.style.RoadSurfaceStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'layer',
    alk.style.RoadSurfaceStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'setUpdating',
    alk.style.RoadSurfaceStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoadSurfaceStyle.prototype,
    'styleFunction',
    alk.style.RoadSurfaceStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.RoutingLayerStyle',
    alk.style.RoutingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'layer',
    alk.style.RoutingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'setUpdating',
    alk.style.RoutingLayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.RoutingLayerStyle.prototype,
    'styleFunction',
    alk.style.RoutingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.Shadow',
    alk.style.Shadow,
    ALKMAPS);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getOrigin',
    alk.style.Shadow.prototype.getOrigin);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getRadius',
    alk.style.Shadow.prototype.getRadius);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getHitDetectionImageSize',
    alk.style.Shadow.prototype.getHitDetectionImageSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getAnchor',
    alk.style.Shadow.prototype.getAnchor);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getSize',
    alk.style.Shadow.prototype.getSize);

goog.exportProperty(
    alk.style.Shadow.prototype,
    'getFill',
    alk.style.Shadow.prototype.getFill);

goog.exportSymbol(
    'alk.style.ShadowedCircle',
    alk.style.ShadowedCircle,
    ALKMAPS);

goog.exportSymbol(
    'alk.style.SingleSearchStyle',
    alk.style.SingleSearchStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'layer',
    alk.style.SingleSearchStyle.prototype.layer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setLayer',
    alk.style.SingleSearchStyle.prototype.setLayer);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'setUpdating',
    alk.style.SingleSearchStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.SingleSearchStyle.prototype,
    'styleFunction',
    alk.style.SingleSearchStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.StopsRouteStyle',
    alk.style.StopsRouteStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.StopsRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.StopsRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.StopsRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'defaultWayPointImage',
    alk.style.StopsRouteStyle.prototype.defaultWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginImage',
    alk.style.StopsRouteStyle.prototype.getOriginImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getOriginStyleFunction',
    alk.style.StopsRouteStyle.prototype.getOriginStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointImage',
    alk.style.StopsRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointImage',
    alk.style.StopsRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getViaPointStyleFunction',
    alk.style.StopsRouteStyle.prototype.getViaPointStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationImage',
    alk.style.StopsRouteStyle.prototype.getDestinationImage);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getDestinationStyleFunction',
    alk.style.StopsRouteStyle.prototype.getDestinationStyleFunction);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'getStopStyle',
    alk.style.StopsRouteStyle.prototype.getStopStyle);

goog.exportSymbol(
    'alk.style.StrokeQueue',
    alk.style.StrokeQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'getWidth',
    alk.style.StrokeQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'setWidth',
    alk.style.StrokeQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'strokes',
    alk.style.StrokeQueue.prototype.strokes);

goog.exportProperty(
    alk.style.StrokeQueue.prototype,
    'next',
    alk.style.StrokeQueue.prototype.next);

goog.exportSymbol(
    'alk.style.StyleQueue',
    alk.style.StyleQueue,
    ALKMAPS);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'getWidth',
    alk.style.StyleQueue.prototype.getWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'setWidth',
    alk.style.StyleQueue.prototype.setWidth);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'styles',
    alk.style.StyleQueue.prototype.styles);

goog.exportProperty(
    alk.style.StyleQueue.prototype,
    'next',
    alk.style.StyleQueue.prototype.next);

goog.exportSymbol(
    'alk.style.TrafficCamerasLayerStyle',
    alk.style.TrafficCamerasLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficCamerasLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficCamerasLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficCamerasLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.TrafficIncidentsLayerStyle',
    alk.style.TrafficIncidentsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'defaultIconURL',
    alk.style.TrafficIncidentsLayerStyle.prototype.defaultIconURL);

goog.exportProperty(
    alk.style.TrafficIncidentsLayerStyle.prototype,
    'styleFunction',
    alk.style.TrafficIncidentsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.UpdatingLayerStyle',
    alk.style.UpdatingLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'layer',
    alk.style.UpdatingLayerStyle.prototype.layer);

goog.exportProperty(
    alk.style.UpdatingLayerStyle.prototype,
    'styleFunction',
    alk.style.UpdatingLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.style.WeatherAlertsLayerStyle',
    alk.style.WeatherAlertsLayerStyle,
    ALKMAPS);

goog.exportProperty(
    alk.style.WeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.WeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'setUpdating',
    alk.style.LineRouteStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.LineRouteStyle.prototype,
    'styleFunction',
    alk.style.LineRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getUpdateStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getUpdateStrokeStyle);

goog.exportProperty(
    alk.style.QueuedLineRouteStyle.prototype,
    'getStrokeStyle',
    alk.style.QueuedLineRouteStyle.prototype.getStrokeStyle);

goog.exportProperty(
    alk.style.StopsRouteStyle.prototype,
    'styleFunction',
    alk.style.StopsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.ArrowsRouteStyle.prototype,
    'styleFunction',
    alk.style.ArrowsRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.QueuedStyleLayerStyle.prototype,
    'styleFunction',
    alk.style.QueuedStyleLayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.EditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.EditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.EditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.EditRouteStyle.prototype,
    'styleFunction',
    alk.style.EditRouteStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getViaPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getViaPointImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointStyleFunction',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointStyleFunction);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultOriginImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultOriginImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'defaultDestinationImage',
    alk.style.WayPointsEditRouteStyle.prototype.defaultDestinationImage);

goog.exportProperty(
    alk.style.WayPointsEditRouteStyle.prototype,
    'getWayPointImage',
    alk.style.WayPointsEditRouteStyle.prototype.getWayPointImage);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'setUpdating',
    alk.style.IconPOILayerStyle.prototype.setUpdating);

goog.exportProperty(
    alk.style.IconPOILayerStyle.prototype,
    'styleFunction',
    alk.style.IconPOILayerStyle.prototype.styleFunction);

goog.exportProperty(
    alk.style.PolygonWeatherAlertsLayerStyle.prototype,
    'styleFunction',
    alk.style.PolygonWeatherAlertsLayerStyle.prototype.styleFunction);

goog.exportSymbol(
    'alk.val.ArrowsType.None',
    alk.val.ArrowsType.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.Line',
    alk.val.ArrowsType.Line,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ArrowsType.End',
    alk.val.ArrowsType.End,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.All',
    alk.val.Certainty.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Observed',
    alk.val.Certainty.Observed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Likely',
    alk.val.Certainty.Likely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Possible',
    alk.val.Certainty.Possible,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unlikely',
    alk.val.Certainty.Unlikely,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Certainty.Unknown',
    alk.val.Certainty.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.Current',
    alk.val.Dataset.Current,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_EU',
    alk.val.Dataset.PCM_EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_OC',
    alk.val.Dataset.PCM_OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SA',
    alk.val.Dataset.PCM_SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_GT',
    alk.val.Dataset.PCM_GT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AF',
    alk.val.Dataset.PCM_AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_AS',
    alk.val.Dataset.PCM_AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_ME',
    alk.val.Dataset.PCM_ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_SE',
    alk.val.Dataset.PCM_SE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Dataset.PCM_NA',
    alk.val.Dataset.PCM_NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Radar',
    alk.val.Display.Radar,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Display.Satellite',
    alk.val.Display.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Miles',
    alk.val.DistanceUnits.Miles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DistanceUnits.Kilometers',
    alk.val.DistanceUnits.Kilometers,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Cities',
    alk.val.DrawerGroup.Cities,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Labels',
    alk.val.DrawerGroup.Labels,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Roads',
    alk.val.DrawerGroup.Roads,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Commercial',
    alk.val.DrawerGroup.Commercial,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Borders',
    alk.val.DrawerGroup.Borders,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.DrawerGroup.Areas',
    alk.val.DrawerGroup.Areas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Format.ImagePNG',
    alk.val.Format.ImagePNG,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Gallons',
    alk.val.FuelUnits.Gallons,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.FuelUnits.Liters',
    alk.val.FuelUnits.Liters,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.None',
    alk.val.HazMat.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.General',
    alk.val.HazMat.General,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Caustic',
    alk.val.HazMat.Caustic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Explosives',
    alk.val.HazMat.Explosives,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Flammable',
    alk.val.HazMat.Flammable,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Inhalants',
    alk.val.HazMat.Inhalants,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HazMat.Radioactive',
    alk.val.HazMat.Radioactive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Monday',
    alk.val.HistDay.Monday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Tuesday',
    alk.val.HistDay.Tuesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Wednesday',
    alk.val.HistDay.Wednesday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Thursday',
    alk.val.HistDay.Thursday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Friday',
    alk.val.HistDay.Friday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Saturday',
    alk.val.HistDay.Saturday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HistDay.Sunday',
    alk.val.HistDay.Sunday,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed607LH',
    alk.val.HosRuleType.USFed607LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.HosRuleType.USFed708LH',
    alk.val.HosRuleType.USFed708LH,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Background',
    alk.val.ImgOption.Background,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Foreground',
    alk.val.ImgOption.Foreground,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgOption.Both',
    alk.val.ImgOption.Both,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Default',
    alk.val.ImgSrc.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.ALKCurated',
    alk.val.ImgSrc.ALKCurated,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat1',
    alk.val.ImgSrc.Sat1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat2',
    alk.val.ImgSrc.Sat2,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat3',
    alk.val.ImgSrc.Sat3,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat4',
    alk.val.ImgSrc.Sat4,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat5',
    alk.val.ImgSrc.Sat5,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ImgSrc.Sat6',
    alk.val.ImgSrc.Sat6,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENUS',
    alk.val.Language.ENUS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ENGB',
    alk.val.Language.ENGB,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.DE',
    alk.val.Language.DE,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.FR',
    alk.val.Language.FR,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.ES',
    alk.val.Language.ES,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Language.IT',
    alk.val.Language.IT,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.NationalNetwork',
    alk.val.OverrideClass.NationalNetwork,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.OverrideClass.FiftyThreeFoot',
    alk.val.OverrideClass.FiftyThreeFoot,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.All',
    alk.val.POICategory.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.City',
    alk.val.POICategory.City,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Zip',
    alk.val.POICategory.Zip,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Place',
    alk.val.POICategory.Place,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Airport',
    alk.val.POICategory.Airport,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Automotive',
    alk.val.POICategory.Automotive,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.WeighStation',
    alk.val.POICategory.WeighStation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Dining',
    alk.val.POICategory.Dining,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Education',
    alk.val.POICategory.Education,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Emergency',
    alk.val.POICategory.Emergency,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Government',
    alk.val.POICategory.Government,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Gas',
    alk.val.POICategory.Gas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Lodging',
    alk.val.POICategory.Lodging,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Parks',
    alk.val.POICategory.Parks,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Retail',
    alk.val.POICategory.Retail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.SportsRec',
    alk.val.POICategory.SportsRec,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Travel',
    alk.val.POICategory.Travel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.TruckServices',
    alk.val.POICategory.TruckServices,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.POICategory.Attractions',
    alk.val.POICategory.Attractions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.Default',
    alk.val.Provider.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Provider.RC1',
    alk.val.Provider.RC1,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.NA',
    alk.val.Region.NA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.EU',
    alk.val.Region.EU,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.OC',
    alk.val.Region.OC,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.SA',
    alk.val.Region.SA,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AF',
    alk.val.Region.AF,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.AS',
    alk.val.Region.AS,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Region.ME',
    alk.val.Region.ME,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.ReportFormat.JSON',
    alk.val.ReportFormat.JSON,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.CalcMiles',
    alk.val.Report.CalcMiles,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Mileage',
    alk.val.Report.Mileage,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Directions',
    alk.val.Report.Directions,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.State',
    alk.val.Report.State,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Detail',
    alk.val.Report.Detail,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.Road',
    alk.val.Report.Road,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Report.GeoTunnel',
    alk.val.Report.GeoTunnel,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.None',
    alk.val.RouteOptimization.None,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.ThruAll',
    alk.val.RouteOptimization.ThruAll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteOptimization.DestinationFixed',
    alk.val.RouteOptimization.DestinationFixed,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Practical',
    alk.val.RouteType.Practical,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.RouteType.Shortest',
    alk.val.RouteType.Shortest,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.All',
    alk.val.Severity.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Extreme',
    alk.val.Severity.Extreme,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Severe',
    alk.val.Severity.Severe,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Moderate',
    alk.val.Severity.Moderate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Minor',
    alk.val.Severity.Minor,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Severity.Unknown',
    alk.val.Severity.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG900913',
    alk.val.SRS.EPSG900913,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG4326',
    alk.val.SRS.EPSG4326,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.SRS.EPSG3857',
    alk.val.SRS.EPSG3857,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Origin',
    alk.val.StopType.Origin,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.WayPoint',
    alk.val.StopType.WayPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.Destination',
    alk.val.StopType.Destination,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.StopType.ViaPoint',
    alk.val.StopType.ViaPoint,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Transportation',
    alk.val.Style.Transportation,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataDark',
    alk.val.Style.DataDark,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.DataLight',
    alk.val.Style.DataLight,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Basic',
    alk.val.Style.Basic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Default',
    alk.val.Style.Default,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Classic',
    alk.val.Style.Classic,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Monochrome',
    alk.val.Style.Monochrome,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.RoadAtlas',
    alk.val.Style.RoadAtlas,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Night',
    alk.val.Style.Night,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Satellite',
    alk.val.Style.Satellite,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Lightness',
    alk.val.Style.Lightness,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Smooth',
    alk.val.Style.Smooth,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Terrain',
    alk.val.Style.Terrain,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Style.Modern',
    alk.val.Style.Modern,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.US',
    alk.val.TollCurrency.US,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollCurrency.CDN',
    alk.val.TollCurrency.CDN,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.All',
    alk.val.TollPlan.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.C407ETRTransponder',
    alk.val.TollPlan.C407ETRTransponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.A25Transponder',
    alk.val.TollPlan.A25Transponder,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.BreezeBy',
    alk.val.TollPlan.BreezeBy,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CPass',
    alk.val.TollPlan.CPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.CruiseCard',
    alk.val.TollPlan.CruiseCard,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPass',
    alk.val.TollPlan.EPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EPassCanada',
    alk.val.TollPlan.EPassCanada,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EXpressToll',
    alk.val.TollPlan.EXpressToll,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZTag',
    alk.val.TollPlan.EZTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPass',
    alk.val.TollPlan.EZPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassNJ',
    alk.val.TollPlan.EZPassNJ,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.EZPassWV',
    alk.val.TollPlan.EZPassWV,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FastLane',
    alk.val.TollPlan.FastLane,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.FasTrak',
    alk.val.TollPlan.FasTrak,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GeauxPass',
    alk.val.TollPlan.GeauxPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GoodToGo',
    alk.val.TollPlan.GoodToGo,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.GOPass',
    alk.val.TollPlan.GOPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IPass',
    alk.val.TollPlan.IPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.IZoom',
    alk.val.TollPlan.IZoom,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.KTag',
    alk.val.TollPlan.KTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LaredoTradeTag',
    alk.val.TollPlan.LaredoTradeTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.LeeWay',
    alk.val.TollPlan.LeeWay,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.MacPass',
    alk.val.TollPlan.MacPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NCQuickPass',
    alk.val.TollPlan.NCQuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.NEXPress',
    alk.val.TollPlan.NEXPress,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PalmettoPass',
    alk.val.TollPlan.PalmettoPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PeachPass',
    alk.val.TollPlan.PeachPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.PikePass',
    alk.val.TollPlan.PikePass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.QuickPass',
    alk.val.TollPlan.QuickPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SmartTag',
    alk.val.TollPlan.SmartTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.StraitPass',
    alk.val.TollPlan.StraitPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.SunPass',
    alk.val.TollPlan.SunPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TollTag',
    alk.val.TollPlan.TollTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.TxTag',
    alk.val.TollPlan.TxTag,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TollPlan.WalbashPass',
    alk.val.TollPlan.WalbashPass,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentyEightDoubleTrailer',
    alk.val.TruckConfig.TwentyEightDoubleTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyStraightTruck',
    alk.val.TruckConfig.FortyStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FortyEightSemiTrailer',
    alk.val.TruckConfig.FortyEightSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FiftyThreeSemiTrailer',
    alk.val.TruckConfig.FiftyThreeSemiTrailer,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.FullSizeVan',
    alk.val.TruckConfig.FullSizeVan,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.TruckConfig.TwentySixStraightTruck',
    alk.val.TruckConfig.TwentySixStraightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.All',
    alk.val.Urgency.All,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Immediate',
    alk.val.Urgency.Immediate,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Expected',
    alk.val.Urgency.Expected,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Future',
    alk.val.Urgency.Future,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Past',
    alk.val.Urgency.Past,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.Urgency.Unknown',
    alk.val.Urgency.Unknown,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.English',
    alk.val.VehicleDimensionUnits.English,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleDimensionUnits.Metric',
    alk.val.VehicleDimensionUnits.Metric,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Truck',
    alk.val.VehicleType.Truck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.LightTruck',
    alk.val.VehicleType.LightTruck,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.VehicleType.Auto',
    alk.val.VehicleType.Auto,
    ALKMAPS);

goog.exportSymbol(
    'alk.val.WeatherAlertColor',
    alk.val.WeatherAlertColor,
    ALKMAPS);
alk.VERSION = '2.0.0';

  return ALKMAPS;
}));
